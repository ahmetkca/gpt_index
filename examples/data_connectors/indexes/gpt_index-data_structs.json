{"index_struct": {"text": "\nThe documents contain data structures used to create a GPT index. These include the IndexStruct class, which is a base data structure for a GPT index, and the Node class, which is a generic node of data used in most indices. It also includes the IndexGraph, KeywordTable, IndexList, IndexDict, SimpleIndexDict, WeaviateIndexStruct, and QdrantIndexStruct classes, which are all used to compose a higher level index. These classes have methods and properties such as get_text(), get_type(), size, get_children(), insert_under_parent(), add_node(), get_texts(), keywords, add_node(), get_nodes(), and get_node(). Additionally, the StructDatapoint and BaseStructTable classes are used to store struct outputs, and the SQLStructTable class is used to store SQL struct outputs.", "doc_id": "e9ed3920-45b1-46ff-bea1-efbbcf8f678c", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"Init file.\"\"\"\n\nfrom gpt_index.data_structs.data_structs import (\n    IndexDict,\n    IndexGraph,\n    IndexList,\n    KeywordTable,\n    Node,\n    QdrantIndexStruct,\n    SimpleIndexDict,\n    WeaviateIndexStruct,\n)\nfrom gpt_index.data_structs.table import StructDatapoint\n\n__all__ = [\n    \"Node\",\n    \"IndexGraph\",\n    \"KeywordTable\",\n    \"IndexList\",\n    \"IndexDict\",\n    \"SimpleIndexDict\",\n    \"WeaviateIndexStruct\",\n    \"QdrantIndexStruct\",\n    \"StructDatapoint\",\n]\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/__init__.py", "file_name": "__init__.py"}, "index": 0, "child_indices": [], "ref_doc_id": "73f0f8d7e49d0fc9866dbe8a9d799396b09b1a74", "node_info": null}, "1": {"text": "\"\"\"File for core data structures.\"\"\"\n\nimport random\nimport sys\nfrom dataclasses import dataclass, field\nfrom typing import Any, Dict, List, Optional, Set\n\nfrom dataclasses_json import DataClassJsonMixin\n\nfrom gpt_index.schema import BaseDocument\nfrom gpt_index.utils import get_new_int_id\n\n\n@dataclass\nclass IndexStruct(BaseDocument, DataClassJsonMixin):\n    \"\"\"A base data struct for a GPT index.\"\"\"\n\n    # NOTE: the text field, inherited from BaseDocument,\n    # represents a summary of the content of the index struct.\n    # primarily used for composing indices with other indices\n\n    # NOTE: the doc_id field, inherited from BaseDocument,\n    # represents a unique identifier for the index struct\n    # that will be put in the docstore.\n    # Not all index_structs need to have a doc_id. Only index_structs that\n    # represent a complete data structure (e.g. IndexGraph, IndexList),\n    # and are used to", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 1, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "2": {"text": "IndexGraph, IndexList),\n    # and are used to compose a higher level index, will have a doc_id.\n\n\n@dataclass\nclass Node(IndexStruct):\n    \"\"\"A generic node of data.\n\n    Base struct used in most indices.\n\n    \"\"\"\n\n    def __post_init__(self) -> None:\n        \"\"\"Post init.\"\"\"\n        # NOTE: for Node objects, the text field is required\n        if self.text is None:\n            raise ValueError(\"text field not set.\")\n\n    # used for GPTTreeIndex\n    index: int = 0\n    child_indices: Set[int] = field(default_factory=set)\n\n    # embeddings\n    embedding: Optional[List[float]] = None\n\n    # reference document id\n    ref_doc_id: Optional[str] = None\n\n    # extra node info\n    node_info: Optional[Dict[str, Any]] = None\n\n    def", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 2, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "3": {"text": "Optional[Dict[str, Any]] = None\n\n    def get_text(self) -> str:\n        \"\"\"Get text.\"\"\"\n        text = super().get_text()\n        result_text = (\n            text if self.extra_info_str is None else f\"{self.extra_info_str}\\n\\n{text}\"\n        )\n        return result_text\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        # TODO: consolidate with IndexStructType\n        return \"node\"\n\n\n@dataclass\nclass IndexGraph(IndexStruct):\n    \"\"\"A graph representing the tree-structured index.\"\"\"\n\n    all_nodes: Dict[int, Node] = field(default_factory=dict)\n    root_nodes: Dict[int, Node] = field(default_factory=dict)\n\n ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 3, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "4": {"text": "Node] = field(default_factory=dict)\n\n    @property\n    def size(self) -> int:\n        \"\"\"Get the size of the graph.\"\"\"\n        return len(self.all_nodes)\n\n    def get_children(self, parent_node: Optional[Node]) -> Dict[int, Node]:\n        \"\"\"Get nodes given indices.\"\"\"\n        if parent_node is None:\n            return self.root_nodes\n        else:\n            return {i: self.all_nodes[i] for i in parent_node.child_indices}\n\n    def insert_under_parent(self, node: Node, parent_node: Optional[Node]) -> None:\n        \"\"\"Insert under parent node.\"\"\"\n        if node.index in self.all_nodes:\n            raise ValueError(\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 4, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "5": {"text": "raise ValueError(\n                \"Cannot insert a new node with the same index as an existing node.\"\n            )\n        if parent_node is None:\n            self.root_nodes[node.index] = node\n        else:\n            parent_node.child_indices.add(node.index)\n\n        self.all_nodes[node.index] = node\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"tree\"\n\n\n@dataclass\nclass KeywordTable(IndexStruct):\n    \"\"\"A table of keywords mapping keywords to text chunks.\"\"\"\n\n    table: Dict[str, Set[int]] = field(default_factory=dict)\n    text_chunks: Dict[int, Node] = field(default_factory=dict)\n\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 5, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "6": {"text": "Node] = field(default_factory=dict)\n\n    def _get_index(self) -> int:\n        \"\"\"Get the next index for the text chunk.\"\"\"\n        # randomly generate until we get a unique index\n        while True:\n            idx = random.randint(0, sys.maxsize)\n            if idx not in self.text_chunks:\n                break\n        return idx\n\n    def add_node(self, keywords: List[str], node: Node) -> int:\n        \"\"\"Add text to table.\"\"\"\n        cur_idx = self._get_index()\n        for keyword in keywords:\n            if keyword not in self.table:\n                self.table[keyword] = set()\n   ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 6, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "7": {"text": "  self.table[keyword] = set()\n            self.table[keyword].add(cur_idx)\n        self.text_chunks[cur_idx] = node\n        return cur_idx\n\n    def get_texts(self, keyword: str) -> List[str]:\n        \"\"\"Get texts given keyword.\"\"\"\n        if keyword not in self.table:\n            raise ValueError(\"Keyword not found in table.\")\n        return [self.text_chunks[idx].get_text() for idx in self.table[keyword]]\n\n    @property\n    def keywords(self) -> Set[str]:\n        \"\"\"Get all keywords in the table.\"\"\"\n        return set(self.table.keys())\n\n    @property\n    def size(self) -> int:\n        \"\"\"Get the size of the table.\"\"\"\n  ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 7, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "8": {"text": "    \"\"\"Get the size of the table.\"\"\"\n        return len(self.table)\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"keyword_table\"\n\n\n@dataclass\nclass IndexList(IndexStruct):\n    \"\"\"A list of documents.\"\"\"\n\n    nodes: List[Node] = field(default_factory=list)\n\n    def add_node(self, node: Node) -> None:\n        \"\"\"Add text to table, return current position in list.\"\"\"\n        # don't worry about child indices for now, nodes are all in order\n        self.nodes.append(node)\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"list\"\n\n\n@dataclass\nclass BaseIndexDict(IndexStruct):\n    \"\"\"A simple dictionary of", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 8, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "9": {"text": "   \"\"\"A simple dictionary of documents.\"\"\"\n\n    nodes_dict: Dict[int, Node] = field(default_factory=dict)\n    id_map: Dict[str, int] = field(default_factory=dict)\n\n    def add_node(\n        self,\n        node: Node,\n        text_id: Optional[str] = None,\n    ) -> str:\n        \"\"\"Add text to table, return current position in list.\"\"\"\n        int_id = get_new_int_id(set(self.nodes_dict.keys()))\n        if text_id in self.id_map:\n            raise ValueError(\"text_id cannot already exist in index.\")\n        elif text_id is not None and not isinstance(text_id, str):\n            raise ValueError(\"text_id must be a string.\")\n       ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 9, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "10": {"text": "must be a string.\")\n        elif text_id is None:\n            text_id = str(int_id)\n        self.id_map[text_id] = int_id\n\n        # don't worry about child indices for now, nodes are all in order\n        self.nodes_dict[int_id] = node\n        return text_id\n\n    def get_nodes(self, text_ids: List[str]) -> List[Node]:\n        \"\"\"Get nodes.\"\"\"\n        nodes = []\n        for text_id in text_ids:\n            if text_id not in self.id_map:\n                raise ValueError(\"text_id not found in id_map\")\n            elif not isinstance(text_id, str):\n          ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 10, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "11": {"text": "str):\n                raise ValueError(\"text_id must be a string.\")\n            int_id = self.id_map[text_id]\n            if int_id not in self.nodes_dict:\n                raise ValueError(\"int_id not found in nodes_dict\")\n            nodes.append(self.nodes_dict[int_id])\n        return nodes\n\n    def get_node(self, text_id: str) -> Node:\n        \"\"\"Get node.\"\"\"\n        return self.get_nodes([text_id])[0]\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"dict\"\n\n\n# TODO: this should be specific to FAISS\n@dataclass\nclass", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 11, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "12": {"text": "this should be specific to FAISS\n@dataclass\nclass IndexDict(BaseIndexDict):\n    \"\"\"A dictionary of documents.\n\n    Note: this index structure is specifically used with the Faiss index.\n\n    \"\"\"\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"dict\"\n\n\n@dataclass\nclass SimpleIndexDict(BaseIndexDict):\n    \"\"\"A simple dictionary of documents.\n\n    This index structure also contains an internal in-memory\n    embedding dict.\n\n    \"\"\"\n\n    embedding_dict: Dict[str, List[float]] = field(default_factory=dict)\n\n    def add_to_embedding_dict(self, text_id: str, embedding: List[float]) -> None:\n        \"\"\"Add embedding to dict.\"\"\"\n        if text_id not in self.id_map:\n            raise", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 12, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "13": {"text": "           raise ValueError(\"text_id not found in id_map\")\n        elif not isinstance(text_id, str):\n            raise ValueError(\"text_id must be a string.\")\n        self.embedding_dict[text_id] = embedding\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"simple_dict\"\n\n\n@dataclass\nclass WeaviateIndexStruct(IndexStruct):\n    \"\"\"A helper index struct for Weaviate.\n\n    In Weaviate, docs are stored in Weaviate directly.\n    This index struct helps to store the class prefix\n\n    \"\"\"\n\n    class_prefix: Optional[str] = None\n\n    def __post_init__(self) -> None:\n        \"\"\"Post init.\"\"\"\n        if self.class_prefix is None:\n          ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 13, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "14": {"text": "is None:\n            raise ValueError(\"class_prefix must be provided.\")\n\n    def get_class_prefix(self) -> str:\n        \"\"\"Get class prefix.\"\"\"\n        if self.class_prefix is None:\n            raise ValueError(\"class_prefix must be provided.\")\n        return self.class_prefix\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"weaviate\"\n\n\n@dataclass\nclass PineconeIndexStruct(IndexStruct):\n    \"\"\"An index struct for Pinecone.\n\n    Docs are stored in Pinecone directly.\n\n    \"\"\"\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"pinecone\"\n\n\n@dataclass\nclass QdrantIndexStruct(IndexStruct):\n    \"\"\"And", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 14, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "15": {"text": "QdrantIndexStruct(IndexStruct):\n    \"\"\"And index struct for Qdrant.\n\n    Docs are stored in Qdrant directly.\n    This index struct helps to store the collection name\n\n    \"\"\"\n\n    collection_name: Optional[str] = None\n\n    def __post_init__(self) -> None:\n        \"\"\"Post init.\"\"\"\n        if self.collection_name is None:\n            raise ValueError(\"collection_name must be provided.\")\n\n    def get_collection_name(self) -> str:\n        \"\"\"Get class prefix.\"\"\"\n        if self.collection_name is None:\n            raise ValueError(\"collection_name must be provided.\")\n        return self.collection_name\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"qdrant\"\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 15, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "16": {"text": "\"\"\"IndexStructType class.\"\"\"\n\nfrom enum import Enum\n\n\nclass IndexStructType(str, Enum):\n    \"\"\"Index struct type. Identifier for a \"type\" of index.\n\n    Attributes:\n        TREE (\"tree\"): Tree index. See :ref:`Ref-Indices-Tree` for tree indices.\n        LIST (\"list\"): List index. See :ref:`Ref-Indices-List` for list indices.\n        KEYWORD_TABLE (\"keyword_table\"): Keyword table index. See\n            :ref:`Ref-Indices-Table`\n            for keyword table indices.\n        DICT (\"dict\"): Faiss Vector Store Index. See :ref:`Ref-Indices-VectorStore`\n            for more information on the Faiss vector store index.\n        SIMPLE_DICT (\"simple_dict\"): Simple Vector Store Index. See\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/struct_type.py", "file_name": "struct_type.py"}, "index": 16, "child_indices": [], "ref_doc_id": "d75d8d1f3958884352e2c1148a6b9f1dd3e1f626", "node_info": null}, "17": {"text": "Store Index. See\n            :ref:`Ref-Indices-VectorStore`\n            for more information on the simple vector store index.\n        WEAVIATE (\"weaviate\"): Weaviate Vector Store Index.\n            See :ref:`Ref-Indices-VectorStore`\n            for more information on the Weaviate vector store index.\n        PINECONE (\"pinecone\"): Pinecone Vector Store Index.\n            See :ref:`Ref-Indices-VectorStore`\n            for more information on the Pinecone vector store index.\n        QDRANT (\"qdrant\"): Qdrant Vector Store Index.\n            See :ref:`Ref-Indices-VectorStore`\n            for more information on the Qdrant vector store index.\n\n        SQL (\"SQL\"): SQL", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/struct_type.py", "file_name": "struct_type.py"}, "index": 17, "child_indices": [], "ref_doc_id": "d75d8d1f3958884352e2c1148a6b9f1dd3e1f626", "node_info": null}, "18": {"text": "index.\n\n        SQL (\"SQL\"): SQL Structured Store Index.\n            See :ref:`Ref-Indices-StructStore`\n            for more information on the SQL vector store index.\n\n    \"\"\"\n\n    # TODO: refactor so these are properties on the base class\n\n    NODE = \"node\"\n    TREE = \"tree\"\n    LIST = \"list\"\n    KEYWORD_TABLE = \"keyword_table\"\n    # for Faiss\n    # TODO: rename\n    DICT = \"dict\"\n    # for simple embedding index\n    SIMPLE_DICT = \"simple_dict\"\n    # for weaviate index\n    WEAVIATE = \"weaviate\"\n    # for pinecone index\n    PINECONE = \"pinecone\"\n    # for qdrant index\n    QDRANT = \"qdrant\"\n    # for SQL index\n    SQL = \"sql\"\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/struct_type.py", "file_name": "struct_type.py"}, "index": 18, "child_indices": [], "ref_doc_id": "d75d8d1f3958884352e2c1148a6b9f1dd3e1f626", "node_info": null}, "19": {"text": "\"\"\"Struct store schema.\"\"\"\n\nfrom dataclasses import dataclass, field\nfrom typing import Any, Dict\n\nfrom dataclasses_json import DataClassJsonMixin\n\nfrom gpt_index.data_structs.data_structs import IndexStruct\n\n\n@dataclass\nclass StructDatapoint(DataClassJsonMixin):\n    \"\"\"Struct outputs.\"\"\"\n\n    # map from field name to StructValue\n    fields: Dict[str, Any]\n\n\n@dataclass\nclass BaseStructTable(IndexStruct):\n    \"\"\"Struct outputs.\"\"\"\n\n\n@dataclass\nclass SQLStructTable(BaseStructTable):\n    \"\"\"SQL struct outputs.\"\"\"\n\n    context_dict: Dict[str, str] = field(default_factory=dict)\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        # TODO: consolidate with IndexStructType\n        return \"sql\"\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/table.py", "file_name": "table.py"}, "index": 19, "child_indices": [], "ref_doc_id": "a23a646d5f57acd8044f740f0b4a0b683aa20e7f", "node_info": null}, "20": {"text": "This code file contains data structures used in a GPT index. It includes the IndexStruct class, which is a base data structure for a GPT index, and the Node class, which is a generic node of data used in most indices. It also includes the IndexGraph, KeywordTable, IndexList, IndexDict, SimpleIndexDict, WeaviateIndexStruct, and QdrantIndexStruct classes, which are all used to compose a higher level index. Each class has its own methods and properties, such as get_text(), get_type(), size, get_children(), insert_under_parent(), add_node(), get_texts(), keywords, add_node(), get_nodes(), and get_node().", "doc_id": null, "embedding": null, "extra_info": null, "index": 20, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "ref_doc_id": null, "node_info": null}, "21": {"text": "This code file contains classes for different types of index structures used with the Faiss index. The IndexDict class is used to store documents in a dictionary, the SimpleIndexDict class is used to store documents in an in-memory embedding dict, the WeaviateIndexStruct class is used to store the class prefix, the PineconeIndexStruct class is used to store documents in Pinecone directly, and the QdrantIndexStruct class is used to store documents in Qdrant directly. Additionally, the StructDatapoint and BaseStructTable classes are used to store struct outputs, and the SQLStructTable class is used to store SQL struct outputs.", "doc_id": null, "embedding": null, "extra_info": null, "index": 21, "child_indices": [12, 13, 14, 15, 16, 17, 18, 19], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"20": {"text": "This code file contains data structures used in a GPT index. It includes the IndexStruct class, which is a base data structure for a GPT index, and the Node class, which is a generic node of data used in most indices. It also includes the IndexGraph, KeywordTable, IndexList, IndexDict, SimpleIndexDict, WeaviateIndexStruct, and QdrantIndexStruct classes, which are all used to compose a higher level index. Each class has its own methods and properties, such as get_text(), get_type(), size, get_children(), insert_under_parent(), add_node(), get_texts(), keywords, add_node(), get_nodes(), and get_node().", "doc_id": null, "embedding": null, "extra_info": null, "index": 20, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "ref_doc_id": null, "node_info": null}, "21": {"text": "This code file contains classes for different types of index structures used with the Faiss index. The IndexDict class is used to store documents in a dictionary, the SimpleIndexDict class is used to store documents in an in-memory embedding dict, the WeaviateIndexStruct class is used to store the class prefix, the PineconeIndexStruct class is used to store documents in Pinecone directly, and the QdrantIndexStruct class is used to store documents in Qdrant directly. Additionally, the StructDatapoint and BaseStructTable classes are used to store struct outputs, and the SQLStructTable class is used to store SQL struct outputs.", "doc_id": null, "embedding": null, "extra_info": null, "index": 21, "child_indices": [12, 13, 14, 15, 16, 17, 18, 19], "ref_doc_id": null, "node_info": null}}}, "docstore": {"docs": {"73f0f8d7e49d0fc9866dbe8a9d799396b09b1a74": {"text": "\"\"\"Init file.\"\"\"\n\nfrom gpt_index.data_structs.data_structs import (\n    IndexDict,\n    IndexGraph,\n    IndexList,\n    KeywordTable,\n    Node,\n    QdrantIndexStruct,\n    SimpleIndexDict,\n    WeaviateIndexStruct,\n)\nfrom gpt_index.data_structs.table import StructDatapoint\n\n__all__ = [\n    \"Node\",\n    \"IndexGraph\",\n    \"KeywordTable\",\n    \"IndexList\",\n    \"IndexDict\",\n    \"SimpleIndexDict\",\n    \"WeaviateIndexStruct\",\n    \"QdrantIndexStruct\",\n    \"StructDatapoint\",\n]\n", "doc_id": "73f0f8d7e49d0fc9866dbe8a9d799396b09b1a74", "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/__init__.py", "file_name": "__init__.py"}, "__type__": "Document"}, "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe": {"text": "\"\"\"File for core data structures.\"\"\"\n\nimport random\nimport sys\nfrom dataclasses import dataclass, field\nfrom typing import Any, Dict, List, Optional, Set\n\nfrom dataclasses_json import DataClassJsonMixin\n\nfrom gpt_index.schema import BaseDocument\nfrom gpt_index.utils import get_new_int_id\n\n\n@dataclass\nclass IndexStruct(BaseDocument, DataClassJsonMixin):\n    \"\"\"A base data struct for a GPT index.\"\"\"\n\n    # NOTE: the text field, inherited from BaseDocument,\n    # represents a summary of the content of the index struct.\n    # primarily used for composing indices with other indices\n\n    # NOTE: the doc_id field, inherited from BaseDocument,\n    # represents a unique identifier for the index struct\n    # that will be put in the docstore.\n    # Not all index_structs need to have a doc_id. Only index_structs that\n    # represent a complete data structure (e.g. IndexGraph, IndexList),\n    # and are used to compose a higher level index, will have a doc_id.\n\n\n@dataclass\nclass Node(IndexStruct):\n    \"\"\"A generic node of data.\n\n    Base struct used in most indices.\n\n    \"\"\"\n\n    def __post_init__(self) -> None:\n        \"\"\"Post init.\"\"\"\n        # NOTE: for Node objects, the text field is required\n        if self.text is None:\n            raise ValueError(\"text field not set.\")\n\n    # used for GPTTreeIndex\n    index: int = 0\n    child_indices: Set[int] = field(default_factory=set)\n\n    # embeddings\n    embedding: Optional[List[float]] = None\n\n    # reference document id\n    ref_doc_id: Optional[str] = None\n\n    # extra node info\n    node_info: Optional[Dict[str, Any]] = None\n\n    def get_text(self) -> str:\n        \"\"\"Get text.\"\"\"\n        text = super().get_text()\n        result_text = (\n            text if self.extra_info_str is None else f\"{self.extra_info_str}\\n\\n{text}\"\n        )\n        return result_text\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        # TODO: consolidate with IndexStructType\n        return \"node\"\n\n\n@dataclass\nclass IndexGraph(IndexStruct):\n    \"\"\"A graph representing the tree-structured index.\"\"\"\n\n    all_nodes: Dict[int, Node] = field(default_factory=dict)\n    root_nodes: Dict[int, Node] = field(default_factory=dict)\n\n    @property\n    def size(self) -> int:\n        \"\"\"Get the size of the graph.\"\"\"\n        return len(self.all_nodes)\n\n    def get_children(self, parent_node: Optional[Node]) -> Dict[int, Node]:\n        \"\"\"Get nodes given indices.\"\"\"\n        if parent_node is None:\n            return self.root_nodes\n        else:\n            return {i: self.all_nodes[i] for i in parent_node.child_indices}\n\n    def insert_under_parent(self, node: Node, parent_node: Optional[Node]) -> None:\n        \"\"\"Insert under parent node.\"\"\"\n        if node.index in self.all_nodes:\n            raise ValueError(\n                \"Cannot insert a new node with the same index as an existing node.\"\n            )\n        if parent_node is None:\n            self.root_nodes[node.index] = node\n        else:\n            parent_node.child_indices.add(node.index)\n\n        self.all_nodes[node.index] = node\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"tree\"\n\n\n@dataclass\nclass KeywordTable(IndexStruct):\n    \"\"\"A table of keywords mapping keywords to text chunks.\"\"\"\n\n    table: Dict[str, Set[int]] = field(default_factory=dict)\n    text_chunks: Dict[int, Node] = field(default_factory=dict)\n\n    def _get_index(self) -> int:\n        \"\"\"Get the next index for the text chunk.\"\"\"\n        # randomly generate until we get a unique index\n        while True:\n            idx = random.randint(0, sys.maxsize)\n            if idx not in self.text_chunks:\n                break\n        return idx\n\n    def add_node(self, keywords: List[str], node: Node) -> int:\n        \"\"\"Add text to table.\"\"\"\n        cur_idx = self._get_index()\n        for keyword in keywords:\n            if keyword not in self.table:\n                self.table[keyword] = set()\n            self.table[keyword].add(cur_idx)\n        self.text_chunks[cur_idx] = node\n        return cur_idx\n\n    def get_texts(self, keyword: str) -> List[str]:\n        \"\"\"Get texts given keyword.\"\"\"\n        if keyword not in self.table:\n            raise ValueError(\"Keyword not found in table.\")\n        return [self.text_chunks[idx].get_text() for idx in self.table[keyword]]\n\n    @property\n    def keywords(self) -> Set[str]:\n        \"\"\"Get all keywords in the table.\"\"\"\n        return set(self.table.keys())\n\n    @property\n    def size(self) -> int:\n        \"\"\"Get the size of the table.\"\"\"\n        return len(self.table)\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"keyword_table\"\n\n\n@dataclass\nclass IndexList(IndexStruct):\n    \"\"\"A list of documents.\"\"\"\n\n    nodes: List[Node] = field(default_factory=list)\n\n    def add_node(self, node: Node) -> None:\n        \"\"\"Add text to table, return current position in list.\"\"\"\n        # don't worry about child indices for now, nodes are all in order\n        self.nodes.append(node)\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"list\"\n\n\n@dataclass\nclass BaseIndexDict(IndexStruct):\n    \"\"\"A simple dictionary of documents.\"\"\"\n\n    nodes_dict: Dict[int, Node] = field(default_factory=dict)\n    id_map: Dict[str, int] = field(default_factory=dict)\n\n    def add_node(\n        self,\n        node: Node,\n        text_id: Optional[str] = None,\n    ) -> str:\n        \"\"\"Add text to table, return current position in list.\"\"\"\n        int_id = get_new_int_id(set(self.nodes_dict.keys()))\n        if text_id in self.id_map:\n            raise ValueError(\"text_id cannot already exist in index.\")\n        elif text_id is not None and not isinstance(text_id, str):\n            raise ValueError(\"text_id must be a string.\")\n        elif text_id is None:\n            text_id = str(int_id)\n        self.id_map[text_id] = int_id\n\n        # don't worry about child indices for now, nodes are all in order\n        self.nodes_dict[int_id] = node\n        return text_id\n\n    def get_nodes(self, text_ids: List[str]) -> List[Node]:\n        \"\"\"Get nodes.\"\"\"\n        nodes = []\n        for text_id in text_ids:\n            if text_id not in self.id_map:\n                raise ValueError(\"text_id not found in id_map\")\n            elif not isinstance(text_id, str):\n                raise ValueError(\"text_id must be a string.\")\n            int_id = self.id_map[text_id]\n            if int_id not in self.nodes_dict:\n                raise ValueError(\"int_id not found in nodes_dict\")\n            nodes.append(self.nodes_dict[int_id])\n        return nodes\n\n    def get_node(self, text_id: str) -> Node:\n        \"\"\"Get node.\"\"\"\n        return self.get_nodes([text_id])[0]\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"dict\"\n\n\n# TODO: this should be specific to FAISS\n@dataclass\nclass IndexDict(BaseIndexDict):\n    \"\"\"A dictionary of documents.\n\n    Note: this index structure is specifically used with the Faiss index.\n\n    \"\"\"\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"dict\"\n\n\n@dataclass\nclass SimpleIndexDict(BaseIndexDict):\n    \"\"\"A simple dictionary of documents.\n\n    This index structure also contains an internal in-memory\n    embedding dict.\n\n    \"\"\"\n\n    embedding_dict: Dict[str, List[float]] = field(default_factory=dict)\n\n    def add_to_embedding_dict(self, text_id: str, embedding: List[float]) -> None:\n        \"\"\"Add embedding to dict.\"\"\"\n        if text_id not in self.id_map:\n            raise ValueError(\"text_id not found in id_map\")\n        elif not isinstance(text_id, str):\n            raise ValueError(\"text_id must be a string.\")\n        self.embedding_dict[text_id] = embedding\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"simple_dict\"\n\n\n@dataclass\nclass WeaviateIndexStruct(IndexStruct):\n    \"\"\"A helper index struct for Weaviate.\n\n    In Weaviate, docs are stored in Weaviate directly.\n    This index struct helps to store the class prefix\n\n    \"\"\"\n\n    class_prefix: Optional[str] = None\n\n    def __post_init__(self) -> None:\n        \"\"\"Post init.\"\"\"\n        if self.class_prefix is None:\n            raise ValueError(\"class_prefix must be provided.\")\n\n    def get_class_prefix(self) -> str:\n        \"\"\"Get class prefix.\"\"\"\n        if self.class_prefix is None:\n            raise ValueError(\"class_prefix must be provided.\")\n        return self.class_prefix\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"weaviate\"\n\n\n@dataclass\nclass PineconeIndexStruct(IndexStruct):\n    \"\"\"An index struct for Pinecone.\n\n    Docs are stored in Pinecone directly.\n\n    \"\"\"\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"pinecone\"\n\n\n@dataclass\nclass QdrantIndexStruct(IndexStruct):\n    \"\"\"And index struct for Qdrant.\n\n    Docs are stored in Qdrant directly.\n    This index struct helps to store the collection name\n\n    \"\"\"\n\n    collection_name: Optional[str] = None\n\n    def __post_init__(self) -> None:\n        \"\"\"Post init.\"\"\"\n        if self.collection_name is None:\n            raise ValueError(\"collection_name must be provided.\")\n\n    def get_collection_name(self) -> str:\n        \"\"\"Get class prefix.\"\"\"\n        if self.collection_name is None:\n            raise ValueError(\"collection_name must be provided.\")\n        return self.collection_name\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"qdrant\"\n", "doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "__type__": "Document"}, "d75d8d1f3958884352e2c1148a6b9f1dd3e1f626": {"text": "\"\"\"IndexStructType class.\"\"\"\n\nfrom enum import Enum\n\n\nclass IndexStructType(str, Enum):\n    \"\"\"Index struct type. Identifier for a \"type\" of index.\n\n    Attributes:\n        TREE (\"tree\"): Tree index. See :ref:`Ref-Indices-Tree` for tree indices.\n        LIST (\"list\"): List index. See :ref:`Ref-Indices-List` for list indices.\n        KEYWORD_TABLE (\"keyword_table\"): Keyword table index. See\n            :ref:`Ref-Indices-Table`\n            for keyword table indices.\n        DICT (\"dict\"): Faiss Vector Store Index. See :ref:`Ref-Indices-VectorStore`\n            for more information on the Faiss vector store index.\n        SIMPLE_DICT (\"simple_dict\"): Simple Vector Store Index. See\n            :ref:`Ref-Indices-VectorStore`\n            for more information on the simple vector store index.\n        WEAVIATE (\"weaviate\"): Weaviate Vector Store Index.\n            See :ref:`Ref-Indices-VectorStore`\n            for more information on the Weaviate vector store index.\n        PINECONE (\"pinecone\"): Pinecone Vector Store Index.\n            See :ref:`Ref-Indices-VectorStore`\n            for more information on the Pinecone vector store index.\n        QDRANT (\"qdrant\"): Qdrant Vector Store Index.\n            See :ref:`Ref-Indices-VectorStore`\n            for more information on the Qdrant vector store index.\n\n        SQL (\"SQL\"): SQL Structured Store Index.\n            See :ref:`Ref-Indices-StructStore`\n            for more information on the SQL vector store index.\n\n    \"\"\"\n\n    # TODO: refactor so these are properties on the base class\n\n    NODE = \"node\"\n    TREE = \"tree\"\n    LIST = \"list\"\n    KEYWORD_TABLE = \"keyword_table\"\n    # for Faiss\n    # TODO: rename\n    DICT = \"dict\"\n    # for simple embedding index\n    SIMPLE_DICT = \"simple_dict\"\n    # for weaviate index\n    WEAVIATE = \"weaviate\"\n    # for pinecone index\n    PINECONE = \"pinecone\"\n    # for qdrant index\n    QDRANT = \"qdrant\"\n    # for SQL index\n    SQL = \"sql\"\n", "doc_id": "d75d8d1f3958884352e2c1148a6b9f1dd3e1f626", "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/struct_type.py", "file_name": "struct_type.py"}, "__type__": "Document"}, "a23a646d5f57acd8044f740f0b4a0b683aa20e7f": {"text": "\"\"\"Struct store schema.\"\"\"\n\nfrom dataclasses import dataclass, field\nfrom typing import Any, Dict\n\nfrom dataclasses_json import DataClassJsonMixin\n\nfrom gpt_index.data_structs.data_structs import IndexStruct\n\n\n@dataclass\nclass StructDatapoint(DataClassJsonMixin):\n    \"\"\"Struct outputs.\"\"\"\n\n    # map from field name to StructValue\n    fields: Dict[str, Any]\n\n\n@dataclass\nclass BaseStructTable(IndexStruct):\n    \"\"\"Struct outputs.\"\"\"\n\n\n@dataclass\nclass SQLStructTable(BaseStructTable):\n    \"\"\"SQL struct outputs.\"\"\"\n\n    context_dict: Dict[str, str] = field(default_factory=dict)\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        # TODO: consolidate with IndexStructType\n        return \"sql\"\n", "doc_id": "a23a646d5f57acd8044f740f0b4a0b683aa20e7f", "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/table.py", "file_name": "table.py"}, "__type__": "Document"}, "e9ed3920-45b1-46ff-bea1-efbbcf8f678c": {"text": "\nThe documents contain data structures used to create a GPT index. These include the IndexStruct class, which is a base data structure for a GPT index, and the Node class, which is a generic node of data used in most indices. It also includes the IndexGraph, KeywordTable, IndexList, IndexDict, SimpleIndexDict, WeaviateIndexStruct, and QdrantIndexStruct classes, which are all used to compose a higher level index. These classes have methods and properties such as get_text(), get_type(), size, get_children(), insert_under_parent(), add_node(), get_texts(), keywords, add_node(), get_nodes(), and get_node(). Additionally, the StructDatapoint and BaseStructTable classes are used to store struct outputs, and the SQLStructTable class is used to store SQL struct outputs.", "doc_id": "e9ed3920-45b1-46ff-bea1-efbbcf8f678c", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"Init file.\"\"\"\n\nfrom gpt_index.data_structs.data_structs import (\n    IndexDict,\n    IndexGraph,\n    IndexList,\n    KeywordTable,\n    Node,\n    QdrantIndexStruct,\n    SimpleIndexDict,\n    WeaviateIndexStruct,\n)\nfrom gpt_index.data_structs.table import StructDatapoint\n\n__all__ = [\n    \"Node\",\n    \"IndexGraph\",\n    \"KeywordTable\",\n    \"IndexList\",\n    \"IndexDict\",\n    \"SimpleIndexDict\",\n    \"WeaviateIndexStruct\",\n    \"QdrantIndexStruct\",\n    \"StructDatapoint\",\n]\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/__init__.py", "file_name": "__init__.py"}, "index": 0, "child_indices": [], "ref_doc_id": "73f0f8d7e49d0fc9866dbe8a9d799396b09b1a74", "node_info": null}, "1": {"text": "\"\"\"File for core data structures.\"\"\"\n\nimport random\nimport sys\nfrom dataclasses import dataclass, field\nfrom typing import Any, Dict, List, Optional, Set\n\nfrom dataclasses_json import DataClassJsonMixin\n\nfrom gpt_index.schema import BaseDocument\nfrom gpt_index.utils import get_new_int_id\n\n\n@dataclass\nclass IndexStruct(BaseDocument, DataClassJsonMixin):\n    \"\"\"A base data struct for a GPT index.\"\"\"\n\n    # NOTE: the text field, inherited from BaseDocument,\n    # represents a summary of the content of the index struct.\n    # primarily used for composing indices with other indices\n\n    # NOTE: the doc_id field, inherited from BaseDocument,\n    # represents a unique identifier for the index struct\n    # that will be put in the docstore.\n    # Not all index_structs need to have a doc_id. Only index_structs that\n    # represent a complete data structure (e.g. IndexGraph, IndexList),\n    # and are used to", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 1, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "2": {"text": "IndexGraph, IndexList),\n    # and are used to compose a higher level index, will have a doc_id.\n\n\n@dataclass\nclass Node(IndexStruct):\n    \"\"\"A generic node of data.\n\n    Base struct used in most indices.\n\n    \"\"\"\n\n    def __post_init__(self) -> None:\n        \"\"\"Post init.\"\"\"\n        # NOTE: for Node objects, the text field is required\n        if self.text is None:\n            raise ValueError(\"text field not set.\")\n\n    # used for GPTTreeIndex\n    index: int = 0\n    child_indices: Set[int] = field(default_factory=set)\n\n    # embeddings\n    embedding: Optional[List[float]] = None\n\n    # reference document id\n    ref_doc_id: Optional[str] = None\n\n    # extra node info\n    node_info: Optional[Dict[str, Any]] = None\n\n    def", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 2, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "3": {"text": "Optional[Dict[str, Any]] = None\n\n    def get_text(self) -> str:\n        \"\"\"Get text.\"\"\"\n        text = super().get_text()\n        result_text = (\n            text if self.extra_info_str is None else f\"{self.extra_info_str}\\n\\n{text}\"\n        )\n        return result_text\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        # TODO: consolidate with IndexStructType\n        return \"node\"\n\n\n@dataclass\nclass IndexGraph(IndexStruct):\n    \"\"\"A graph representing the tree-structured index.\"\"\"\n\n    all_nodes: Dict[int, Node] = field(default_factory=dict)\n    root_nodes: Dict[int, Node] = field(default_factory=dict)\n\n ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 3, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "4": {"text": "Node] = field(default_factory=dict)\n\n    @property\n    def size(self) -> int:\n        \"\"\"Get the size of the graph.\"\"\"\n        return len(self.all_nodes)\n\n    def get_children(self, parent_node: Optional[Node]) -> Dict[int, Node]:\n        \"\"\"Get nodes given indices.\"\"\"\n        if parent_node is None:\n            return self.root_nodes\n        else:\n            return {i: self.all_nodes[i] for i in parent_node.child_indices}\n\n    def insert_under_parent(self, node: Node, parent_node: Optional[Node]) -> None:\n        \"\"\"Insert under parent node.\"\"\"\n        if node.index in self.all_nodes:\n            raise ValueError(\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 4, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "5": {"text": "raise ValueError(\n                \"Cannot insert a new node with the same index as an existing node.\"\n            )\n        if parent_node is None:\n            self.root_nodes[node.index] = node\n        else:\n            parent_node.child_indices.add(node.index)\n\n        self.all_nodes[node.index] = node\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"tree\"\n\n\n@dataclass\nclass KeywordTable(IndexStruct):\n    \"\"\"A table of keywords mapping keywords to text chunks.\"\"\"\n\n    table: Dict[str, Set[int]] = field(default_factory=dict)\n    text_chunks: Dict[int, Node] = field(default_factory=dict)\n\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 5, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "6": {"text": "Node] = field(default_factory=dict)\n\n    def _get_index(self) -> int:\n        \"\"\"Get the next index for the text chunk.\"\"\"\n        # randomly generate until we get a unique index\n        while True:\n            idx = random.randint(0, sys.maxsize)\n            if idx not in self.text_chunks:\n                break\n        return idx\n\n    def add_node(self, keywords: List[str], node: Node) -> int:\n        \"\"\"Add text to table.\"\"\"\n        cur_idx = self._get_index()\n        for keyword in keywords:\n            if keyword not in self.table:\n                self.table[keyword] = set()\n   ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 6, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "7": {"text": "  self.table[keyword] = set()\n            self.table[keyword].add(cur_idx)\n        self.text_chunks[cur_idx] = node\n        return cur_idx\n\n    def get_texts(self, keyword: str) -> List[str]:\n        \"\"\"Get texts given keyword.\"\"\"\n        if keyword not in self.table:\n            raise ValueError(\"Keyword not found in table.\")\n        return [self.text_chunks[idx].get_text() for idx in self.table[keyword]]\n\n    @property\n    def keywords(self) -> Set[str]:\n        \"\"\"Get all keywords in the table.\"\"\"\n        return set(self.table.keys())\n\n    @property\n    def size(self) -> int:\n        \"\"\"Get the size of the table.\"\"\"\n  ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 7, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "8": {"text": "    \"\"\"Get the size of the table.\"\"\"\n        return len(self.table)\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"keyword_table\"\n\n\n@dataclass\nclass IndexList(IndexStruct):\n    \"\"\"A list of documents.\"\"\"\n\n    nodes: List[Node] = field(default_factory=list)\n\n    def add_node(self, node: Node) -> None:\n        \"\"\"Add text to table, return current position in list.\"\"\"\n        # don't worry about child indices for now, nodes are all in order\n        self.nodes.append(node)\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"list\"\n\n\n@dataclass\nclass BaseIndexDict(IndexStruct):\n    \"\"\"A simple dictionary of", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 8, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "9": {"text": "   \"\"\"A simple dictionary of documents.\"\"\"\n\n    nodes_dict: Dict[int, Node] = field(default_factory=dict)\n    id_map: Dict[str, int] = field(default_factory=dict)\n\n    def add_node(\n        self,\n        node: Node,\n        text_id: Optional[str] = None,\n    ) -> str:\n        \"\"\"Add text to table, return current position in list.\"\"\"\n        int_id = get_new_int_id(set(self.nodes_dict.keys()))\n        if text_id in self.id_map:\n            raise ValueError(\"text_id cannot already exist in index.\")\n        elif text_id is not None and not isinstance(text_id, str):\n            raise ValueError(\"text_id must be a string.\")\n       ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 9, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "10": {"text": "must be a string.\")\n        elif text_id is None:\n            text_id = str(int_id)\n        self.id_map[text_id] = int_id\n\n        # don't worry about child indices for now, nodes are all in order\n        self.nodes_dict[int_id] = node\n        return text_id\n\n    def get_nodes(self, text_ids: List[str]) -> List[Node]:\n        \"\"\"Get nodes.\"\"\"\n        nodes = []\n        for text_id in text_ids:\n            if text_id not in self.id_map:\n                raise ValueError(\"text_id not found in id_map\")\n            elif not isinstance(text_id, str):\n          ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 10, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "11": {"text": "str):\n                raise ValueError(\"text_id must be a string.\")\n            int_id = self.id_map[text_id]\n            if int_id not in self.nodes_dict:\n                raise ValueError(\"int_id not found in nodes_dict\")\n            nodes.append(self.nodes_dict[int_id])\n        return nodes\n\n    def get_node(self, text_id: str) -> Node:\n        \"\"\"Get node.\"\"\"\n        return self.get_nodes([text_id])[0]\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"dict\"\n\n\n# TODO: this should be specific to FAISS\n@dataclass\nclass", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 11, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "12": {"text": "this should be specific to FAISS\n@dataclass\nclass IndexDict(BaseIndexDict):\n    \"\"\"A dictionary of documents.\n\n    Note: this index structure is specifically used with the Faiss index.\n\n    \"\"\"\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"dict\"\n\n\n@dataclass\nclass SimpleIndexDict(BaseIndexDict):\n    \"\"\"A simple dictionary of documents.\n\n    This index structure also contains an internal in-memory\n    embedding dict.\n\n    \"\"\"\n\n    embedding_dict: Dict[str, List[float]] = field(default_factory=dict)\n\n    def add_to_embedding_dict(self, text_id: str, embedding: List[float]) -> None:\n        \"\"\"Add embedding to dict.\"\"\"\n        if text_id not in self.id_map:\n            raise", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 12, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "13": {"text": "           raise ValueError(\"text_id not found in id_map\")\n        elif not isinstance(text_id, str):\n            raise ValueError(\"text_id must be a string.\")\n        self.embedding_dict[text_id] = embedding\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"simple_dict\"\n\n\n@dataclass\nclass WeaviateIndexStruct(IndexStruct):\n    \"\"\"A helper index struct for Weaviate.\n\n    In Weaviate, docs are stored in Weaviate directly.\n    This index struct helps to store the class prefix\n\n    \"\"\"\n\n    class_prefix: Optional[str] = None\n\n    def __post_init__(self) -> None:\n        \"\"\"Post init.\"\"\"\n        if self.class_prefix is None:\n          ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 13, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "14": {"text": "is None:\n            raise ValueError(\"class_prefix must be provided.\")\n\n    def get_class_prefix(self) -> str:\n        \"\"\"Get class prefix.\"\"\"\n        if self.class_prefix is None:\n            raise ValueError(\"class_prefix must be provided.\")\n        return self.class_prefix\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"weaviate\"\n\n\n@dataclass\nclass PineconeIndexStruct(IndexStruct):\n    \"\"\"An index struct for Pinecone.\n\n    Docs are stored in Pinecone directly.\n\n    \"\"\"\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"pinecone\"\n\n\n@dataclass\nclass QdrantIndexStruct(IndexStruct):\n    \"\"\"And", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 14, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "15": {"text": "QdrantIndexStruct(IndexStruct):\n    \"\"\"And index struct for Qdrant.\n\n    Docs are stored in Qdrant directly.\n    This index struct helps to store the collection name\n\n    \"\"\"\n\n    collection_name: Optional[str] = None\n\n    def __post_init__(self) -> None:\n        \"\"\"Post init.\"\"\"\n        if self.collection_name is None:\n            raise ValueError(\"collection_name must be provided.\")\n\n    def get_collection_name(self) -> str:\n        \"\"\"Get class prefix.\"\"\"\n        if self.collection_name is None:\n            raise ValueError(\"collection_name must be provided.\")\n        return self.collection_name\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"qdrant\"\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 15, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "16": {"text": "\"\"\"IndexStructType class.\"\"\"\n\nfrom enum import Enum\n\n\nclass IndexStructType(str, Enum):\n    \"\"\"Index struct type. Identifier for a \"type\" of index.\n\n    Attributes:\n        TREE (\"tree\"): Tree index. See :ref:`Ref-Indices-Tree` for tree indices.\n        LIST (\"list\"): List index. See :ref:`Ref-Indices-List` for list indices.\n        KEYWORD_TABLE (\"keyword_table\"): Keyword table index. See\n            :ref:`Ref-Indices-Table`\n            for keyword table indices.\n        DICT (\"dict\"): Faiss Vector Store Index. See :ref:`Ref-Indices-VectorStore`\n            for more information on the Faiss vector store index.\n        SIMPLE_DICT (\"simple_dict\"): Simple Vector Store Index. See\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/struct_type.py", "file_name": "struct_type.py"}, "index": 16, "child_indices": [], "ref_doc_id": "d75d8d1f3958884352e2c1148a6b9f1dd3e1f626", "node_info": null}, "17": {"text": "Store Index. See\n            :ref:`Ref-Indices-VectorStore`\n            for more information on the simple vector store index.\n        WEAVIATE (\"weaviate\"): Weaviate Vector Store Index.\n            See :ref:`Ref-Indices-VectorStore`\n            for more information on the Weaviate vector store index.\n        PINECONE (\"pinecone\"): Pinecone Vector Store Index.\n            See :ref:`Ref-Indices-VectorStore`\n            for more information on the Pinecone vector store index.\n        QDRANT (\"qdrant\"): Qdrant Vector Store Index.\n            See :ref:`Ref-Indices-VectorStore`\n            for more information on the Qdrant vector store index.\n\n        SQL (\"SQL\"): SQL", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/struct_type.py", "file_name": "struct_type.py"}, "index": 17, "child_indices": [], "ref_doc_id": "d75d8d1f3958884352e2c1148a6b9f1dd3e1f626", "node_info": null}, "18": {"text": "index.\n\n        SQL (\"SQL\"): SQL Structured Store Index.\n            See :ref:`Ref-Indices-StructStore`\n            for more information on the SQL vector store index.\n\n    \"\"\"\n\n    # TODO: refactor so these are properties on the base class\n\n    NODE = \"node\"\n    TREE = \"tree\"\n    LIST = \"list\"\n    KEYWORD_TABLE = \"keyword_table\"\n    # for Faiss\n    # TODO: rename\n    DICT = \"dict\"\n    # for simple embedding index\n    SIMPLE_DICT = \"simple_dict\"\n    # for weaviate index\n    WEAVIATE = \"weaviate\"\n    # for pinecone index\n    PINECONE = \"pinecone\"\n    # for qdrant index\n    QDRANT = \"qdrant\"\n    # for SQL index\n    SQL = \"sql\"\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/struct_type.py", "file_name": "struct_type.py"}, "index": 18, "child_indices": [], "ref_doc_id": "d75d8d1f3958884352e2c1148a6b9f1dd3e1f626", "node_info": null}, "19": {"text": "\"\"\"Struct store schema.\"\"\"\n\nfrom dataclasses import dataclass, field\nfrom typing import Any, Dict\n\nfrom dataclasses_json import DataClassJsonMixin\n\nfrom gpt_index.data_structs.data_structs import IndexStruct\n\n\n@dataclass\nclass StructDatapoint(DataClassJsonMixin):\n    \"\"\"Struct outputs.\"\"\"\n\n    # map from field name to StructValue\n    fields: Dict[str, Any]\n\n\n@dataclass\nclass BaseStructTable(IndexStruct):\n    \"\"\"Struct outputs.\"\"\"\n\n\n@dataclass\nclass SQLStructTable(BaseStructTable):\n    \"\"\"SQL struct outputs.\"\"\"\n\n    context_dict: Dict[str, str] = field(default_factory=dict)\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        # TODO: consolidate with IndexStructType\n        return \"sql\"\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/table.py", "file_name": "table.py"}, "index": 19, "child_indices": [], "ref_doc_id": "a23a646d5f57acd8044f740f0b4a0b683aa20e7f", "node_info": null}, "20": {"text": "This code file contains data structures used in a GPT index. It includes the IndexStruct class, which is a base data structure for a GPT index, and the Node class, which is a generic node of data used in most indices. It also includes the IndexGraph, KeywordTable, IndexList, IndexDict, SimpleIndexDict, WeaviateIndexStruct, and QdrantIndexStruct classes, which are all used to compose a higher level index. Each class has its own methods and properties, such as get_text(), get_type(), size, get_children(), insert_under_parent(), add_node(), get_texts(), keywords, add_node(), get_nodes(), and get_node().", "doc_id": null, "embedding": null, "extra_info": null, "index": 20, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "ref_doc_id": null, "node_info": null}, "21": {"text": "This code file contains classes for different types of index structures used with the Faiss index. The IndexDict class is used to store documents in a dictionary, the SimpleIndexDict class is used to store documents in an in-memory embedding dict, the WeaviateIndexStruct class is used to store the class prefix, the PineconeIndexStruct class is used to store documents in Pinecone directly, and the QdrantIndexStruct class is used to store documents in Qdrant directly. Additionally, the StructDatapoint and BaseStructTable classes are used to store struct outputs, and the SQLStructTable class is used to store SQL struct outputs.", "doc_id": null, "embedding": null, "extra_info": null, "index": 21, "child_indices": [12, 13, 14, 15, 16, 17, 18, 19], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"20": {"text": "This code file contains data structures used in a GPT index. It includes the IndexStruct class, which is a base data structure for a GPT index, and the Node class, which is a generic node of data used in most indices. It also includes the IndexGraph, KeywordTable, IndexList, IndexDict, SimpleIndexDict, WeaviateIndexStruct, and QdrantIndexStruct classes, which are all used to compose a higher level index. Each class has its own methods and properties, such as get_text(), get_type(), size, get_children(), insert_under_parent(), add_node(), get_texts(), keywords, add_node(), get_nodes(), and get_node().", "doc_id": null, "embedding": null, "extra_info": null, "index": 20, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "ref_doc_id": null, "node_info": null}, "21": {"text": "This code file contains classes for different types of index structures used with the Faiss index. The IndexDict class is used to store documents in a dictionary, the SimpleIndexDict class is used to store documents in an in-memory embedding dict, the WeaviateIndexStruct class is used to store the class prefix, the PineconeIndexStruct class is used to store documents in Pinecone directly, and the QdrantIndexStruct class is used to store documents in Qdrant directly. Additionally, the StructDatapoint and BaseStructTable classes are used to store struct outputs, and the SQLStructTable class is used to store SQL struct outputs.", "doc_id": null, "embedding": null, "extra_info": null, "index": 21, "child_indices": [12, 13, 14, 15, 16, 17, 18, 19], "ref_doc_id": null, "node_info": null}}, "__type__": "tree"}}}}