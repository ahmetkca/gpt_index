{"index_struct": {"text": "\nThe __init__.py and data_structs.py documents provide functions for retrieving documents from Weaviate through vector lookup, converting from gpt index, deleting documents, and loading data from Weaviate. Additionally, the documents provide functions for validating the client, parsing get responses from Weaviate, and getting a default class prefix. The utils.py file contains two functions, parse_get_response() and get_by_id(), which are used to query the Weaviate database. The BaseWeaviateIndexStruct class is used to create a schema for Weaviate-specific serializers for GPT Index data structures. The WeaviateReader class is used to retrieve documents from Weaviate through vector lookup.", "doc_id": "c73a93c9-8f3c-4a72-a674-e11b3234c11c", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"Init file.\"\"\"\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/__init__.py", "file_name": "__init__.py"}, "index": 0, "child_indices": [], "ref_doc_id": "1d4640565ae2765d9ca96a509dc9809217f62f2f", "node_info": null}, "1": {"text": "\"\"\"Weaviate-specific serializers for GPT Index data structures.\n\nContain conversion to and from dataclasses that GPT Index uses.\n\n\"\"\"\n\nimport json\nfrom abc import abstractmethod\nfrom typing import Any, Dict, Generic, List, Optional, TypeVar\n\nfrom gpt_index.data_structs.data_structs import IndexStruct, Node\nfrom gpt_index.readers.weaviate.utils import (\n    get_by_id,\n    parse_get_response,\n    validate_client,\n)\nfrom gpt_index.utils import get_new_id\n\nIS = TypeVar(\"IS\", bound=IndexStruct)\n\n\nclass BaseWeaviateIndexStruct(Generic[IS]):\n    \"\"\"Base Weaviate index struct.\"\"\"\n\n    @classmethod\n    @abstractmethod\n    def _class_name(cls, class_prefix: str) -> str:\n        \"\"\"Return class name.\"\"\"\n\n    @classmethod\n    def _get_common_properties(cls) -> List[Dict]:\n       ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 1, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "2": {"text": "-> List[Dict]:\n        \"\"\"Get common properties.\"\"\"\n        return [\n            {\n                \"dataType\": [\"string\"],\n                \"description\": \"Text property\",\n                \"name\": \"text\",\n            },\n            {\n                \"dataType\": [\"string\"],\n                \"description\": \"Document id\",\n                \"name\": \"doc_id\",\n            },\n            {\n                \"dataType\": [\"string\"],\n                \"description\": \"extra_info", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 2, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "3": {"text": "         \"description\": \"extra_info (in JSON)\",\n                \"name\": \"extra_info\",\n            },\n        ]\n\n    @classmethod\n    @abstractmethod\n    def _get_properties(cls) -> List[Dict]:\n        \"\"\"Get properties specific to each index struct.\n\n        Used in creating schema.\n\n        \"\"\"\n\n    @classmethod\n    def _get_by_id(cls, client: Any, object_id: str, class_prefix: str) -> Dict:\n        \"\"\"Get entry by id.\"\"\"\n        validate_client(client)\n        class_name = cls._class_name(class_prefix)\n        properties = cls._get_common_properties() + cls._get_properties()\n        prop_names =", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 3, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "4": {"text": "       prop_names = [p[\"name\"] for p in properties]\n        entry = get_by_id(client, object_id, class_name, prop_names)\n        return entry\n\n    @classmethod\n    def create_schema(cls, client: Any, class_prefix: str) -> None:\n        \"\"\"Create schema.\"\"\"\n        validate_client(client)\n        # first check if schema exists\n        schema = client.schema.get()\n        classes = schema[\"classes\"]\n        existing_class_names = {c[\"class\"] for c in classes}\n        # if schema already exists, don't create\n        class_name = cls._class_name(class_prefix)\n        if class_name in existing_class_names:\n            return\n\n       ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 4, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "5": {"text": "       return\n\n        # get common properties\n        properties = cls._get_common_properties()\n        # get specific properties\n        properties.extend(cls._get_properties())\n        class_obj = {\n            \"class\": cls._class_name(class_prefix),  # <= note the capital \"A\".\n            \"description\": f\"Class for {class_name}\",\n            \"properties\": properties,\n        }\n        client.schema.create_class(class_obj)\n\n    @classmethod\n    @abstractmethod\n    def _entry_to_gpt_index(cls, entry: Dict) -> IS:\n        \"\"\"Convert to gpt index list.\"\"\"\n\n    @classmethod\n    def to_gpt_index_list(\n      ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 5, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "6": {"text": "to_gpt_index_list(\n        cls,\n        client: Any,\n        class_prefix: str,\n        vector: Optional[List[float]] = None,\n        object_limit: Optional[int] = None,\n    ) -> List[IS]:\n        \"\"\"Convert to gpt index list.\"\"\"\n        validate_client(client)\n        class_name = cls._class_name(class_prefix)\n        properties = cls._get_common_properties() + cls._get_properties()\n        prop_names = [p[\"name\"] for p in properties]\n        query = client.query.get(class_name, prop_names).with_additional(\n            [\"id\", \"vector\"]\n        )\n        if vector is not None:\n         ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 6, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "7": {"text": "if vector is not None:\n            query = query.with_near_vector(\n                {\n                    \"vector\": vector,\n                }\n            )\n        if object_limit is not None:\n            query = query.with_limit(object_limit)\n        query_result = query.do()\n        parsed_result = parse_get_response(query_result)\n        entries = parsed_result[class_name]\n\n        results: List[IS] = []\n        for entry in entries:\n            results.append(cls._entry_to_gpt_index(entry))\n\n        return results\n\n    @classmethod\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 7, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "8": {"text": "      return results\n\n    @classmethod\n    @abstractmethod\n    def _from_gpt_index(cls, client: Any, index: IS, class_prefix: str) -> str:\n        \"\"\"Convert from gpt index.\"\"\"\n\n    @classmethod\n    def from_gpt_index(cls, client: Any, index: IS, class_prefix: str) -> str:\n        \"\"\"Convert from gpt index.\"\"\"\n        validate_client(client)\n        index_id = cls._from_gpt_index(client, index, class_prefix)\n        client.batch.flush()\n        return index_id\n\n\nclass WeaviateNode(BaseWeaviateIndexStruct[Node]):\n    \"\"\"Weaviate node.\"\"\"\n\n    @classmethod\n    def _class_name(cls, class_prefix: str) -> str:\n        \"\"\"Return class name.\"\"\"\n      ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 8, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "9": {"text": "   \"\"\"Return class name.\"\"\"\n        return f\"{class_prefix}_Node\"\n\n    @classmethod\n    def _get_properties(cls) -> List[Dict]:\n        \"\"\"Create schema.\"\"\"\n        return [\n            {\n                \"dataType\": [\"int\"],\n                \"description\": \"The index of the Node\",\n                \"name\": \"index\",\n            },\n            {\n                \"dataType\": [\"int[]\"],\n                \"description\": \"The child_indices of the Node\",\n                \"name\": \"child_indices\",\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 9, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "10": {"text": "           },\n            {\n                \"dataType\": [\"string\"],\n                \"description\": \"The ref_doc_id of the Node\",\n                \"name\": \"ref_doc_id\",\n            },\n            {\n                \"dataType\": [\"string\"],\n                \"description\": \"node_info (in JSON)\",\n                \"name\": \"node_info\",\n            },\n        ]\n\n    @classmethod\n    def _entry_to_gpt_index(cls, entry: Dict) -> Node:\n        \"\"\"Convert to gpt index list.\"\"\"\n ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 10, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "11": {"text": "    \"\"\"Convert to gpt index list.\"\"\"\n        extra_info_str = entry[\"extra_info\"]\n        if extra_info_str == \"\":\n            extra_info = None\n        else:\n            extra_info = json.loads(extra_info_str)\n\n        node_info_str = entry[\"node_info\"]\n        if node_info_str == \"\":\n            node_info = None\n        else:\n            node_info = json.loads(node_info_str)\n        return Node(\n            text=entry[\"text\"],\n            doc_id=entry[\"doc_id\"],\n            index=int(entry[\"index\"]),\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 11, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "12": {"text": "           child_indices=entry[\"child_indices\"],\n            ref_doc_id=entry[\"ref_doc_id\"],\n            embedding=entry[\"_additional\"][\"vector\"],\n            extra_info=extra_info,\n            node_info=node_info,\n        )\n\n    @classmethod\n    def _from_gpt_index(cls, client: Any, node: Node, class_prefix: str) -> str:\n        \"\"\"Convert from gpt index.\"\"\"\n        node_dict = node.to_dict()\n        vector = node_dict.pop(\"embedding\")\n        extra_info = node_dict.pop(\"extra_info\")\n        # json-serialize the extra_info\n        extra_info_str = \"\"\n       ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 12, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "13": {"text": " extra_info_str = \"\"\n        if extra_info is not None:\n            extra_info_str = json.dumps(extra_info)\n        node_dict[\"extra_info\"] = extra_info_str\n        # json-serialize the node_info\n        node_info = node_dict.pop(\"node_info\")\n        node_info_str = \"\"\n        if node_info is not None:\n            node_info_str = json.dumps(node_info)\n        node_dict[\"node_info\"] = node_info_str\n\n        # TODO: account for existing nodes that are stored\n        node_id = get_new_id(set())\n        class_name = cls._class_name(class_prefix)\n        client.batch.add_data_object(node_dict,", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 13, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "14": {"text": "  client.batch.add_data_object(node_dict, class_name, node_id, vector)\n\n        return node_id\n\n    @classmethod\n    def delete_document(cls, client: Any, ref_doc_id: str, class_prefix: str) -> None:\n        \"\"\"Delete entry.\"\"\"\n        validate_client(client)\n        # make sure that each entry\n        class_name = cls._class_name(class_prefix)\n        where_filter = {\n            \"path\": [\"ref_doc_id\"],\n            \"operator\": \"Equal\",\n            \"valueString\": ref_doc_id,\n        }\n        query = (\n            client.query.get(class_name)\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 14, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "15": {"text": "           .with_additional([\"id\"])\n            .with_where(where_filter)\n        )\n\n        query_result = query.do()\n        parsed_result = parse_get_response(query_result)\n        entries = parsed_result[class_name]\n        for entry in entries:\n            client.data_object.delete(entry[\"_additional\"][\"id\"], class_name)\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 15, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "16": {"text": "\"\"\"Weaviate reader.\"\"\"\n\nfrom typing import Any, List, Optional\n\nfrom gpt_index.readers.base import BaseReader\nfrom gpt_index.readers.schema.base import Document\n\n\nclass WeaviateReader(BaseReader):\n    \"\"\"Weaviate reader.\n\n    Retrieves documents from Weaviate through vector lookup. Allows option\n    to concatenate retrieved documents into one Document, or to return\n    separate Document objects per document.\n\n    Args:\n        host (str): host.\n        auth_client_secret (Optional[weaviate.auth.AuthCredentials]):\n            auth_client_secret.\n    \"\"\"\n\n    def __init__(\n        self,\n        host: str,\n        auth_client_secret: Optional[Any] = None,\n    ) -> None:\n        \"\"\"Initialize with parameters.\"\"\"\n        try:\n      ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/reader.py", "file_name": "reader.py"}, "index": 16, "child_indices": [], "ref_doc_id": "9fb7548dd341b7bbe79a3a28e6bf3fd7ef78c44d", "node_info": null}, "17": {"text": "       try:\n            import weaviate  # noqa: F401\n            from weaviate import Client  # noqa: F401\n            from weaviate.auth import AuthCredentials  # noqa: F401\n        except ImportError:\n            raise ValueError(\n                \"`weaviate` package not found, please run `pip install weaviate-client`\"\n            )\n\n        self.client: Client = Client(host, auth_client_secret=auth_client_secret)\n\n    def load_data(\n        self,\n        class_name: Optional[str] = None,\n        properties: Optional[List[str]] = None,\n        graphql_query: Optional[str] = None,\n       ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/reader.py", "file_name": "reader.py"}, "index": 17, "child_indices": [], "ref_doc_id": "9fb7548dd341b7bbe79a3a28e6bf3fd7ef78c44d", "node_info": null}, "18": {"text": "Optional[str] = None,\n        separate_documents: Optional[bool] = True,\n    ) -> List[Document]:\n        \"\"\"Load data from Weaviate.\n\n        If `graphql_query` is not found in load_kwargs, we assume that\n        `class_name` and `properties` are provided.\n\n        Args:\n            class_name (Optional[str]): class_name to retrieve documents from.\n            properties (Optional[List[str]]): properties to retrieve from documents.\n            graphql_query (Optional[str]): Raw GraphQL Query.\n                We assume that the query is a Get query.\n            separate_documents (Optional[bool]): Whether to return separate\n                documents. Defaults to True.\n\n      ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/reader.py", "file_name": "reader.py"}, "index": 18, "child_indices": [], "ref_doc_id": "9fb7548dd341b7bbe79a3a28e6bf3fd7ef78c44d", "node_info": null}, "19": {"text": " documents. Defaults to True.\n\n        Returns:\n            List[Document]: A list of documents.\n\n        \"\"\"\n        if class_name is not None and properties is not None:\n            props_txt = \"\\n\".join(properties)\n            graphql_query = f\"\"\"\n            {{\n                Get {{\n                    {class_name} {{\n                        {props_txt}\n                    }}\n                }}\n            }}\n            \"\"\"\n        elif graphql_query is not None:\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/reader.py", "file_name": "reader.py"}, "index": 19, "child_indices": [], "ref_doc_id": "9fb7548dd341b7bbe79a3a28e6bf3fd7ef78c44d", "node_info": null}, "20": {"text": "     elif graphql_query is not None:\n            pass\n        else:\n            raise ValueError(\n                \"Either `class_name` and `properties` must be specified, \"\n                \"or `graphql_query` must be specified.\"\n            )\n\n        response = self.client.query.raw(graphql_query)\n        if \"errors\" in response:\n            raise ValueError(\"Invalid query, got errors: {}\".format(response[\"errors\"]))\n\n        data_response = response[\"data\"]\n        if \"Get\" not in data_response:\n            raise ValueError(\"Invalid query response, must be a Get query.\")\n\n        if class_name is None:\n            #", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/reader.py", "file_name": "reader.py"}, "index": 20, "child_indices": [], "ref_doc_id": "9fb7548dd341b7bbe79a3a28e6bf3fd7ef78c44d", "node_info": null}, "21": {"text": "is None:\n            # infer class_name if only graphql_query was provided\n            class_name = list(data_response[\"Get\"].keys())[0]\n        entries = data_response[\"Get\"][class_name]\n        documents = []\n        for entry in entries:\n            embedding = None\n            # for each entry, join properties into <property>:<value>\n            # separated by newlines\n            text_list = []\n            for k, v in entry.items():\n                if k == \"_additional\":\n                    if \"vector\" in v:\n                        embedding =", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/reader.py", "file_name": "reader.py"}, "index": 21, "child_indices": [], "ref_doc_id": "9fb7548dd341b7bbe79a3a28e6bf3fd7ef78c44d", "node_info": null}, "22": {"text": "             embedding = v[\"vector\"]\n                    continue\n                text_list.append(f\"{k}: {v}\")\n\n            text = \"\\n\".join(text_list)\n            documents.append(Document(text=text, embedding=embedding))\n\n        if not separate_documents:\n            # join all documents into one\n            text_list = [doc.get_text() for doc in documents]\n            text = \"\\n\\n\".join(text_list)\n            documents = [Document(text=text)]\n\n        return documents\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/reader.py", "file_name": "reader.py"}, "index": 22, "child_indices": [], "ref_doc_id": "9fb7548dd341b7bbe79a3a28e6bf3fd7ef78c44d", "node_info": null}, "23": {"text": "\"\"\"Weaviate utils.\"\"\"\n\nfrom typing import Any, Dict, List, Set, cast\n\nfrom gpt_index.utils import get_new_int_id\n\nDEFAULT_CLASS_PREFIX_STUB = \"Gpt_Index\"\n\n\ndef get_default_class_prefix(current_id_set: Set = set()) -> str:\n    \"\"\"Get default class prefix.\"\"\"\n    return DEFAULT_CLASS_PREFIX_STUB + \"_\" + str(get_new_int_id(current_id_set))\n\n\ndef validate_client(client: Any) -> None:\n    \"\"\"Validate client and import weaviate library.\"\"\"\n    try:\n        import weaviate  # noqa: F401\n        from weaviate import Client\n\n        client = cast(Client, client)\n    except ImportError:\n        raise ValueError(\n            \"Weaviate is not installed. \"\n            \"Please install it with `pip install", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/utils.py", "file_name": "utils.py"}, "index": 23, "child_indices": [], "ref_doc_id": "82a86f061d187eb61fee194b2b8aa7c6d5b8930e", "node_info": null}, "24": {"text": "       \"Please install it with `pip install weaviate-client`.\"\n        )\n    cast(Client, client)\n\n\ndef parse_get_response(response: Dict) -> Dict:\n    \"\"\"Parse get response from Weaviate.\"\"\"\n    if \"errors\" in response:\n        raise ValueError(\"Invalid query, got errors: {}\".format(response[\"errors\"]))\n    data_response = response[\"data\"]\n    if \"Get\" not in data_response:\n        raise ValueError(\"Invalid query response, must be a Get query.\")\n\n    return data_response[\"Get\"]\n\n\ndef get_by_id(\n    client: Any, object_id: str, class_name: str, properties: List[str]\n) -> Dict:\n    \"\"\"Get response by id from Weaviate.\"\"\"\n    validate_client(client)\n\n    where_filter = {\"path\": [\"id\"], \"operator\": \"Equal\", \"valueString\": object_id}\n    query_result = (\n     ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/utils.py", "file_name": "utils.py"}, "index": 24, "child_indices": [], "ref_doc_id": "82a86f061d187eb61fee194b2b8aa7c6d5b8930e", "node_info": null}, "25": {"text": "   query_result = (\n        client.query.get(class_name, properties)\n        .with_where(where_filter)\n        .with_additional([\"id\", \"vector\"])\n        .do()\n    )\n\n    parsed_result = parse_get_response(query_result)\n    entries = parsed_result[class_name]\n    if len(entries) == 0:\n        raise ValueError(\"No entry found for the given id\")\n    elif len(entries) > 1:\n        raise ValueError(\"More than one entry found for the given id\")\n    return entries[0]\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/utils.py", "file_name": "utils.py"}, "index": 25, "child_indices": [], "ref_doc_id": "82a86f061d187eb61fee194b2b8aa7c6d5b8930e", "node_info": null}, "26": {"text": "This code file is located in gpt_index/readers/weaviate/data_structs.py and contains the class BaseWeaviateIndexStruct, which is used to create a schema for Weaviate-specific serializers for GPT Index data structures. It contains methods for getting common properties, creating a schema, converting to and from GPT Index data structures, and getting entries by id. It also contains the class WeaviateNode, which is used to convert a Weaviate node to a GPT Index list.", "doc_id": null, "embedding": null, "extra_info": null, "index": 26, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "ref_doc_id": null, "node_info": null}, "27": {"text": "This code file contains two classes, WeaviateReader and DataStructs, which are used to read and store data from Weaviate. The WeaviateReader class is used to retrieve documents from Weaviate through vector lookup, and can return either separate Document objects per document or concatenate them into one Document. The DataStructs class is used to convert from the gpt index, json-serialize the extra_info and node_info, and delete documents. It also contains a get_default_class_prefix function to get the default class prefix, and a validate_client function to validate the client and import the weaviate library.", "doc_id": null, "embedding": null, "extra_info": null, "index": 27, "child_indices": [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "ref_doc_id": null, "node_info": null}, "28": {"text": "This code file, utils.py, is part of the gpt_index/readers/weaviate directory. It contains two functions, parse_get_response() and get_by_id(), which are used to query the Weaviate database. The parse_get_response() function takes a response dictionary as an argument and checks for errors. If there are no errors, it returns the data from the response. The get_by_id() function takes a client, object_id, class_name, and properties as arguments and uses the client to query the Weaviate database for the given object_id. It then parses the response and checks for errors. If there are no errors, it returns the entry for the given id.", "doc_id": null, "embedding": null, "extra_info": null, "index": 28, "child_indices": [24, 25], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"26": {"text": "This code file is located in gpt_index/readers/weaviate/data_structs.py and contains the class BaseWeaviateIndexStruct, which is used to create a schema for Weaviate-specific serializers for GPT Index data structures. It contains methods for getting common properties, creating a schema, converting to and from GPT Index data structures, and getting entries by id. It also contains the class WeaviateNode, which is used to convert a Weaviate node to a GPT Index list.", "doc_id": null, "embedding": null, "extra_info": null, "index": 26, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "ref_doc_id": null, "node_info": null}, "27": {"text": "This code file contains two classes, WeaviateReader and DataStructs, which are used to read and store data from Weaviate. The WeaviateReader class is used to retrieve documents from Weaviate through vector lookup, and can return either separate Document objects per document or concatenate them into one Document. The DataStructs class is used to convert from the gpt index, json-serialize the extra_info and node_info, and delete documents. It also contains a get_default_class_prefix function to get the default class prefix, and a validate_client function to validate the client and import the weaviate library.", "doc_id": null, "embedding": null, "extra_info": null, "index": 27, "child_indices": [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "ref_doc_id": null, "node_info": null}, "28": {"text": "This code file, utils.py, is part of the gpt_index/readers/weaviate directory. It contains two functions, parse_get_response() and get_by_id(), which are used to query the Weaviate database. The parse_get_response() function takes a response dictionary as an argument and checks for errors. If there are no errors, it returns the data from the response. The get_by_id() function takes a client, object_id, class_name, and properties as arguments and uses the client to query the Weaviate database for the given object_id. It then parses the response and checks for errors. If there are no errors, it returns the entry for the given id.", "doc_id": null, "embedding": null, "extra_info": null, "index": 28, "child_indices": [24, 25], "ref_doc_id": null, "node_info": null}}}, "docstore": {"docs": {"1d4640565ae2765d9ca96a509dc9809217f62f2f": {"text": "\"\"\"Init file.\"\"\"\n", "doc_id": "1d4640565ae2765d9ca96a509dc9809217f62f2f", "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/__init__.py", "file_name": "__init__.py"}, "__type__": "Document"}, "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e": {"text": "\"\"\"Weaviate-specific serializers for GPT Index data structures.\n\nContain conversion to and from dataclasses that GPT Index uses.\n\n\"\"\"\n\nimport json\nfrom abc import abstractmethod\nfrom typing import Any, Dict, Generic, List, Optional, TypeVar\n\nfrom gpt_index.data_structs.data_structs import IndexStruct, Node\nfrom gpt_index.readers.weaviate.utils import (\n    get_by_id,\n    parse_get_response,\n    validate_client,\n)\nfrom gpt_index.utils import get_new_id\n\nIS = TypeVar(\"IS\", bound=IndexStruct)\n\n\nclass BaseWeaviateIndexStruct(Generic[IS]):\n    \"\"\"Base Weaviate index struct.\"\"\"\n\n    @classmethod\n    @abstractmethod\n    def _class_name(cls, class_prefix: str) -> str:\n        \"\"\"Return class name.\"\"\"\n\n    @classmethod\n    def _get_common_properties(cls) -> List[Dict]:\n        \"\"\"Get common properties.\"\"\"\n        return [\n            {\n                \"dataType\": [\"string\"],\n                \"description\": \"Text property\",\n                \"name\": \"text\",\n            },\n            {\n                \"dataType\": [\"string\"],\n                \"description\": \"Document id\",\n                \"name\": \"doc_id\",\n            },\n            {\n                \"dataType\": [\"string\"],\n                \"description\": \"extra_info (in JSON)\",\n                \"name\": \"extra_info\",\n            },\n        ]\n\n    @classmethod\n    @abstractmethod\n    def _get_properties(cls) -> List[Dict]:\n        \"\"\"Get properties specific to each index struct.\n\n        Used in creating schema.\n\n        \"\"\"\n\n    @classmethod\n    def _get_by_id(cls, client: Any, object_id: str, class_prefix: str) -> Dict:\n        \"\"\"Get entry by id.\"\"\"\n        validate_client(client)\n        class_name = cls._class_name(class_prefix)\n        properties = cls._get_common_properties() + cls._get_properties()\n        prop_names = [p[\"name\"] for p in properties]\n        entry = get_by_id(client, object_id, class_name, prop_names)\n        return entry\n\n    @classmethod\n    def create_schema(cls, client: Any, class_prefix: str) -> None:\n        \"\"\"Create schema.\"\"\"\n        validate_client(client)\n        # first check if schema exists\n        schema = client.schema.get()\n        classes = schema[\"classes\"]\n        existing_class_names = {c[\"class\"] for c in classes}\n        # if schema already exists, don't create\n        class_name = cls._class_name(class_prefix)\n        if class_name in existing_class_names:\n            return\n\n        # get common properties\n        properties = cls._get_common_properties()\n        # get specific properties\n        properties.extend(cls._get_properties())\n        class_obj = {\n            \"class\": cls._class_name(class_prefix),  # <= note the capital \"A\".\n            \"description\": f\"Class for {class_name}\",\n            \"properties\": properties,\n        }\n        client.schema.create_class(class_obj)\n\n    @classmethod\n    @abstractmethod\n    def _entry_to_gpt_index(cls, entry: Dict) -> IS:\n        \"\"\"Convert to gpt index list.\"\"\"\n\n    @classmethod\n    def to_gpt_index_list(\n        cls,\n        client: Any,\n        class_prefix: str,\n        vector: Optional[List[float]] = None,\n        object_limit: Optional[int] = None,\n    ) -> List[IS]:\n        \"\"\"Convert to gpt index list.\"\"\"\n        validate_client(client)\n        class_name = cls._class_name(class_prefix)\n        properties = cls._get_common_properties() + cls._get_properties()\n        prop_names = [p[\"name\"] for p in properties]\n        query = client.query.get(class_name, prop_names).with_additional(\n            [\"id\", \"vector\"]\n        )\n        if vector is not None:\n            query = query.with_near_vector(\n                {\n                    \"vector\": vector,\n                }\n            )\n        if object_limit is not None:\n            query = query.with_limit(object_limit)\n        query_result = query.do()\n        parsed_result = parse_get_response(query_result)\n        entries = parsed_result[class_name]\n\n        results: List[IS] = []\n        for entry in entries:\n            results.append(cls._entry_to_gpt_index(entry))\n\n        return results\n\n    @classmethod\n    @abstractmethod\n    def _from_gpt_index(cls, client: Any, index: IS, class_prefix: str) -> str:\n        \"\"\"Convert from gpt index.\"\"\"\n\n    @classmethod\n    def from_gpt_index(cls, client: Any, index: IS, class_prefix: str) -> str:\n        \"\"\"Convert from gpt index.\"\"\"\n        validate_client(client)\n        index_id = cls._from_gpt_index(client, index, class_prefix)\n        client.batch.flush()\n        return index_id\n\n\nclass WeaviateNode(BaseWeaviateIndexStruct[Node]):\n    \"\"\"Weaviate node.\"\"\"\n\n    @classmethod\n    def _class_name(cls, class_prefix: str) -> str:\n        \"\"\"Return class name.\"\"\"\n        return f\"{class_prefix}_Node\"\n\n    @classmethod\n    def _get_properties(cls) -> List[Dict]:\n        \"\"\"Create schema.\"\"\"\n        return [\n            {\n                \"dataType\": [\"int\"],\n                \"description\": \"The index of the Node\",\n                \"name\": \"index\",\n            },\n            {\n                \"dataType\": [\"int[]\"],\n                \"description\": \"The child_indices of the Node\",\n                \"name\": \"child_indices\",\n            },\n            {\n                \"dataType\": [\"string\"],\n                \"description\": \"The ref_doc_id of the Node\",\n                \"name\": \"ref_doc_id\",\n            },\n            {\n                \"dataType\": [\"string\"],\n                \"description\": \"node_info (in JSON)\",\n                \"name\": \"node_info\",\n            },\n        ]\n\n    @classmethod\n    def _entry_to_gpt_index(cls, entry: Dict) -> Node:\n        \"\"\"Convert to gpt index list.\"\"\"\n        extra_info_str = entry[\"extra_info\"]\n        if extra_info_str == \"\":\n            extra_info = None\n        else:\n            extra_info = json.loads(extra_info_str)\n\n        node_info_str = entry[\"node_info\"]\n        if node_info_str == \"\":\n            node_info = None\n        else:\n            node_info = json.loads(node_info_str)\n        return Node(\n            text=entry[\"text\"],\n            doc_id=entry[\"doc_id\"],\n            index=int(entry[\"index\"]),\n            child_indices=entry[\"child_indices\"],\n            ref_doc_id=entry[\"ref_doc_id\"],\n            embedding=entry[\"_additional\"][\"vector\"],\n            extra_info=extra_info,\n            node_info=node_info,\n        )\n\n    @classmethod\n    def _from_gpt_index(cls, client: Any, node: Node, class_prefix: str) -> str:\n        \"\"\"Convert from gpt index.\"\"\"\n        node_dict = node.to_dict()\n        vector = node_dict.pop(\"embedding\")\n        extra_info = node_dict.pop(\"extra_info\")\n        # json-serialize the extra_info\n        extra_info_str = \"\"\n        if extra_info is not None:\n            extra_info_str = json.dumps(extra_info)\n        node_dict[\"extra_info\"] = extra_info_str\n        # json-serialize the node_info\n        node_info = node_dict.pop(\"node_info\")\n        node_info_str = \"\"\n        if node_info is not None:\n            node_info_str = json.dumps(node_info)\n        node_dict[\"node_info\"] = node_info_str\n\n        # TODO: account for existing nodes that are stored\n        node_id = get_new_id(set())\n        class_name = cls._class_name(class_prefix)\n        client.batch.add_data_object(node_dict, class_name, node_id, vector)\n\n        return node_id\n\n    @classmethod\n    def delete_document(cls, client: Any, ref_doc_id: str, class_prefix: str) -> None:\n        \"\"\"Delete entry.\"\"\"\n        validate_client(client)\n        # make sure that each entry\n        class_name = cls._class_name(class_prefix)\n        where_filter = {\n            \"path\": [\"ref_doc_id\"],\n            \"operator\": \"Equal\",\n            \"valueString\": ref_doc_id,\n        }\n        query = (\n            client.query.get(class_name)\n            .with_additional([\"id\"])\n            .with_where(where_filter)\n        )\n\n        query_result = query.do()\n        parsed_result = parse_get_response(query_result)\n        entries = parsed_result[class_name]\n        for entry in entries:\n            client.data_object.delete(entry[\"_additional\"][\"id\"], class_name)\n", "doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "__type__": "Document"}, "9fb7548dd341b7bbe79a3a28e6bf3fd7ef78c44d": {"text": "\"\"\"Weaviate reader.\"\"\"\n\nfrom typing import Any, List, Optional\n\nfrom gpt_index.readers.base import BaseReader\nfrom gpt_index.readers.schema.base import Document\n\n\nclass WeaviateReader(BaseReader):\n    \"\"\"Weaviate reader.\n\n    Retrieves documents from Weaviate through vector lookup. Allows option\n    to concatenate retrieved documents into one Document, or to return\n    separate Document objects per document.\n\n    Args:\n        host (str): host.\n        auth_client_secret (Optional[weaviate.auth.AuthCredentials]):\n            auth_client_secret.\n    \"\"\"\n\n    def __init__(\n        self,\n        host: str,\n        auth_client_secret: Optional[Any] = None,\n    ) -> None:\n        \"\"\"Initialize with parameters.\"\"\"\n        try:\n            import weaviate  # noqa: F401\n            from weaviate import Client  # noqa: F401\n            from weaviate.auth import AuthCredentials  # noqa: F401\n        except ImportError:\n            raise ValueError(\n                \"`weaviate` package not found, please run `pip install weaviate-client`\"\n            )\n\n        self.client: Client = Client(host, auth_client_secret=auth_client_secret)\n\n    def load_data(\n        self,\n        class_name: Optional[str] = None,\n        properties: Optional[List[str]] = None,\n        graphql_query: Optional[str] = None,\n        separate_documents: Optional[bool] = True,\n    ) -> List[Document]:\n        \"\"\"Load data from Weaviate.\n\n        If `graphql_query` is not found in load_kwargs, we assume that\n        `class_name` and `properties` are provided.\n\n        Args:\n            class_name (Optional[str]): class_name to retrieve documents from.\n            properties (Optional[List[str]]): properties to retrieve from documents.\n            graphql_query (Optional[str]): Raw GraphQL Query.\n                We assume that the query is a Get query.\n            separate_documents (Optional[bool]): Whether to return separate\n                documents. Defaults to True.\n\n        Returns:\n            List[Document]: A list of documents.\n\n        \"\"\"\n        if class_name is not None and properties is not None:\n            props_txt = \"\\n\".join(properties)\n            graphql_query = f\"\"\"\n            {{\n                Get {{\n                    {class_name} {{\n                        {props_txt}\n                    }}\n                }}\n            }}\n            \"\"\"\n        elif graphql_query is not None:\n            pass\n        else:\n            raise ValueError(\n                \"Either `class_name` and `properties` must be specified, \"\n                \"or `graphql_query` must be specified.\"\n            )\n\n        response = self.client.query.raw(graphql_query)\n        if \"errors\" in response:\n            raise ValueError(\"Invalid query, got errors: {}\".format(response[\"errors\"]))\n\n        data_response = response[\"data\"]\n        if \"Get\" not in data_response:\n            raise ValueError(\"Invalid query response, must be a Get query.\")\n\n        if class_name is None:\n            # infer class_name if only graphql_query was provided\n            class_name = list(data_response[\"Get\"].keys())[0]\n        entries = data_response[\"Get\"][class_name]\n        documents = []\n        for entry in entries:\n            embedding = None\n            # for each entry, join properties into <property>:<value>\n            # separated by newlines\n            text_list = []\n            for k, v in entry.items():\n                if k == \"_additional\":\n                    if \"vector\" in v:\n                        embedding = v[\"vector\"]\n                    continue\n                text_list.append(f\"{k}: {v}\")\n\n            text = \"\\n\".join(text_list)\n            documents.append(Document(text=text, embedding=embedding))\n\n        if not separate_documents:\n            # join all documents into one\n            text_list = [doc.get_text() for doc in documents]\n            text = \"\\n\\n\".join(text_list)\n            documents = [Document(text=text)]\n\n        return documents\n", "doc_id": "9fb7548dd341b7bbe79a3a28e6bf3fd7ef78c44d", "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/reader.py", "file_name": "reader.py"}, "__type__": "Document"}, "82a86f061d187eb61fee194b2b8aa7c6d5b8930e": {"text": "\"\"\"Weaviate utils.\"\"\"\n\nfrom typing import Any, Dict, List, Set, cast\n\nfrom gpt_index.utils import get_new_int_id\n\nDEFAULT_CLASS_PREFIX_STUB = \"Gpt_Index\"\n\n\ndef get_default_class_prefix(current_id_set: Set = set()) -> str:\n    \"\"\"Get default class prefix.\"\"\"\n    return DEFAULT_CLASS_PREFIX_STUB + \"_\" + str(get_new_int_id(current_id_set))\n\n\ndef validate_client(client: Any) -> None:\n    \"\"\"Validate client and import weaviate library.\"\"\"\n    try:\n        import weaviate  # noqa: F401\n        from weaviate import Client\n\n        client = cast(Client, client)\n    except ImportError:\n        raise ValueError(\n            \"Weaviate is not installed. \"\n            \"Please install it with `pip install weaviate-client`.\"\n        )\n    cast(Client, client)\n\n\ndef parse_get_response(response: Dict) -> Dict:\n    \"\"\"Parse get response from Weaviate.\"\"\"\n    if \"errors\" in response:\n        raise ValueError(\"Invalid query, got errors: {}\".format(response[\"errors\"]))\n    data_response = response[\"data\"]\n    if \"Get\" not in data_response:\n        raise ValueError(\"Invalid query response, must be a Get query.\")\n\n    return data_response[\"Get\"]\n\n\ndef get_by_id(\n    client: Any, object_id: str, class_name: str, properties: List[str]\n) -> Dict:\n    \"\"\"Get response by id from Weaviate.\"\"\"\n    validate_client(client)\n\n    where_filter = {\"path\": [\"id\"], \"operator\": \"Equal\", \"valueString\": object_id}\n    query_result = (\n        client.query.get(class_name, properties)\n        .with_where(where_filter)\n        .with_additional([\"id\", \"vector\"])\n        .do()\n    )\n\n    parsed_result = parse_get_response(query_result)\n    entries = parsed_result[class_name]\n    if len(entries) == 0:\n        raise ValueError(\"No entry found for the given id\")\n    elif len(entries) > 1:\n        raise ValueError(\"More than one entry found for the given id\")\n    return entries[0]\n", "doc_id": "82a86f061d187eb61fee194b2b8aa7c6d5b8930e", "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/utils.py", "file_name": "utils.py"}, "__type__": "Document"}, "c73a93c9-8f3c-4a72-a674-e11b3234c11c": {"text": "\nThe __init__.py and data_structs.py documents provide functions for retrieving documents from Weaviate through vector lookup, converting from gpt index, deleting documents, and loading data from Weaviate. Additionally, the documents provide functions for validating the client, parsing get responses from Weaviate, and getting a default class prefix. The utils.py file contains two functions, parse_get_response() and get_by_id(), which are used to query the Weaviate database. The BaseWeaviateIndexStruct class is used to create a schema for Weaviate-specific serializers for GPT Index data structures. The WeaviateReader class is used to retrieve documents from Weaviate through vector lookup.", "doc_id": "c73a93c9-8f3c-4a72-a674-e11b3234c11c", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"Init file.\"\"\"\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/__init__.py", "file_name": "__init__.py"}, "index": 0, "child_indices": [], "ref_doc_id": "1d4640565ae2765d9ca96a509dc9809217f62f2f", "node_info": null}, "1": {"text": "\"\"\"Weaviate-specific serializers for GPT Index data structures.\n\nContain conversion to and from dataclasses that GPT Index uses.\n\n\"\"\"\n\nimport json\nfrom abc import abstractmethod\nfrom typing import Any, Dict, Generic, List, Optional, TypeVar\n\nfrom gpt_index.data_structs.data_structs import IndexStruct, Node\nfrom gpt_index.readers.weaviate.utils import (\n    get_by_id,\n    parse_get_response,\n    validate_client,\n)\nfrom gpt_index.utils import get_new_id\n\nIS = TypeVar(\"IS\", bound=IndexStruct)\n\n\nclass BaseWeaviateIndexStruct(Generic[IS]):\n    \"\"\"Base Weaviate index struct.\"\"\"\n\n    @classmethod\n    @abstractmethod\n    def _class_name(cls, class_prefix: str) -> str:\n        \"\"\"Return class name.\"\"\"\n\n    @classmethod\n    def _get_common_properties(cls) -> List[Dict]:\n       ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 1, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "2": {"text": "-> List[Dict]:\n        \"\"\"Get common properties.\"\"\"\n        return [\n            {\n                \"dataType\": [\"string\"],\n                \"description\": \"Text property\",\n                \"name\": \"text\",\n            },\n            {\n                \"dataType\": [\"string\"],\n                \"description\": \"Document id\",\n                \"name\": \"doc_id\",\n            },\n            {\n                \"dataType\": [\"string\"],\n                \"description\": \"extra_info", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 2, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "3": {"text": "         \"description\": \"extra_info (in JSON)\",\n                \"name\": \"extra_info\",\n            },\n        ]\n\n    @classmethod\n    @abstractmethod\n    def _get_properties(cls) -> List[Dict]:\n        \"\"\"Get properties specific to each index struct.\n\n        Used in creating schema.\n\n        \"\"\"\n\n    @classmethod\n    def _get_by_id(cls, client: Any, object_id: str, class_prefix: str) -> Dict:\n        \"\"\"Get entry by id.\"\"\"\n        validate_client(client)\n        class_name = cls._class_name(class_prefix)\n        properties = cls._get_common_properties() + cls._get_properties()\n        prop_names =", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 3, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "4": {"text": "       prop_names = [p[\"name\"] for p in properties]\n        entry = get_by_id(client, object_id, class_name, prop_names)\n        return entry\n\n    @classmethod\n    def create_schema(cls, client: Any, class_prefix: str) -> None:\n        \"\"\"Create schema.\"\"\"\n        validate_client(client)\n        # first check if schema exists\n        schema = client.schema.get()\n        classes = schema[\"classes\"]\n        existing_class_names = {c[\"class\"] for c in classes}\n        # if schema already exists, don't create\n        class_name = cls._class_name(class_prefix)\n        if class_name in existing_class_names:\n            return\n\n       ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 4, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "5": {"text": "       return\n\n        # get common properties\n        properties = cls._get_common_properties()\n        # get specific properties\n        properties.extend(cls._get_properties())\n        class_obj = {\n            \"class\": cls._class_name(class_prefix),  # <= note the capital \"A\".\n            \"description\": f\"Class for {class_name}\",\n            \"properties\": properties,\n        }\n        client.schema.create_class(class_obj)\n\n    @classmethod\n    @abstractmethod\n    def _entry_to_gpt_index(cls, entry: Dict) -> IS:\n        \"\"\"Convert to gpt index list.\"\"\"\n\n    @classmethod\n    def to_gpt_index_list(\n      ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 5, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "6": {"text": "to_gpt_index_list(\n        cls,\n        client: Any,\n        class_prefix: str,\n        vector: Optional[List[float]] = None,\n        object_limit: Optional[int] = None,\n    ) -> List[IS]:\n        \"\"\"Convert to gpt index list.\"\"\"\n        validate_client(client)\n        class_name = cls._class_name(class_prefix)\n        properties = cls._get_common_properties() + cls._get_properties()\n        prop_names = [p[\"name\"] for p in properties]\n        query = client.query.get(class_name, prop_names).with_additional(\n            [\"id\", \"vector\"]\n        )\n        if vector is not None:\n         ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 6, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "7": {"text": "if vector is not None:\n            query = query.with_near_vector(\n                {\n                    \"vector\": vector,\n                }\n            )\n        if object_limit is not None:\n            query = query.with_limit(object_limit)\n        query_result = query.do()\n        parsed_result = parse_get_response(query_result)\n        entries = parsed_result[class_name]\n\n        results: List[IS] = []\n        for entry in entries:\n            results.append(cls._entry_to_gpt_index(entry))\n\n        return results\n\n    @classmethod\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 7, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "8": {"text": "      return results\n\n    @classmethod\n    @abstractmethod\n    def _from_gpt_index(cls, client: Any, index: IS, class_prefix: str) -> str:\n        \"\"\"Convert from gpt index.\"\"\"\n\n    @classmethod\n    def from_gpt_index(cls, client: Any, index: IS, class_prefix: str) -> str:\n        \"\"\"Convert from gpt index.\"\"\"\n        validate_client(client)\n        index_id = cls._from_gpt_index(client, index, class_prefix)\n        client.batch.flush()\n        return index_id\n\n\nclass WeaviateNode(BaseWeaviateIndexStruct[Node]):\n    \"\"\"Weaviate node.\"\"\"\n\n    @classmethod\n    def _class_name(cls, class_prefix: str) -> str:\n        \"\"\"Return class name.\"\"\"\n      ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 8, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "9": {"text": "   \"\"\"Return class name.\"\"\"\n        return f\"{class_prefix}_Node\"\n\n    @classmethod\n    def _get_properties(cls) -> List[Dict]:\n        \"\"\"Create schema.\"\"\"\n        return [\n            {\n                \"dataType\": [\"int\"],\n                \"description\": \"The index of the Node\",\n                \"name\": \"index\",\n            },\n            {\n                \"dataType\": [\"int[]\"],\n                \"description\": \"The child_indices of the Node\",\n                \"name\": \"child_indices\",\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 9, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "10": {"text": "           },\n            {\n                \"dataType\": [\"string\"],\n                \"description\": \"The ref_doc_id of the Node\",\n                \"name\": \"ref_doc_id\",\n            },\n            {\n                \"dataType\": [\"string\"],\n                \"description\": \"node_info (in JSON)\",\n                \"name\": \"node_info\",\n            },\n        ]\n\n    @classmethod\n    def _entry_to_gpt_index(cls, entry: Dict) -> Node:\n        \"\"\"Convert to gpt index list.\"\"\"\n ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 10, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "11": {"text": "    \"\"\"Convert to gpt index list.\"\"\"\n        extra_info_str = entry[\"extra_info\"]\n        if extra_info_str == \"\":\n            extra_info = None\n        else:\n            extra_info = json.loads(extra_info_str)\n\n        node_info_str = entry[\"node_info\"]\n        if node_info_str == \"\":\n            node_info = None\n        else:\n            node_info = json.loads(node_info_str)\n        return Node(\n            text=entry[\"text\"],\n            doc_id=entry[\"doc_id\"],\n            index=int(entry[\"index\"]),\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 11, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "12": {"text": "           child_indices=entry[\"child_indices\"],\n            ref_doc_id=entry[\"ref_doc_id\"],\n            embedding=entry[\"_additional\"][\"vector\"],\n            extra_info=extra_info,\n            node_info=node_info,\n        )\n\n    @classmethod\n    def _from_gpt_index(cls, client: Any, node: Node, class_prefix: str) -> str:\n        \"\"\"Convert from gpt index.\"\"\"\n        node_dict = node.to_dict()\n        vector = node_dict.pop(\"embedding\")\n        extra_info = node_dict.pop(\"extra_info\")\n        # json-serialize the extra_info\n        extra_info_str = \"\"\n       ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 12, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "13": {"text": " extra_info_str = \"\"\n        if extra_info is not None:\n            extra_info_str = json.dumps(extra_info)\n        node_dict[\"extra_info\"] = extra_info_str\n        # json-serialize the node_info\n        node_info = node_dict.pop(\"node_info\")\n        node_info_str = \"\"\n        if node_info is not None:\n            node_info_str = json.dumps(node_info)\n        node_dict[\"node_info\"] = node_info_str\n\n        # TODO: account for existing nodes that are stored\n        node_id = get_new_id(set())\n        class_name = cls._class_name(class_prefix)\n        client.batch.add_data_object(node_dict,", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 13, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "14": {"text": "  client.batch.add_data_object(node_dict, class_name, node_id, vector)\n\n        return node_id\n\n    @classmethod\n    def delete_document(cls, client: Any, ref_doc_id: str, class_prefix: str) -> None:\n        \"\"\"Delete entry.\"\"\"\n        validate_client(client)\n        # make sure that each entry\n        class_name = cls._class_name(class_prefix)\n        where_filter = {\n            \"path\": [\"ref_doc_id\"],\n            \"operator\": \"Equal\",\n            \"valueString\": ref_doc_id,\n        }\n        query = (\n            client.query.get(class_name)\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 14, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "15": {"text": "           .with_additional([\"id\"])\n            .with_where(where_filter)\n        )\n\n        query_result = query.do()\n        parsed_result = parse_get_response(query_result)\n        entries = parsed_result[class_name]\n        for entry in entries:\n            client.data_object.delete(entry[\"_additional\"][\"id\"], class_name)\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/data_structs.py", "file_name": "data_structs.py"}, "index": 15, "child_indices": [], "ref_doc_id": "460d2ae4fea64197bd58b237d3e9f7ac8ad5604e", "node_info": null}, "16": {"text": "\"\"\"Weaviate reader.\"\"\"\n\nfrom typing import Any, List, Optional\n\nfrom gpt_index.readers.base import BaseReader\nfrom gpt_index.readers.schema.base import Document\n\n\nclass WeaviateReader(BaseReader):\n    \"\"\"Weaviate reader.\n\n    Retrieves documents from Weaviate through vector lookup. Allows option\n    to concatenate retrieved documents into one Document, or to return\n    separate Document objects per document.\n\n    Args:\n        host (str): host.\n        auth_client_secret (Optional[weaviate.auth.AuthCredentials]):\n            auth_client_secret.\n    \"\"\"\n\n    def __init__(\n        self,\n        host: str,\n        auth_client_secret: Optional[Any] = None,\n    ) -> None:\n        \"\"\"Initialize with parameters.\"\"\"\n        try:\n      ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/reader.py", "file_name": "reader.py"}, "index": 16, "child_indices": [], "ref_doc_id": "9fb7548dd341b7bbe79a3a28e6bf3fd7ef78c44d", "node_info": null}, "17": {"text": "       try:\n            import weaviate  # noqa: F401\n            from weaviate import Client  # noqa: F401\n            from weaviate.auth import AuthCredentials  # noqa: F401\n        except ImportError:\n            raise ValueError(\n                \"`weaviate` package not found, please run `pip install weaviate-client`\"\n            )\n\n        self.client: Client = Client(host, auth_client_secret=auth_client_secret)\n\n    def load_data(\n        self,\n        class_name: Optional[str] = None,\n        properties: Optional[List[str]] = None,\n        graphql_query: Optional[str] = None,\n       ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/reader.py", "file_name": "reader.py"}, "index": 17, "child_indices": [], "ref_doc_id": "9fb7548dd341b7bbe79a3a28e6bf3fd7ef78c44d", "node_info": null}, "18": {"text": "Optional[str] = None,\n        separate_documents: Optional[bool] = True,\n    ) -> List[Document]:\n        \"\"\"Load data from Weaviate.\n\n        If `graphql_query` is not found in load_kwargs, we assume that\n        `class_name` and `properties` are provided.\n\n        Args:\n            class_name (Optional[str]): class_name to retrieve documents from.\n            properties (Optional[List[str]]): properties to retrieve from documents.\n            graphql_query (Optional[str]): Raw GraphQL Query.\n                We assume that the query is a Get query.\n            separate_documents (Optional[bool]): Whether to return separate\n                documents. Defaults to True.\n\n      ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/reader.py", "file_name": "reader.py"}, "index": 18, "child_indices": [], "ref_doc_id": "9fb7548dd341b7bbe79a3a28e6bf3fd7ef78c44d", "node_info": null}, "19": {"text": " documents. Defaults to True.\n\n        Returns:\n            List[Document]: A list of documents.\n\n        \"\"\"\n        if class_name is not None and properties is not None:\n            props_txt = \"\\n\".join(properties)\n            graphql_query = f\"\"\"\n            {{\n                Get {{\n                    {class_name} {{\n                        {props_txt}\n                    }}\n                }}\n            }}\n            \"\"\"\n        elif graphql_query is not None:\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/reader.py", "file_name": "reader.py"}, "index": 19, "child_indices": [], "ref_doc_id": "9fb7548dd341b7bbe79a3a28e6bf3fd7ef78c44d", "node_info": null}, "20": {"text": "     elif graphql_query is not None:\n            pass\n        else:\n            raise ValueError(\n                \"Either `class_name` and `properties` must be specified, \"\n                \"or `graphql_query` must be specified.\"\n            )\n\n        response = self.client.query.raw(graphql_query)\n        if \"errors\" in response:\n            raise ValueError(\"Invalid query, got errors: {}\".format(response[\"errors\"]))\n\n        data_response = response[\"data\"]\n        if \"Get\" not in data_response:\n            raise ValueError(\"Invalid query response, must be a Get query.\")\n\n        if class_name is None:\n            #", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/reader.py", "file_name": "reader.py"}, "index": 20, "child_indices": [], "ref_doc_id": "9fb7548dd341b7bbe79a3a28e6bf3fd7ef78c44d", "node_info": null}, "21": {"text": "is None:\n            # infer class_name if only graphql_query was provided\n            class_name = list(data_response[\"Get\"].keys())[0]\n        entries = data_response[\"Get\"][class_name]\n        documents = []\n        for entry in entries:\n            embedding = None\n            # for each entry, join properties into <property>:<value>\n            # separated by newlines\n            text_list = []\n            for k, v in entry.items():\n                if k == \"_additional\":\n                    if \"vector\" in v:\n                        embedding =", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/reader.py", "file_name": "reader.py"}, "index": 21, "child_indices": [], "ref_doc_id": "9fb7548dd341b7bbe79a3a28e6bf3fd7ef78c44d", "node_info": null}, "22": {"text": "             embedding = v[\"vector\"]\n                    continue\n                text_list.append(f\"{k}: {v}\")\n\n            text = \"\\n\".join(text_list)\n            documents.append(Document(text=text, embedding=embedding))\n\n        if not separate_documents:\n            # join all documents into one\n            text_list = [doc.get_text() for doc in documents]\n            text = \"\\n\\n\".join(text_list)\n            documents = [Document(text=text)]\n\n        return documents\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/reader.py", "file_name": "reader.py"}, "index": 22, "child_indices": [], "ref_doc_id": "9fb7548dd341b7bbe79a3a28e6bf3fd7ef78c44d", "node_info": null}, "23": {"text": "\"\"\"Weaviate utils.\"\"\"\n\nfrom typing import Any, Dict, List, Set, cast\n\nfrom gpt_index.utils import get_new_int_id\n\nDEFAULT_CLASS_PREFIX_STUB = \"Gpt_Index\"\n\n\ndef get_default_class_prefix(current_id_set: Set = set()) -> str:\n    \"\"\"Get default class prefix.\"\"\"\n    return DEFAULT_CLASS_PREFIX_STUB + \"_\" + str(get_new_int_id(current_id_set))\n\n\ndef validate_client(client: Any) -> None:\n    \"\"\"Validate client and import weaviate library.\"\"\"\n    try:\n        import weaviate  # noqa: F401\n        from weaviate import Client\n\n        client = cast(Client, client)\n    except ImportError:\n        raise ValueError(\n            \"Weaviate is not installed. \"\n            \"Please install it with `pip install", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/utils.py", "file_name": "utils.py"}, "index": 23, "child_indices": [], "ref_doc_id": "82a86f061d187eb61fee194b2b8aa7c6d5b8930e", "node_info": null}, "24": {"text": "       \"Please install it with `pip install weaviate-client`.\"\n        )\n    cast(Client, client)\n\n\ndef parse_get_response(response: Dict) -> Dict:\n    \"\"\"Parse get response from Weaviate.\"\"\"\n    if \"errors\" in response:\n        raise ValueError(\"Invalid query, got errors: {}\".format(response[\"errors\"]))\n    data_response = response[\"data\"]\n    if \"Get\" not in data_response:\n        raise ValueError(\"Invalid query response, must be a Get query.\")\n\n    return data_response[\"Get\"]\n\n\ndef get_by_id(\n    client: Any, object_id: str, class_name: str, properties: List[str]\n) -> Dict:\n    \"\"\"Get response by id from Weaviate.\"\"\"\n    validate_client(client)\n\n    where_filter = {\"path\": [\"id\"], \"operator\": \"Equal\", \"valueString\": object_id}\n    query_result = (\n     ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/utils.py", "file_name": "utils.py"}, "index": 24, "child_indices": [], "ref_doc_id": "82a86f061d187eb61fee194b2b8aa7c6d5b8930e", "node_info": null}, "25": {"text": "   query_result = (\n        client.query.get(class_name, properties)\n        .with_where(where_filter)\n        .with_additional([\"id\", \"vector\"])\n        .do()\n    )\n\n    parsed_result = parse_get_response(query_result)\n    entries = parsed_result[class_name]\n    if len(entries) == 0:\n        raise ValueError(\"No entry found for the given id\")\n    elif len(entries) > 1:\n        raise ValueError(\"More than one entry found for the given id\")\n    return entries[0]\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/weaviate/utils.py", "file_name": "utils.py"}, "index": 25, "child_indices": [], "ref_doc_id": "82a86f061d187eb61fee194b2b8aa7c6d5b8930e", "node_info": null}, "26": {"text": "This code file is located in gpt_index/readers/weaviate/data_structs.py and contains the class BaseWeaviateIndexStruct, which is used to create a schema for Weaviate-specific serializers for GPT Index data structures. It contains methods for getting common properties, creating a schema, converting to and from GPT Index data structures, and getting entries by id. It also contains the class WeaviateNode, which is used to convert a Weaviate node to a GPT Index list.", "doc_id": null, "embedding": null, "extra_info": null, "index": 26, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "ref_doc_id": null, "node_info": null}, "27": {"text": "This code file contains two classes, WeaviateReader and DataStructs, which are used to read and store data from Weaviate. The WeaviateReader class is used to retrieve documents from Weaviate through vector lookup, and can return either separate Document objects per document or concatenate them into one Document. The DataStructs class is used to convert from the gpt index, json-serialize the extra_info and node_info, and delete documents. It also contains a get_default_class_prefix function to get the default class prefix, and a validate_client function to validate the client and import the weaviate library.", "doc_id": null, "embedding": null, "extra_info": null, "index": 27, "child_indices": [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "ref_doc_id": null, "node_info": null}, "28": {"text": "This code file, utils.py, is part of the gpt_index/readers/weaviate directory. It contains two functions, parse_get_response() and get_by_id(), which are used to query the Weaviate database. The parse_get_response() function takes a response dictionary as an argument and checks for errors. If there are no errors, it returns the data from the response. The get_by_id() function takes a client, object_id, class_name, and properties as arguments and uses the client to query the Weaviate database for the given object_id. It then parses the response and checks for errors. If there are no errors, it returns the entry for the given id.", "doc_id": null, "embedding": null, "extra_info": null, "index": 28, "child_indices": [24, 25], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"26": {"text": "This code file is located in gpt_index/readers/weaviate/data_structs.py and contains the class BaseWeaviateIndexStruct, which is used to create a schema for Weaviate-specific serializers for GPT Index data structures. It contains methods for getting common properties, creating a schema, converting to and from GPT Index data structures, and getting entries by id. It also contains the class WeaviateNode, which is used to convert a Weaviate node to a GPT Index list.", "doc_id": null, "embedding": null, "extra_info": null, "index": 26, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "ref_doc_id": null, "node_info": null}, "27": {"text": "This code file contains two classes, WeaviateReader and DataStructs, which are used to read and store data from Weaviate. The WeaviateReader class is used to retrieve documents from Weaviate through vector lookup, and can return either separate Document objects per document or concatenate them into one Document. The DataStructs class is used to convert from the gpt index, json-serialize the extra_info and node_info, and delete documents. It also contains a get_default_class_prefix function to get the default class prefix, and a validate_client function to validate the client and import the weaviate library.", "doc_id": null, "embedding": null, "extra_info": null, "index": 27, "child_indices": [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "ref_doc_id": null, "node_info": null}, "28": {"text": "This code file, utils.py, is part of the gpt_index/readers/weaviate directory. It contains two functions, parse_get_response() and get_by_id(), which are used to query the Weaviate database. The parse_get_response() function takes a response dictionary as an argument and checks for errors. If there are no errors, it returns the data from the response. The get_by_id() function takes a client, object_id, class_name, and properties as arguments and uses the client to query the Weaviate database for the given object_id. It then parses the response and checks for errors. If there are no errors, it returns the entry for the given id.", "doc_id": null, "embedding": null, "extra_info": null, "index": 28, "child_indices": [24, 25], "ref_doc_id": null, "node_info": null}}, "__type__": "tree"}}}}