{"index_struct": {"text": "\nThe test_docstore.py file tests the DocumentStore class's ability to retrieve documents and serialize them into dictionaries. The test_utils.py file tests the tokenizer, retry_on_exceptions_with_backoff, and retry_on_conditional_exceptions functions of the utils module.", "doc_id": "6f0bb870-9ed0-4704-bf47-ae057d86a020", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"Init file.\"\"\"\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/__init__.py", "file_name": "__init__.py"}, "index": 0, "child_indices": [], "ref_doc_id": "1d4640565ae2765d9ca96a509dc9809217f62f2f", "node_info": null}, "1": {"text": "\"\"\"Test docstore.\"\"\"\n\nfrom typing import Dict, Type\n\nfrom gpt_index.data_structs.data_structs import IndexStruct, Node\nfrom gpt_index.docstore import DocumentStore\nfrom gpt_index.readers.schema.base import Document\n\n\ndef test_docstore() -> None:\n    \"\"\"Test docstore.\"\"\"\n    doc = Document(\"hello world\", doc_id=\"d1\", extra_info={\"foo\": \"bar\"})\n    node = Node(\"my node\", doc_id=\"d2\", node_info={\"node\": \"info\"})\n\n    type_to_struct: Dict[str, Type[IndexStruct]] = {\"node\": Node}\n\n    # test get document\n    docstore = DocumentStore.from_documents([doc, node])\n    gd1 = docstore.get_document(\"d1\")\n    assert gd1 == doc\n    gd2 = docstore.get_document(\"d2\")\n    assert gd2 == node\n\n    # test serialize/deserialize\n    doc_dict = docstore.serialize_to_dict()\n    assert", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/test_docstore.py", "file_name": "test_docstore.py"}, "index": 1, "child_indices": [], "ref_doc_id": "5542097578c1b4bdfd1108235f4f7c42f54f7a1c", "node_info": null}, "2": {"text": "= docstore.serialize_to_dict()\n    assert doc_dict[\"docs\"] == {\n        \"d1\": {\n            \"text\": \"hello world\",\n            \"doc_id\": \"d1\",\n            \"embedding\": None,\n            \"extra_info\": {\"foo\": \"bar\"},\n            \"__type__\": \"Document\",\n        },\n        \"d2\": {\n            \"text\": \"my node\",\n            \"doc_id\": \"d2\",\n            \"embedding\": None,\n            \"extra_info\": None,\n            \"node_info\": {\"node\": \"info\"},\n            \"index\": 0,\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/test_docstore.py", "file_name": "test_docstore.py"}, "index": 2, "child_indices": [], "ref_doc_id": "5542097578c1b4bdfd1108235f4f7c42f54f7a1c", "node_info": null}, "3": {"text": "0,\n            \"child_indices\": [],\n            \"ref_doc_id\": None,\n            \"__type__\": \"node\",\n        },\n    }\n\n    docstore_loaded = DocumentStore.load_from_dict(doc_dict, type_to_struct)\n    assert docstore_loaded == docstore\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/test_docstore.py", "file_name": "test_docstore.py"}, "index": 3, "child_indices": [], "ref_doc_id": "5542097578c1b4bdfd1108235f4f7c42f54f7a1c", "node_info": null}, "4": {"text": "\"\"\"Test utils.\"\"\"\n\nfrom typing import Optional, Type, Union\n\nimport pytest\n\nfrom gpt_index.utils import (\n    ErrorToRetry,\n    globals_helper,\n    retry_on_exceptions_with_backoff,\n)\n\n\ndef test_tokenizer() -> None:\n    \"\"\"Make sure tokenizer works.\n\n    NOTE: we use a different tokenizer for python >= 3.9.\n\n    \"\"\"\n    text = \"hello world foo bar\"\n    tokenizer = globals_helper.tokenizer\n    assert len(tokenizer(text)) == 4\n\n\ncall_count = 0\n\n\ndef fn_with_exception(\n    exception_cls: Optional[Union[Type[Exception], Exception]]\n) -> bool:\n    \"\"\"Return true unless exception is specified.\"\"\"\n    global call_count\n    call_count += 1\n    if exception_cls:\n        raise exception_cls\n    return True\n\n\nclass ConditionalException(Exception):\n    \"\"\"Exception that contains retry attribute.\"\"\"\n\n   ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/test_utils.py", "file_name": "test_utils.py"}, "index": 4, "child_indices": [], "ref_doc_id": "e53db54622ade21e7df6c38eaab8124ceeac9497", "node_info": null}, "5": {"text": "  \"\"\"Exception that contains retry attribute.\"\"\"\n\n    def __init__(self, should_retry: bool) -> None:\n        \"\"\"Initialize with parameters.\"\"\"\n        self.should_retry = should_retry\n\n\ndef test_retry_on_exceptions_with_backoff() -> None:\n    \"\"\"Make sure retry function has accurate number of attempts.\"\"\"\n    global call_count\n    assert fn_with_exception(None)\n\n    call_count = 0\n    with pytest.raises(ValueError):\n        fn_with_exception(ValueError)\n    assert call_count == 1\n\n    call_count = 0\n    with pytest.raises(ValueError):\n        retry_on_exceptions_with_backoff(\n            lambda: fn_with_exception(ValueError),\n            [ErrorToRetry(ValueError)],\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/test_utils.py", "file_name": "test_utils.py"}, "index": 5, "child_indices": [], "ref_doc_id": "e53db54622ade21e7df6c38eaab8124ceeac9497", "node_info": null}, "6": {"text": "           max_tries=3,\n            min_backoff_secs=0.0,\n        )\n    assert call_count == 3\n\n    # different exception will not get retried\n    call_count = 0\n    with pytest.raises(TypeError):\n        retry_on_exceptions_with_backoff(\n            lambda: fn_with_exception(TypeError),\n            [ErrorToRetry(ValueError)],\n            max_tries=3,\n        )\n    assert call_count == 1\n\n\ndef test_retry_on_conditional_exceptions() -> None:\n    \"\"\"Make sure retry function works on conditional exceptions.\"\"\"\n    global call_count\n    call_count = 0\n    with pytest.raises(ConditionalException):\n       ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/test_utils.py", "file_name": "test_utils.py"}, "index": 6, "child_indices": [], "ref_doc_id": "e53db54622ade21e7df6c38eaab8124ceeac9497", "node_info": null}, "7": {"text": "       retry_on_exceptions_with_backoff(\n            lambda: fn_with_exception(ConditionalException(True)),\n            [ErrorToRetry(ConditionalException, lambda e: e.should_retry)],\n            max_tries=3,\n            min_backoff_secs=0.0,\n        )\n    assert call_count == 3\n\n    call_count = 0\n    with pytest.raises(ConditionalException):\n        retry_on_exceptions_with_backoff(\n            lambda: fn_with_exception(ConditionalException(False)),\n            [ErrorToRetry(ConditionalException, lambda e: e.should_retry)],\n            max_tries=3,\n            min_backoff_secs=0.0,\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/test_utils.py", "file_name": "test_utils.py"}, "index": 7, "child_indices": [], "ref_doc_id": "e53db54622ade21e7df6c38eaab8124ceeac9497", "node_info": null}, "8": {"text": "   min_backoff_secs=0.0,\n        )\n    assert call_count == 1\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/test_utils.py", "file_name": "test_utils.py"}, "index": 8, "child_indices": [], "ref_doc_id": "e53db54622ade21e7df6c38eaab8124ceeac9497", "node_info": null}, "9": {"text": "This code file contains two tests, one for the DocumentStore class and one for the utils module. The test for the DocumentStore class tests the get_document and serialize_to_dict methods, while the test for the utils module tests the tokenizer, retry_on_exceptions_with_backoff, and retry_on_conditional_exceptions functions. The tests use pytest to check the functionality of the code and make sure that the expected results are returned.", "doc_id": null, "embedding": null, "extra_info": null, "index": 9, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"9": {"text": "This code file contains two tests, one for the DocumentStore class and one for the utils module. The test for the DocumentStore class tests the get_document and serialize_to_dict methods, while the test for the utils module tests the tokenizer, retry_on_exceptions_with_backoff, and retry_on_conditional_exceptions functions. The tests use pytest to check the functionality of the code and make sure that the expected results are returned.", "doc_id": null, "embedding": null, "extra_info": null, "index": 9, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8], "ref_doc_id": null, "node_info": null}}}, "docstore": {"docs": {"1d4640565ae2765d9ca96a509dc9809217f62f2f": {"text": "\"\"\"Init file.\"\"\"\n", "doc_id": "1d4640565ae2765d9ca96a509dc9809217f62f2f", "embedding": null, "extra_info": {"file_path": "tests/__init__.py", "file_name": "__init__.py"}, "__type__": "Document"}, "5542097578c1b4bdfd1108235f4f7c42f54f7a1c": {"text": "\"\"\"Test docstore.\"\"\"\n\nfrom typing import Dict, Type\n\nfrom gpt_index.data_structs.data_structs import IndexStruct, Node\nfrom gpt_index.docstore import DocumentStore\nfrom gpt_index.readers.schema.base import Document\n\n\ndef test_docstore() -> None:\n    \"\"\"Test docstore.\"\"\"\n    doc = Document(\"hello world\", doc_id=\"d1\", extra_info={\"foo\": \"bar\"})\n    node = Node(\"my node\", doc_id=\"d2\", node_info={\"node\": \"info\"})\n\n    type_to_struct: Dict[str, Type[IndexStruct]] = {\"node\": Node}\n\n    # test get document\n    docstore = DocumentStore.from_documents([doc, node])\n    gd1 = docstore.get_document(\"d1\")\n    assert gd1 == doc\n    gd2 = docstore.get_document(\"d2\")\n    assert gd2 == node\n\n    # test serialize/deserialize\n    doc_dict = docstore.serialize_to_dict()\n    assert doc_dict[\"docs\"] == {\n        \"d1\": {\n            \"text\": \"hello world\",\n            \"doc_id\": \"d1\",\n            \"embedding\": None,\n            \"extra_info\": {\"foo\": \"bar\"},\n            \"__type__\": \"Document\",\n        },\n        \"d2\": {\n            \"text\": \"my node\",\n            \"doc_id\": \"d2\",\n            \"embedding\": None,\n            \"extra_info\": None,\n            \"node_info\": {\"node\": \"info\"},\n            \"index\": 0,\n            \"child_indices\": [],\n            \"ref_doc_id\": None,\n            \"__type__\": \"node\",\n        },\n    }\n\n    docstore_loaded = DocumentStore.load_from_dict(doc_dict, type_to_struct)\n    assert docstore_loaded == docstore\n", "doc_id": "5542097578c1b4bdfd1108235f4f7c42f54f7a1c", "embedding": null, "extra_info": {"file_path": "tests/test_docstore.py", "file_name": "test_docstore.py"}, "__type__": "Document"}, "e53db54622ade21e7df6c38eaab8124ceeac9497": {"text": "\"\"\"Test utils.\"\"\"\n\nfrom typing import Optional, Type, Union\n\nimport pytest\n\nfrom gpt_index.utils import (\n    ErrorToRetry,\n    globals_helper,\n    retry_on_exceptions_with_backoff,\n)\n\n\ndef test_tokenizer() -> None:\n    \"\"\"Make sure tokenizer works.\n\n    NOTE: we use a different tokenizer for python >= 3.9.\n\n    \"\"\"\n    text = \"hello world foo bar\"\n    tokenizer = globals_helper.tokenizer\n    assert len(tokenizer(text)) == 4\n\n\ncall_count = 0\n\n\ndef fn_with_exception(\n    exception_cls: Optional[Union[Type[Exception], Exception]]\n) -> bool:\n    \"\"\"Return true unless exception is specified.\"\"\"\n    global call_count\n    call_count += 1\n    if exception_cls:\n        raise exception_cls\n    return True\n\n\nclass ConditionalException(Exception):\n    \"\"\"Exception that contains retry attribute.\"\"\"\n\n    def __init__(self, should_retry: bool) -> None:\n        \"\"\"Initialize with parameters.\"\"\"\n        self.should_retry = should_retry\n\n\ndef test_retry_on_exceptions_with_backoff() -> None:\n    \"\"\"Make sure retry function has accurate number of attempts.\"\"\"\n    global call_count\n    assert fn_with_exception(None)\n\n    call_count = 0\n    with pytest.raises(ValueError):\n        fn_with_exception(ValueError)\n    assert call_count == 1\n\n    call_count = 0\n    with pytest.raises(ValueError):\n        retry_on_exceptions_with_backoff(\n            lambda: fn_with_exception(ValueError),\n            [ErrorToRetry(ValueError)],\n            max_tries=3,\n            min_backoff_secs=0.0,\n        )\n    assert call_count == 3\n\n    # different exception will not get retried\n    call_count = 0\n    with pytest.raises(TypeError):\n        retry_on_exceptions_with_backoff(\n            lambda: fn_with_exception(TypeError),\n            [ErrorToRetry(ValueError)],\n            max_tries=3,\n        )\n    assert call_count == 1\n\n\ndef test_retry_on_conditional_exceptions() -> None:\n    \"\"\"Make sure retry function works on conditional exceptions.\"\"\"\n    global call_count\n    call_count = 0\n    with pytest.raises(ConditionalException):\n        retry_on_exceptions_with_backoff(\n            lambda: fn_with_exception(ConditionalException(True)),\n            [ErrorToRetry(ConditionalException, lambda e: e.should_retry)],\n            max_tries=3,\n            min_backoff_secs=0.0,\n        )\n    assert call_count == 3\n\n    call_count = 0\n    with pytest.raises(ConditionalException):\n        retry_on_exceptions_with_backoff(\n            lambda: fn_with_exception(ConditionalException(False)),\n            [ErrorToRetry(ConditionalException, lambda e: e.should_retry)],\n            max_tries=3,\n            min_backoff_secs=0.0,\n        )\n    assert call_count == 1\n", "doc_id": "e53db54622ade21e7df6c38eaab8124ceeac9497", "embedding": null, "extra_info": {"file_path": "tests/test_utils.py", "file_name": "test_utils.py"}, "__type__": "Document"}, "6f0bb870-9ed0-4704-bf47-ae057d86a020": {"text": "\nThe test_docstore.py file tests the DocumentStore class's ability to retrieve documents and serialize them into dictionaries. The test_utils.py file tests the tokenizer, retry_on_exceptions_with_backoff, and retry_on_conditional_exceptions functions of the utils module.", "doc_id": "6f0bb870-9ed0-4704-bf47-ae057d86a020", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"Init file.\"\"\"\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/__init__.py", "file_name": "__init__.py"}, "index": 0, "child_indices": [], "ref_doc_id": "1d4640565ae2765d9ca96a509dc9809217f62f2f", "node_info": null}, "1": {"text": "\"\"\"Test docstore.\"\"\"\n\nfrom typing import Dict, Type\n\nfrom gpt_index.data_structs.data_structs import IndexStruct, Node\nfrom gpt_index.docstore import DocumentStore\nfrom gpt_index.readers.schema.base import Document\n\n\ndef test_docstore() -> None:\n    \"\"\"Test docstore.\"\"\"\n    doc = Document(\"hello world\", doc_id=\"d1\", extra_info={\"foo\": \"bar\"})\n    node = Node(\"my node\", doc_id=\"d2\", node_info={\"node\": \"info\"})\n\n    type_to_struct: Dict[str, Type[IndexStruct]] = {\"node\": Node}\n\n    # test get document\n    docstore = DocumentStore.from_documents([doc, node])\n    gd1 = docstore.get_document(\"d1\")\n    assert gd1 == doc\n    gd2 = docstore.get_document(\"d2\")\n    assert gd2 == node\n\n    # test serialize/deserialize\n    doc_dict = docstore.serialize_to_dict()\n    assert", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/test_docstore.py", "file_name": "test_docstore.py"}, "index": 1, "child_indices": [], "ref_doc_id": "5542097578c1b4bdfd1108235f4f7c42f54f7a1c", "node_info": null}, "2": {"text": "= docstore.serialize_to_dict()\n    assert doc_dict[\"docs\"] == {\n        \"d1\": {\n            \"text\": \"hello world\",\n            \"doc_id\": \"d1\",\n            \"embedding\": None,\n            \"extra_info\": {\"foo\": \"bar\"},\n            \"__type__\": \"Document\",\n        },\n        \"d2\": {\n            \"text\": \"my node\",\n            \"doc_id\": \"d2\",\n            \"embedding\": None,\n            \"extra_info\": None,\n            \"node_info\": {\"node\": \"info\"},\n            \"index\": 0,\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/test_docstore.py", "file_name": "test_docstore.py"}, "index": 2, "child_indices": [], "ref_doc_id": "5542097578c1b4bdfd1108235f4f7c42f54f7a1c", "node_info": null}, "3": {"text": "0,\n            \"child_indices\": [],\n            \"ref_doc_id\": None,\n            \"__type__\": \"node\",\n        },\n    }\n\n    docstore_loaded = DocumentStore.load_from_dict(doc_dict, type_to_struct)\n    assert docstore_loaded == docstore\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/test_docstore.py", "file_name": "test_docstore.py"}, "index": 3, "child_indices": [], "ref_doc_id": "5542097578c1b4bdfd1108235f4f7c42f54f7a1c", "node_info": null}, "4": {"text": "\"\"\"Test utils.\"\"\"\n\nfrom typing import Optional, Type, Union\n\nimport pytest\n\nfrom gpt_index.utils import (\n    ErrorToRetry,\n    globals_helper,\n    retry_on_exceptions_with_backoff,\n)\n\n\ndef test_tokenizer() -> None:\n    \"\"\"Make sure tokenizer works.\n\n    NOTE: we use a different tokenizer for python >= 3.9.\n\n    \"\"\"\n    text = \"hello world foo bar\"\n    tokenizer = globals_helper.tokenizer\n    assert len(tokenizer(text)) == 4\n\n\ncall_count = 0\n\n\ndef fn_with_exception(\n    exception_cls: Optional[Union[Type[Exception], Exception]]\n) -> bool:\n    \"\"\"Return true unless exception is specified.\"\"\"\n    global call_count\n    call_count += 1\n    if exception_cls:\n        raise exception_cls\n    return True\n\n\nclass ConditionalException(Exception):\n    \"\"\"Exception that contains retry attribute.\"\"\"\n\n   ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/test_utils.py", "file_name": "test_utils.py"}, "index": 4, "child_indices": [], "ref_doc_id": "e53db54622ade21e7df6c38eaab8124ceeac9497", "node_info": null}, "5": {"text": "  \"\"\"Exception that contains retry attribute.\"\"\"\n\n    def __init__(self, should_retry: bool) -> None:\n        \"\"\"Initialize with parameters.\"\"\"\n        self.should_retry = should_retry\n\n\ndef test_retry_on_exceptions_with_backoff() -> None:\n    \"\"\"Make sure retry function has accurate number of attempts.\"\"\"\n    global call_count\n    assert fn_with_exception(None)\n\n    call_count = 0\n    with pytest.raises(ValueError):\n        fn_with_exception(ValueError)\n    assert call_count == 1\n\n    call_count = 0\n    with pytest.raises(ValueError):\n        retry_on_exceptions_with_backoff(\n            lambda: fn_with_exception(ValueError),\n            [ErrorToRetry(ValueError)],\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/test_utils.py", "file_name": "test_utils.py"}, "index": 5, "child_indices": [], "ref_doc_id": "e53db54622ade21e7df6c38eaab8124ceeac9497", "node_info": null}, "6": {"text": "           max_tries=3,\n            min_backoff_secs=0.0,\n        )\n    assert call_count == 3\n\n    # different exception will not get retried\n    call_count = 0\n    with pytest.raises(TypeError):\n        retry_on_exceptions_with_backoff(\n            lambda: fn_with_exception(TypeError),\n            [ErrorToRetry(ValueError)],\n            max_tries=3,\n        )\n    assert call_count == 1\n\n\ndef test_retry_on_conditional_exceptions() -> None:\n    \"\"\"Make sure retry function works on conditional exceptions.\"\"\"\n    global call_count\n    call_count = 0\n    with pytest.raises(ConditionalException):\n       ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/test_utils.py", "file_name": "test_utils.py"}, "index": 6, "child_indices": [], "ref_doc_id": "e53db54622ade21e7df6c38eaab8124ceeac9497", "node_info": null}, "7": {"text": "       retry_on_exceptions_with_backoff(\n            lambda: fn_with_exception(ConditionalException(True)),\n            [ErrorToRetry(ConditionalException, lambda e: e.should_retry)],\n            max_tries=3,\n            min_backoff_secs=0.0,\n        )\n    assert call_count == 3\n\n    call_count = 0\n    with pytest.raises(ConditionalException):\n        retry_on_exceptions_with_backoff(\n            lambda: fn_with_exception(ConditionalException(False)),\n            [ErrorToRetry(ConditionalException, lambda e: e.should_retry)],\n            max_tries=3,\n            min_backoff_secs=0.0,\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/test_utils.py", "file_name": "test_utils.py"}, "index": 7, "child_indices": [], "ref_doc_id": "e53db54622ade21e7df6c38eaab8124ceeac9497", "node_info": null}, "8": {"text": "   min_backoff_secs=0.0,\n        )\n    assert call_count == 1\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/test_utils.py", "file_name": "test_utils.py"}, "index": 8, "child_indices": [], "ref_doc_id": "e53db54622ade21e7df6c38eaab8124ceeac9497", "node_info": null}, "9": {"text": "This code file contains two tests, one for the DocumentStore class and one for the utils module. The test for the DocumentStore class tests the get_document and serialize_to_dict methods, while the test for the utils module tests the tokenizer, retry_on_exceptions_with_backoff, and retry_on_conditional_exceptions functions. The tests use pytest to check the functionality of the code and make sure that the expected results are returned.", "doc_id": null, "embedding": null, "extra_info": null, "index": 9, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"9": {"text": "This code file contains two tests, one for the DocumentStore class and one for the utils module. The test for the DocumentStore class tests the get_document and serialize_to_dict methods, while the test for the utils module tests the tokenizer, retry_on_exceptions_with_backoff, and retry_on_conditional_exceptions functions. The tests use pytest to check the functionality of the code and make sure that the expected results are returned.", "doc_id": null, "embedding": null, "extra_info": null, "index": 9, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8], "ref_doc_id": null, "node_info": null}}, "__type__": "tree"}}}}