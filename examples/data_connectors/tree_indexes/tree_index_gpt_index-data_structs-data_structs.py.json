{"index_struct": {"text": "\nThis code file contains data structures used to create a GPT index. It includes the IndexStruct class, which is the base data structure for a GPT index, and several other classes that extend the IndexStruct class. These classes include Node, IndexGraph, KeywordTable, IndexList, BaseIndexDict, IndexDict, and SimpleIndexDict. These classes provide data structures for three different indexing systems: Simple Dict, Weaviate, and Qdrant. Each data structure contains a class method to get the type of indexing system, as well as methods to get the class prefix or collection name, depending on the indexing system. The purpose of this code is to provide data structures for a GPT index, which can be used to store and retrieve data efficiently. The data structures are used to represent a tree-structured index, map keywords to text chunks, and store a list of documents in a dictionary.", "doc_id": "f013287b-8d23-43df-b3ec-40541fbd8556", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"File for core data structures.\"\"\"\n\nimport random\nimport sys\nfrom dataclasses import dataclass, field\nfrom typing import Any, Dict, List, Optional, Set\n\nfrom dataclasses_json import DataClassJsonMixin\n\nfrom gpt_index.schema import BaseDocument\nfrom gpt_index.utils import get_new_int_id\n\n\n@dataclass\nclass IndexStruct(BaseDocument, DataClassJsonMixin):\n    \"\"\"A base data struct for a GPT index.\"\"\"\n\n    # NOTE: the text field, inherited from BaseDocument,\n    # represents a summary of the content of the index struct.\n    # primarily used for composing indices with other indices\n\n    # NOTE: the doc_id field, inherited from BaseDocument,\n    # represents a unique identifier for the index struct\n    # that will be put in the docstore.\n    # Not all index_structs need to have a doc_id. Only index_structs that\n    # represent a complete data structure (e.g. IndexGraph, IndexList),\n    # and are used to compose a higher level index, will have a doc_id.\n\n\n@dataclass\nclass Node(IndexStruct):\n    \"\"\"A generic node of data.\n\n    Base struct used in most indices.\n\n    \"\"\"\n\n    def", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 0, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "1": {"text": "  Base struct used in most indices.\n\n    \"\"\"\n\n    def __post_init__(self) -> None:\n        \"\"\"Post init.\"\"\"\n        # NOTE: for Node objects, the text field is required\n        if self.text is None:\n            raise ValueError(\"text field not set.\")\n\n    # used for GPTTreeIndex\n    index: int = 0\n    child_indices: Set[int] = field(default_factory=set)\n\n    # embeddings\n    embedding: Optional[List[float]] = None\n\n    # reference document id\n    ref_doc_id: Optional[str] = None\n\n    # extra node info\n    node_info: Optional[Dict[str, Any]] = None\n\n    def get_text(self) -> str:\n        \"\"\"Get text.\"\"\"\n        text = super().get_text()\n        result_text = (\n            text if self.extra_info_str is None else f\"{self.extra_info_str}\\n\\n{text}\"\n        )\n        return result_text\n\n    @classmethod\n ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 1, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "2": {"text": "       return result_text\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        # TODO: consolidate with IndexStructType\n        return \"node\"\n\n\n@dataclass\nclass IndexGraph(IndexStruct):\n    \"\"\"A graph representing the tree-structured index.\"\"\"\n\n    all_nodes: Dict[int, Node] = field(default_factory=dict)\n    root_nodes: Dict[int, Node] = field(default_factory=dict)\n\n    @property\n    def size(self) -> int:\n        \"\"\"Get the size of the graph.\"\"\"\n        return len(self.all_nodes)\n\n    def get_children(self, parent_node: Optional[Node]) -> Dict[int, Node]:\n        \"\"\"Get nodes given indices.\"\"\"\n        if parent_node is None:\n            return self.root_nodes\n        else:\n            return {i: self.all_nodes[i] for i in parent_node.child_indices}\n\n    def", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 2, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "3": {"text": "for i in parent_node.child_indices}\n\n    def insert_under_parent(self, node: Node, parent_node: Optional[Node]) -> None:\n        \"\"\"Insert under parent node.\"\"\"\n        if node.index in self.all_nodes:\n            raise ValueError(\n                \"Cannot insert a new node with the same index as an existing node.\"\n            )\n        if parent_node is None:\n            self.root_nodes[node.index] = node\n        else:\n            parent_node.child_indices.add(node.index)\n\n        self.all_nodes[node.index] = node\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"tree\"\n\n\n@dataclass\nclass KeywordTable(IndexStruct):\n    \"\"\"A table of keywords mapping keywords to text chunks.\"\"\"\n\n    table: Dict[str, Set[int]] = field(default_factory=dict)\n  ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 3, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "4": {"text": "Set[int]] = field(default_factory=dict)\n    text_chunks: Dict[int, Node] = field(default_factory=dict)\n\n    def _get_index(self) -> int:\n        \"\"\"Get the next index for the text chunk.\"\"\"\n        # randomly generate until we get a unique index\n        while True:\n            idx = random.randint(0, sys.maxsize)\n            if idx not in self.text_chunks:\n                break\n        return idx\n\n    def add_node(self, keywords: List[str], node: Node) -> int:\n        \"\"\"Add text to table.\"\"\"\n        cur_idx = self._get_index()\n        for keyword in keywords:\n            if keyword not in self.table:\n                self.table[keyword] = set()\n            self.table[keyword].add(cur_idx)\n       ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 4, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "5": {"text": "       self.text_chunks[cur_idx] = node\n        return cur_idx\n\n    def get_texts(self, keyword: str) -> List[str]:\n        \"\"\"Get texts given keyword.\"\"\"\n        if keyword not in self.table:\n            raise ValueError(\"Keyword not found in table.\")\n        return [self.text_chunks[idx].get_text() for idx in self.table[keyword]]\n\n    @property\n    def keywords(self) -> Set[str]:\n        \"\"\"Get all keywords in the table.\"\"\"\n        return set(self.table.keys())\n\n    @property\n    def size(self) -> int:\n        \"\"\"Get the size of the table.\"\"\"\n        return len(self.table)\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"keyword_table\"\n\n\n@dataclass\nclass IndexList(IndexStruct):\n    \"\"\"A list of documents.\"\"\"\n\n    nodes: List[Node] =", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 5, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "6": {"text": "\"\"\"A list of documents.\"\"\"\n\n    nodes: List[Node] = field(default_factory=list)\n\n    def add_node(self, node: Node) -> None:\n        \"\"\"Add text to table, return current position in list.\"\"\"\n        # don't worry about child indices for now, nodes are all in order\n        self.nodes.append(node)\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"list\"\n\n\n@dataclass\nclass BaseIndexDict(IndexStruct):\n    \"\"\"A simple dictionary of documents.\"\"\"\n\n    nodes_dict: Dict[int, Node] = field(default_factory=dict)\n    id_map: Dict[str, int] = field(default_factory=dict)\n\n    def add_node(\n        self,\n        node: Node,\n        text_id: Optional[str] = None,\n    ) -> str:\n        \"\"\"Add text to table, return current position in list.\"\"\"\n        int_id =", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 6, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "7": {"text": "return current position in list.\"\"\"\n        int_id = get_new_int_id(set(self.nodes_dict.keys()))\n        if text_id in self.id_map:\n            raise ValueError(\"text_id cannot already exist in index.\")\n        elif text_id is not None and not isinstance(text_id, str):\n            raise ValueError(\"text_id must be a string.\")\n        elif text_id is None:\n            text_id = str(int_id)\n        self.id_map[text_id] = int_id\n\n        # don't worry about child indices for now, nodes are all in order\n        self.nodes_dict[int_id] = node\n        return text_id\n\n    def get_nodes(self, text_ids: List[str]) -> List[Node]:\n        \"\"\"Get nodes.\"\"\"\n        nodes = []\n        for text_id in text_ids:\n            if text_id not in", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 7, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "8": {"text": "           if text_id not in self.id_map:\n                raise ValueError(\"text_id not found in id_map\")\n            elif not isinstance(text_id, str):\n                raise ValueError(\"text_id must be a string.\")\n            int_id = self.id_map[text_id]\n            if int_id not in self.nodes_dict:\n                raise ValueError(\"int_id not found in nodes_dict\")\n            nodes.append(self.nodes_dict[int_id])\n        return nodes\n\n    def get_node(self, text_id: str) -> Node:\n        \"\"\"Get node.\"\"\"\n        return self.get_nodes([text_id])[0]\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"dict\"\n\n\n# TODO: this should be specific to", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 8, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "9": {"text": "    return \"dict\"\n\n\n# TODO: this should be specific to FAISS\n@dataclass\nclass IndexDict(BaseIndexDict):\n    \"\"\"A dictionary of documents.\n\n    Note: this index structure is specifically used with the Faiss index.\n\n    \"\"\"\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"dict\"\n\n\n@dataclass\nclass SimpleIndexDict(BaseIndexDict):\n    \"\"\"A simple dictionary of documents.\n\n    This index structure also contains an internal in-memory\n    embedding dict.\n\n    \"\"\"\n\n    embedding_dict: Dict[str, List[float]] = field(default_factory=dict)\n\n    def add_to_embedding_dict(self, text_id: str, embedding: List[float]) -> None:\n        \"\"\"Add embedding to dict.\"\"\"\n        if text_id not in self.id_map:\n            raise ValueError(\"text_id not found in id_map\")\n        elif not isinstance(text_id, str):\n            raise ValueError(\"text_id must", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 9, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "10": {"text": "           raise ValueError(\"text_id must be a string.\")\n        self.embedding_dict[text_id] = embedding\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"simple_dict\"\n\n\n@dataclass\nclass WeaviateIndexStruct(IndexStruct):\n    \"\"\"A helper index struct for Weaviate.\n\n    In Weaviate, docs are stored in Weaviate directly.\n    This index struct helps to store the class prefix\n\n    \"\"\"\n\n    class_prefix: Optional[str] = None\n\n    def __post_init__(self) -> None:\n        \"\"\"Post init.\"\"\"\n        if self.class_prefix is None:\n            raise ValueError(\"class_prefix must be provided.\")\n\n    def get_class_prefix(self) -> str:\n        \"\"\"Get class prefix.\"\"\"\n        if self.class_prefix is None:\n            raise ValueError(\"class_prefix must be provided.\")\n        return self.class_prefix\n\n    @classmethod\n    def", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 10, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "11": {"text": "  return self.class_prefix\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"weaviate\"\n\n\n@dataclass\nclass PineconeIndexStruct(IndexStruct):\n    \"\"\"An index struct for Pinecone.\n\n    Docs are stored in Pinecone directly.\n\n    \"\"\"\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"pinecone\"\n\n\n@dataclass\nclass QdrantIndexStruct(IndexStruct):\n    \"\"\"And index struct for Qdrant.\n\n    Docs are stored in Qdrant directly.\n    This index struct helps to store the collection name\n\n    \"\"\"\n\n    collection_name: Optional[str] = None\n\n    def __post_init__(self) -> None:\n        \"\"\"Post init.\"\"\"\n        if self.collection_name is None:\n            raise ValueError(\"collection_name must be provided.\")\n\n    def get_collection_name(self) -> str:\n        \"\"\"Get class prefix.\"\"\"\n        if", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 11, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "12": {"text": "     \"\"\"Get class prefix.\"\"\"\n        if self.collection_name is None:\n            raise ValueError(\"collection_name must be provided.\")\n        return self.collection_name\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"qdrant\"\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 12, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "13": {"text": "This code file contains data structures used in a GPT index. It includes IndexStruct, Node, IndexGraph, KeywordTable, IndexList, BaseIndexDict, IndexDict, and SimpleIndexDict. IndexStruct is a base data structure for a GPT index, and Node is a generic node of data used in most indices. IndexGraph is a graph representing the tree-structured index, KeywordTable is a table of keywords mapping keywords to text chunks, IndexList is a list of documents, BaseIndexDict is a simple dictionary of documents, IndexDict is a dictionary of documents specifically used with the Faiss index, and SimpleIndexDict is a simple dictionary of documents that also contains an internal in-memory embedding dict. The purpose of this code is to provide data structures for a GPT index.", "doc_id": null, "embedding": null, "extra_info": null, "index": 13, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "ref_doc_id": null, "node_info": null}, "14": {"text": "This code file contains data structures for three different indexing systems: Simple Dict, Weaviate, and Qdrant. Each data structure contains a class method to get the type of indexing system, as well as methods to get the class prefix or collection name, depending on the indexing system. The Simple Dict data structure stores embeddings in a dictionary, while the Weaviate and Qdrant data structures store documents directly in the respective systems.", "doc_id": null, "embedding": null, "extra_info": null, "index": 14, "child_indices": [10, 11, 12], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"13": {"text": "This code file contains data structures used in a GPT index. It includes IndexStruct, Node, IndexGraph, KeywordTable, IndexList, BaseIndexDict, IndexDict, and SimpleIndexDict. IndexStruct is a base data structure for a GPT index, and Node is a generic node of data used in most indices. IndexGraph is a graph representing the tree-structured index, KeywordTable is a table of keywords mapping keywords to text chunks, IndexList is a list of documents, BaseIndexDict is a simple dictionary of documents, IndexDict is a dictionary of documents specifically used with the Faiss index, and SimpleIndexDict is a simple dictionary of documents that also contains an internal in-memory embedding dict. The purpose of this code is to provide data structures for a GPT index.", "doc_id": null, "embedding": null, "extra_info": null, "index": 13, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "ref_doc_id": null, "node_info": null}, "14": {"text": "This code file contains data structures for three different indexing systems: Simple Dict, Weaviate, and Qdrant. Each data structure contains a class method to get the type of indexing system, as well as methods to get the class prefix or collection name, depending on the indexing system. The Simple Dict data structure stores embeddings in a dictionary, while the Weaviate and Qdrant data structures store documents directly in the respective systems.", "doc_id": null, "embedding": null, "extra_info": null, "index": 14, "child_indices": [10, 11, 12], "ref_doc_id": null, "node_info": null}}}, "docstore": {"docs": {"bb6752a483b33b4ef24085d9f0c7fc696de3a9fe": {"text": "\"\"\"File for core data structures.\"\"\"\n\nimport random\nimport sys\nfrom dataclasses import dataclass, field\nfrom typing import Any, Dict, List, Optional, Set\n\nfrom dataclasses_json import DataClassJsonMixin\n\nfrom gpt_index.schema import BaseDocument\nfrom gpt_index.utils import get_new_int_id\n\n\n@dataclass\nclass IndexStruct(BaseDocument, DataClassJsonMixin):\n    \"\"\"A base data struct for a GPT index.\"\"\"\n\n    # NOTE: the text field, inherited from BaseDocument,\n    # represents a summary of the content of the index struct.\n    # primarily used for composing indices with other indices\n\n    # NOTE: the doc_id field, inherited from BaseDocument,\n    # represents a unique identifier for the index struct\n    # that will be put in the docstore.\n    # Not all index_structs need to have a doc_id. Only index_structs that\n    # represent a complete data structure (e.g. IndexGraph, IndexList),\n    # and are used to compose a higher level index, will have a doc_id.\n\n\n@dataclass\nclass Node(IndexStruct):\n    \"\"\"A generic node of data.\n\n    Base struct used in most indices.\n\n    \"\"\"\n\n    def __post_init__(self) -> None:\n        \"\"\"Post init.\"\"\"\n        # NOTE: for Node objects, the text field is required\n        if self.text is None:\n            raise ValueError(\"text field not set.\")\n\n    # used for GPTTreeIndex\n    index: int = 0\n    child_indices: Set[int] = field(default_factory=set)\n\n    # embeddings\n    embedding: Optional[List[float]] = None\n\n    # reference document id\n    ref_doc_id: Optional[str] = None\n\n    # extra node info\n    node_info: Optional[Dict[str, Any]] = None\n\n    def get_text(self) -> str:\n        \"\"\"Get text.\"\"\"\n        text = super().get_text()\n        result_text = (\n            text if self.extra_info_str is None else f\"{self.extra_info_str}\\n\\n{text}\"\n        )\n        return result_text\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        # TODO: consolidate with IndexStructType\n        return \"node\"\n\n\n@dataclass\nclass IndexGraph(IndexStruct):\n    \"\"\"A graph representing the tree-structured index.\"\"\"\n\n    all_nodes: Dict[int, Node] = field(default_factory=dict)\n    root_nodes: Dict[int, Node] = field(default_factory=dict)\n\n    @property\n    def size(self) -> int:\n        \"\"\"Get the size of the graph.\"\"\"\n        return len(self.all_nodes)\n\n    def get_children(self, parent_node: Optional[Node]) -> Dict[int, Node]:\n        \"\"\"Get nodes given indices.\"\"\"\n        if parent_node is None:\n            return self.root_nodes\n        else:\n            return {i: self.all_nodes[i] for i in parent_node.child_indices}\n\n    def insert_under_parent(self, node: Node, parent_node: Optional[Node]) -> None:\n        \"\"\"Insert under parent node.\"\"\"\n        if node.index in self.all_nodes:\n            raise ValueError(\n                \"Cannot insert a new node with the same index as an existing node.\"\n            )\n        if parent_node is None:\n            self.root_nodes[node.index] = node\n        else:\n            parent_node.child_indices.add(node.index)\n\n        self.all_nodes[node.index] = node\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"tree\"\n\n\n@dataclass\nclass KeywordTable(IndexStruct):\n    \"\"\"A table of keywords mapping keywords to text chunks.\"\"\"\n\n    table: Dict[str, Set[int]] = field(default_factory=dict)\n    text_chunks: Dict[int, Node] = field(default_factory=dict)\n\n    def _get_index(self) -> int:\n        \"\"\"Get the next index for the text chunk.\"\"\"\n        # randomly generate until we get a unique index\n        while True:\n            idx = random.randint(0, sys.maxsize)\n            if idx not in self.text_chunks:\n                break\n        return idx\n\n    def add_node(self, keywords: List[str], node: Node) -> int:\n        \"\"\"Add text to table.\"\"\"\n        cur_idx = self._get_index()\n        for keyword in keywords:\n            if keyword not in self.table:\n                self.table[keyword] = set()\n            self.table[keyword].add(cur_idx)\n        self.text_chunks[cur_idx] = node\n        return cur_idx\n\n    def get_texts(self, keyword: str) -> List[str]:\n        \"\"\"Get texts given keyword.\"\"\"\n        if keyword not in self.table:\n            raise ValueError(\"Keyword not found in table.\")\n        return [self.text_chunks[idx].get_text() for idx in self.table[keyword]]\n\n    @property\n    def keywords(self) -> Set[str]:\n        \"\"\"Get all keywords in the table.\"\"\"\n        return set(self.table.keys())\n\n    @property\n    def size(self) -> int:\n        \"\"\"Get the size of the table.\"\"\"\n        return len(self.table)\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"keyword_table\"\n\n\n@dataclass\nclass IndexList(IndexStruct):\n    \"\"\"A list of documents.\"\"\"\n\n    nodes: List[Node] = field(default_factory=list)\n\n    def add_node(self, node: Node) -> None:\n        \"\"\"Add text to table, return current position in list.\"\"\"\n        # don't worry about child indices for now, nodes are all in order\n        self.nodes.append(node)\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"list\"\n\n\n@dataclass\nclass BaseIndexDict(IndexStruct):\n    \"\"\"A simple dictionary of documents.\"\"\"\n\n    nodes_dict: Dict[int, Node] = field(default_factory=dict)\n    id_map: Dict[str, int] = field(default_factory=dict)\n\n    def add_node(\n        self,\n        node: Node,\n        text_id: Optional[str] = None,\n    ) -> str:\n        \"\"\"Add text to table, return current position in list.\"\"\"\n        int_id = get_new_int_id(set(self.nodes_dict.keys()))\n        if text_id in self.id_map:\n            raise ValueError(\"text_id cannot already exist in index.\")\n        elif text_id is not None and not isinstance(text_id, str):\n            raise ValueError(\"text_id must be a string.\")\n        elif text_id is None:\n            text_id = str(int_id)\n        self.id_map[text_id] = int_id\n\n        # don't worry about child indices for now, nodes are all in order\n        self.nodes_dict[int_id] = node\n        return text_id\n\n    def get_nodes(self, text_ids: List[str]) -> List[Node]:\n        \"\"\"Get nodes.\"\"\"\n        nodes = []\n        for text_id in text_ids:\n            if text_id not in self.id_map:\n                raise ValueError(\"text_id not found in id_map\")\n            elif not isinstance(text_id, str):\n                raise ValueError(\"text_id must be a string.\")\n            int_id = self.id_map[text_id]\n            if int_id not in self.nodes_dict:\n                raise ValueError(\"int_id not found in nodes_dict\")\n            nodes.append(self.nodes_dict[int_id])\n        return nodes\n\n    def get_node(self, text_id: str) -> Node:\n        \"\"\"Get node.\"\"\"\n        return self.get_nodes([text_id])[0]\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"dict\"\n\n\n# TODO: this should be specific to FAISS\n@dataclass\nclass IndexDict(BaseIndexDict):\n    \"\"\"A dictionary of documents.\n\n    Note: this index structure is specifically used with the Faiss index.\n\n    \"\"\"\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"dict\"\n\n\n@dataclass\nclass SimpleIndexDict(BaseIndexDict):\n    \"\"\"A simple dictionary of documents.\n\n    This index structure also contains an internal in-memory\n    embedding dict.\n\n    \"\"\"\n\n    embedding_dict: Dict[str, List[float]] = field(default_factory=dict)\n\n    def add_to_embedding_dict(self, text_id: str, embedding: List[float]) -> None:\n        \"\"\"Add embedding to dict.\"\"\"\n        if text_id not in self.id_map:\n            raise ValueError(\"text_id not found in id_map\")\n        elif not isinstance(text_id, str):\n            raise ValueError(\"text_id must be a string.\")\n        self.embedding_dict[text_id] = embedding\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"simple_dict\"\n\n\n@dataclass\nclass WeaviateIndexStruct(IndexStruct):\n    \"\"\"A helper index struct for Weaviate.\n\n    In Weaviate, docs are stored in Weaviate directly.\n    This index struct helps to store the class prefix\n\n    \"\"\"\n\n    class_prefix: Optional[str] = None\n\n    def __post_init__(self) -> None:\n        \"\"\"Post init.\"\"\"\n        if self.class_prefix is None:\n            raise ValueError(\"class_prefix must be provided.\")\n\n    def get_class_prefix(self) -> str:\n        \"\"\"Get class prefix.\"\"\"\n        if self.class_prefix is None:\n            raise ValueError(\"class_prefix must be provided.\")\n        return self.class_prefix\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"weaviate\"\n\n\n@dataclass\nclass PineconeIndexStruct(IndexStruct):\n    \"\"\"An index struct for Pinecone.\n\n    Docs are stored in Pinecone directly.\n\n    \"\"\"\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"pinecone\"\n\n\n@dataclass\nclass QdrantIndexStruct(IndexStruct):\n    \"\"\"And index struct for Qdrant.\n\n    Docs are stored in Qdrant directly.\n    This index struct helps to store the collection name\n\n    \"\"\"\n\n    collection_name: Optional[str] = None\n\n    def __post_init__(self) -> None:\n        \"\"\"Post init.\"\"\"\n        if self.collection_name is None:\n            raise ValueError(\"collection_name must be provided.\")\n\n    def get_collection_name(self) -> str:\n        \"\"\"Get class prefix.\"\"\"\n        if self.collection_name is None:\n            raise ValueError(\"collection_name must be provided.\")\n        return self.collection_name\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"qdrant\"\n", "doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "__type__": "Document"}, "f013287b-8d23-43df-b3ec-40541fbd8556": {"text": "\nThis code file contains data structures used to create a GPT index. It includes the IndexStruct class, which is the base data structure for a GPT index, and several other classes that extend the IndexStruct class. These classes include Node, IndexGraph, KeywordTable, IndexList, BaseIndexDict, IndexDict, and SimpleIndexDict. These classes provide data structures for three different indexing systems: Simple Dict, Weaviate, and Qdrant. Each data structure contains a class method to get the type of indexing system, as well as methods to get the class prefix or collection name, depending on the indexing system. The purpose of this code is to provide data structures for a GPT index, which can be used to store and retrieve data efficiently. The data structures are used to represent a tree-structured index, map keywords to text chunks, and store a list of documents in a dictionary.", "doc_id": "f013287b-8d23-43df-b3ec-40541fbd8556", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"File for core data structures.\"\"\"\n\nimport random\nimport sys\nfrom dataclasses import dataclass, field\nfrom typing import Any, Dict, List, Optional, Set\n\nfrom dataclasses_json import DataClassJsonMixin\n\nfrom gpt_index.schema import BaseDocument\nfrom gpt_index.utils import get_new_int_id\n\n\n@dataclass\nclass IndexStruct(BaseDocument, DataClassJsonMixin):\n    \"\"\"A base data struct for a GPT index.\"\"\"\n\n    # NOTE: the text field, inherited from BaseDocument,\n    # represents a summary of the content of the index struct.\n    # primarily used for composing indices with other indices\n\n    # NOTE: the doc_id field, inherited from BaseDocument,\n    # represents a unique identifier for the index struct\n    # that will be put in the docstore.\n    # Not all index_structs need to have a doc_id. Only index_structs that\n    # represent a complete data structure (e.g. IndexGraph, IndexList),\n    # and are used to compose a higher level index, will have a doc_id.\n\n\n@dataclass\nclass Node(IndexStruct):\n    \"\"\"A generic node of data.\n\n    Base struct used in most indices.\n\n    \"\"\"\n\n    def", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 0, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "1": {"text": "  Base struct used in most indices.\n\n    \"\"\"\n\n    def __post_init__(self) -> None:\n        \"\"\"Post init.\"\"\"\n        # NOTE: for Node objects, the text field is required\n        if self.text is None:\n            raise ValueError(\"text field not set.\")\n\n    # used for GPTTreeIndex\n    index: int = 0\n    child_indices: Set[int] = field(default_factory=set)\n\n    # embeddings\n    embedding: Optional[List[float]] = None\n\n    # reference document id\n    ref_doc_id: Optional[str] = None\n\n    # extra node info\n    node_info: Optional[Dict[str, Any]] = None\n\n    def get_text(self) -> str:\n        \"\"\"Get text.\"\"\"\n        text = super().get_text()\n        result_text = (\n            text if self.extra_info_str is None else f\"{self.extra_info_str}\\n\\n{text}\"\n        )\n        return result_text\n\n    @classmethod\n ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 1, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "2": {"text": "       return result_text\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        # TODO: consolidate with IndexStructType\n        return \"node\"\n\n\n@dataclass\nclass IndexGraph(IndexStruct):\n    \"\"\"A graph representing the tree-structured index.\"\"\"\n\n    all_nodes: Dict[int, Node] = field(default_factory=dict)\n    root_nodes: Dict[int, Node] = field(default_factory=dict)\n\n    @property\n    def size(self) -> int:\n        \"\"\"Get the size of the graph.\"\"\"\n        return len(self.all_nodes)\n\n    def get_children(self, parent_node: Optional[Node]) -> Dict[int, Node]:\n        \"\"\"Get nodes given indices.\"\"\"\n        if parent_node is None:\n            return self.root_nodes\n        else:\n            return {i: self.all_nodes[i] for i in parent_node.child_indices}\n\n    def", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 2, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "3": {"text": "for i in parent_node.child_indices}\n\n    def insert_under_parent(self, node: Node, parent_node: Optional[Node]) -> None:\n        \"\"\"Insert under parent node.\"\"\"\n        if node.index in self.all_nodes:\n            raise ValueError(\n                \"Cannot insert a new node with the same index as an existing node.\"\n            )\n        if parent_node is None:\n            self.root_nodes[node.index] = node\n        else:\n            parent_node.child_indices.add(node.index)\n\n        self.all_nodes[node.index] = node\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"tree\"\n\n\n@dataclass\nclass KeywordTable(IndexStruct):\n    \"\"\"A table of keywords mapping keywords to text chunks.\"\"\"\n\n    table: Dict[str, Set[int]] = field(default_factory=dict)\n  ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 3, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "4": {"text": "Set[int]] = field(default_factory=dict)\n    text_chunks: Dict[int, Node] = field(default_factory=dict)\n\n    def _get_index(self) -> int:\n        \"\"\"Get the next index for the text chunk.\"\"\"\n        # randomly generate until we get a unique index\n        while True:\n            idx = random.randint(0, sys.maxsize)\n            if idx not in self.text_chunks:\n                break\n        return idx\n\n    def add_node(self, keywords: List[str], node: Node) -> int:\n        \"\"\"Add text to table.\"\"\"\n        cur_idx = self._get_index()\n        for keyword in keywords:\n            if keyword not in self.table:\n                self.table[keyword] = set()\n            self.table[keyword].add(cur_idx)\n       ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 4, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "5": {"text": "       self.text_chunks[cur_idx] = node\n        return cur_idx\n\n    def get_texts(self, keyword: str) -> List[str]:\n        \"\"\"Get texts given keyword.\"\"\"\n        if keyword not in self.table:\n            raise ValueError(\"Keyword not found in table.\")\n        return [self.text_chunks[idx].get_text() for idx in self.table[keyword]]\n\n    @property\n    def keywords(self) -> Set[str]:\n        \"\"\"Get all keywords in the table.\"\"\"\n        return set(self.table.keys())\n\n    @property\n    def size(self) -> int:\n        \"\"\"Get the size of the table.\"\"\"\n        return len(self.table)\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"keyword_table\"\n\n\n@dataclass\nclass IndexList(IndexStruct):\n    \"\"\"A list of documents.\"\"\"\n\n    nodes: List[Node] =", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 5, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "6": {"text": "\"\"\"A list of documents.\"\"\"\n\n    nodes: List[Node] = field(default_factory=list)\n\n    def add_node(self, node: Node) -> None:\n        \"\"\"Add text to table, return current position in list.\"\"\"\n        # don't worry about child indices for now, nodes are all in order\n        self.nodes.append(node)\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"list\"\n\n\n@dataclass\nclass BaseIndexDict(IndexStruct):\n    \"\"\"A simple dictionary of documents.\"\"\"\n\n    nodes_dict: Dict[int, Node] = field(default_factory=dict)\n    id_map: Dict[str, int] = field(default_factory=dict)\n\n    def add_node(\n        self,\n        node: Node,\n        text_id: Optional[str] = None,\n    ) -> str:\n        \"\"\"Add text to table, return current position in list.\"\"\"\n        int_id =", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 6, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "7": {"text": "return current position in list.\"\"\"\n        int_id = get_new_int_id(set(self.nodes_dict.keys()))\n        if text_id in self.id_map:\n            raise ValueError(\"text_id cannot already exist in index.\")\n        elif text_id is not None and not isinstance(text_id, str):\n            raise ValueError(\"text_id must be a string.\")\n        elif text_id is None:\n            text_id = str(int_id)\n        self.id_map[text_id] = int_id\n\n        # don't worry about child indices for now, nodes are all in order\n        self.nodes_dict[int_id] = node\n        return text_id\n\n    def get_nodes(self, text_ids: List[str]) -> List[Node]:\n        \"\"\"Get nodes.\"\"\"\n        nodes = []\n        for text_id in text_ids:\n            if text_id not in", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 7, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "8": {"text": "           if text_id not in self.id_map:\n                raise ValueError(\"text_id not found in id_map\")\n            elif not isinstance(text_id, str):\n                raise ValueError(\"text_id must be a string.\")\n            int_id = self.id_map[text_id]\n            if int_id not in self.nodes_dict:\n                raise ValueError(\"int_id not found in nodes_dict\")\n            nodes.append(self.nodes_dict[int_id])\n        return nodes\n\n    def get_node(self, text_id: str) -> Node:\n        \"\"\"Get node.\"\"\"\n        return self.get_nodes([text_id])[0]\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"dict\"\n\n\n# TODO: this should be specific to", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 8, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "9": {"text": "    return \"dict\"\n\n\n# TODO: this should be specific to FAISS\n@dataclass\nclass IndexDict(BaseIndexDict):\n    \"\"\"A dictionary of documents.\n\n    Note: this index structure is specifically used with the Faiss index.\n\n    \"\"\"\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"dict\"\n\n\n@dataclass\nclass SimpleIndexDict(BaseIndexDict):\n    \"\"\"A simple dictionary of documents.\n\n    This index structure also contains an internal in-memory\n    embedding dict.\n\n    \"\"\"\n\n    embedding_dict: Dict[str, List[float]] = field(default_factory=dict)\n\n    def add_to_embedding_dict(self, text_id: str, embedding: List[float]) -> None:\n        \"\"\"Add embedding to dict.\"\"\"\n        if text_id not in self.id_map:\n            raise ValueError(\"text_id not found in id_map\")\n        elif not isinstance(text_id, str):\n            raise ValueError(\"text_id must", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 9, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "10": {"text": "           raise ValueError(\"text_id must be a string.\")\n        self.embedding_dict[text_id] = embedding\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"simple_dict\"\n\n\n@dataclass\nclass WeaviateIndexStruct(IndexStruct):\n    \"\"\"A helper index struct for Weaviate.\n\n    In Weaviate, docs are stored in Weaviate directly.\n    This index struct helps to store the class prefix\n\n    \"\"\"\n\n    class_prefix: Optional[str] = None\n\n    def __post_init__(self) -> None:\n        \"\"\"Post init.\"\"\"\n        if self.class_prefix is None:\n            raise ValueError(\"class_prefix must be provided.\")\n\n    def get_class_prefix(self) -> str:\n        \"\"\"Get class prefix.\"\"\"\n        if self.class_prefix is None:\n            raise ValueError(\"class_prefix must be provided.\")\n        return self.class_prefix\n\n    @classmethod\n    def", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 10, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "11": {"text": "  return self.class_prefix\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"weaviate\"\n\n\n@dataclass\nclass PineconeIndexStruct(IndexStruct):\n    \"\"\"An index struct for Pinecone.\n\n    Docs are stored in Pinecone directly.\n\n    \"\"\"\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"pinecone\"\n\n\n@dataclass\nclass QdrantIndexStruct(IndexStruct):\n    \"\"\"And index struct for Qdrant.\n\n    Docs are stored in Qdrant directly.\n    This index struct helps to store the collection name\n\n    \"\"\"\n\n    collection_name: Optional[str] = None\n\n    def __post_init__(self) -> None:\n        \"\"\"Post init.\"\"\"\n        if self.collection_name is None:\n            raise ValueError(\"collection_name must be provided.\")\n\n    def get_collection_name(self) -> str:\n        \"\"\"Get class prefix.\"\"\"\n        if", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 11, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "12": {"text": "     \"\"\"Get class prefix.\"\"\"\n        if self.collection_name is None:\n            raise ValueError(\"collection_name must be provided.\")\n        return self.collection_name\n\n    @classmethod\n    def get_type(cls) -> str:\n        \"\"\"Get type.\"\"\"\n        return \"qdrant\"\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/data_structs/data_structs.py", "file_name": "data_structs.py"}, "index": 12, "child_indices": [], "ref_doc_id": "bb6752a483b33b4ef24085d9f0c7fc696de3a9fe", "node_info": null}, "13": {"text": "This code file contains data structures used in a GPT index. It includes IndexStruct, Node, IndexGraph, KeywordTable, IndexList, BaseIndexDict, IndexDict, and SimpleIndexDict. IndexStruct is a base data structure for a GPT index, and Node is a generic node of data used in most indices. IndexGraph is a graph representing the tree-structured index, KeywordTable is a table of keywords mapping keywords to text chunks, IndexList is a list of documents, BaseIndexDict is a simple dictionary of documents, IndexDict is a dictionary of documents specifically used with the Faiss index, and SimpleIndexDict is a simple dictionary of documents that also contains an internal in-memory embedding dict. The purpose of this code is to provide data structures for a GPT index.", "doc_id": null, "embedding": null, "extra_info": null, "index": 13, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "ref_doc_id": null, "node_info": null}, "14": {"text": "This code file contains data structures for three different indexing systems: Simple Dict, Weaviate, and Qdrant. Each data structure contains a class method to get the type of indexing system, as well as methods to get the class prefix or collection name, depending on the indexing system. The Simple Dict data structure stores embeddings in a dictionary, while the Weaviate and Qdrant data structures store documents directly in the respective systems.", "doc_id": null, "embedding": null, "extra_info": null, "index": 14, "child_indices": [10, 11, 12], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"13": {"text": "This code file contains data structures used in a GPT index. It includes IndexStruct, Node, IndexGraph, KeywordTable, IndexList, BaseIndexDict, IndexDict, and SimpleIndexDict. IndexStruct is a base data structure for a GPT index, and Node is a generic node of data used in most indices. IndexGraph is a graph representing the tree-structured index, KeywordTable is a table of keywords mapping keywords to text chunks, IndexList is a list of documents, BaseIndexDict is a simple dictionary of documents, IndexDict is a dictionary of documents specifically used with the Faiss index, and SimpleIndexDict is a simple dictionary of documents that also contains an internal in-memory embedding dict. The purpose of this code is to provide data structures for a GPT index.", "doc_id": null, "embedding": null, "extra_info": null, "index": 13, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "ref_doc_id": null, "node_info": null}, "14": {"text": "This code file contains data structures for three different indexing systems: Simple Dict, Weaviate, and Qdrant. Each data structure contains a class method to get the type of indexing system, as well as methods to get the class prefix or collection name, depending on the indexing system. The Simple Dict data structure stores embeddings in a dictionary, while the Weaviate and Qdrant data structures store documents directly in the respective systems.", "doc_id": null, "embedding": null, "extra_info": null, "index": 14, "child_indices": [10, 11, 12], "ref_doc_id": null, "node_info": null}}, "__type__": "tree"}}}}