{"index_struct": {"text": "\nThe docstore.py file contains the DocumentStore class, which provides a way to store documents of different types and access them easily. It uses the DataClassJsonMixin to serialize documents to a dictionary and the IndexStruct class to store documents. The DocumentStore class has methods to serialize documents to a dictionary, check if it contains an IndexStruct, load documents from a dictionary, add documents, get a new ID, update the store, get a document, check if a document exists, delete a document, and get the length of the store. The TYPE_KEY constant is used to store the type of document. The purpose of the code is to provide an efficient way to store and access documents of different types.", "doc_id": "4bb47f6b-2c70-42ce-9233-0137340dd2de", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"Document store.\"\"\"\n\nfrom dataclasses import dataclass, field\nfrom typing import Any, Dict, List, Optional, Type, Union\n\nfrom dataclasses_json import DataClassJsonMixin\n\nfrom gpt_index.data_structs.data_structs import IndexStruct\nfrom gpt_index.readers.schema.base import Document\nfrom gpt_index.utils import get_new_id\n\nDOC_TYPE = Union[IndexStruct, Document]\n\n# type key: used to store type of document\nTYPE_KEY = \"__type__\"\n\n\n@dataclass\nclass DocumentStore(DataClassJsonMixin):\n    \"\"\"Document store.\"\"\"\n\n    docs: Dict[str, DOC_TYPE] = field(default_factory=dict)\n\n    def serialize_to_dict(self) -> Dict[str, Any]:\n        \"\"\"Serialize to dict.\"\"\"\n        docs_dict = {}\n        for doc_id, doc in self.docs.items():\n            doc_dict = doc.to_dict()\n            doc_dict[TYPE_KEY] = doc.get_type()\n            docs_dict[doc_id] = doc_dict\n        return {\"docs\": docs_dict}\n\n    def", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/docstore.py", "file_name": "docstore.py"}, "index": 0, "child_indices": [], "ref_doc_id": "523dc2d189441cf16be18c8f3896fae904dc3473", "node_info": null}, "1": {"text": "       return {\"docs\": docs_dict}\n\n    def contains_index_struct(self, exclude_ids: Optional[List[str]] = None) -> bool:\n        \"\"\"Check if contains index struct.\"\"\"\n        exclude_ids = exclude_ids or []\n        for doc in self.docs.values():\n            if isinstance(doc, IndexStruct) and doc.get_doc_id() not in exclude_ids:\n                return True\n        return False\n\n    @classmethod\n    def load_from_dict(\n        cls,\n        docs_dict: Dict[str, Any],\n        type_to_struct: Optional[Dict[str, Type[IndexStruct]]] = None,\n    ) -> \"DocumentStore\":\n        \"\"\"Load from dict.\"\"\"\n        docs_obj_dict = {}\n        for doc_id, doc_dict in docs_dict[\"docs\"].items():\n            doc_type = doc_dict.pop(TYPE_KEY, None)\n            if doc_type ==", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/docstore.py", "file_name": "docstore.py"}, "index": 1, "child_indices": [], "ref_doc_id": "523dc2d189441cf16be18c8f3896fae904dc3473", "node_info": null}, "2": {"text": "None)\n            if doc_type == \"Document\" or doc_type is None:\n                doc: DOC_TYPE = Document.from_dict(doc_dict)\n            else:\n                if type_to_struct is None:\n                    raise ValueError(\n                        \"type_to_struct must be provided if type is index struct.\"\n                    )\n                # try using IndexStructType to retrieve documents\n                if doc_type not in type_to_struct:\n                    raise ValueError(\n                        f\"doc_type {doc_type} not found in type_to_struct. \"\n                        \"Make sure that it was registered in the index registry.\"\n        ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/docstore.py", "file_name": "docstore.py"}, "index": 2, "child_indices": [], "ref_doc_id": "523dc2d189441cf16be18c8f3896fae904dc3473", "node_info": null}, "3": {"text": "sure that it was registered in the index registry.\"\n                    )\n                doc = type_to_struct[doc_type].from_dict(doc_dict)\n                # doc = index_struct_cls.from_dict(doc_dict)\n            docs_obj_dict[doc_id] = doc\n        return cls(docs=docs_obj_dict)\n\n    @classmethod\n    def from_documents(cls, docs: List[DOC_TYPE]) -> \"DocumentStore\":\n        \"\"\"Create from documents.\"\"\"\n        obj = cls()\n        obj.add_documents(docs)\n        return obj\n\n    def get_new_id(self) -> str:\n        \"\"\"Get a new ID.\"\"\"\n        return get_new_id(set(self.docs.keys()))\n\n    def update_docstore(self, other: \"DocumentStore\") -> None:\n        \"\"\"Update docstore.\"\"\"\n        self.docs.update(other.docs)\n\n    def", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/docstore.py", "file_name": "docstore.py"}, "index": 3, "child_indices": [], "ref_doc_id": "523dc2d189441cf16be18c8f3896fae904dc3473", "node_info": null}, "4": {"text": "     self.docs.update(other.docs)\n\n    def add_documents(self, docs: List[DOC_TYPE], generate_id: bool = True) -> None:\n        \"\"\"Add a document to the store.\n\n        If generate_id = True, then generate id for doc if doc_id doesn't exist.\n\n        \"\"\"\n        for doc in docs:\n            if doc.is_doc_id_none:\n                if generate_id:\n                    doc.doc_id = self.get_new_id()\n                else:\n                    raise ValueError(\n                        \"doc_id not set (to generate id, please set generate_id=True).\"\n                    )\n\n            # NOTE: doc could already exist in the store, but we overwrite it\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/docstore.py", "file_name": "docstore.py"}, "index": 4, "child_indices": [], "ref_doc_id": "523dc2d189441cf16be18c8f3896fae904dc3473", "node_info": null}, "5": {"text": "the store, but we overwrite it\n            self.docs[doc.get_doc_id()] = doc\n\n    def get_document(self, doc_id: str, raise_error: bool = True) -> Optional[DOC_TYPE]:\n        \"\"\"Get a document from the store.\"\"\"\n        doc = self.docs.get(doc_id, None)\n        if doc is None and raise_error:\n            raise ValueError(f\"doc_id {doc_id} not found.\")\n        return doc\n\n    def document_exists(self, doc_id: str) -> bool:\n        \"\"\"Check if document exists.\"\"\"\n        return doc_id in self.docs\n\n    def delete_document(\n        self, doc_id: str, raise_error: bool = True\n    ) -> Optional[DOC_TYPE]:\n        \"\"\"Delete a document from the store.\"\"\"\n        doc = self.docs.pop(doc_id, None)\n        if doc is None and raise_error:\n            raise ValueError(f\"doc_id {doc_id} not found.\")\n        return", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/docstore.py", "file_name": "docstore.py"}, "index": 5, "child_indices": [], "ref_doc_id": "523dc2d189441cf16be18c8f3896fae904dc3473", "node_info": null}, "6": {"text": "{doc_id} not found.\")\n        return doc\n\n    def __len__(self) -> int:\n        \"\"\"Get length.\"\"\"\n        return len(self.docs.keys())\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/docstore.py", "file_name": "docstore.py"}, "index": 6, "child_indices": [], "ref_doc_id": "523dc2d189441cf16be18c8f3896fae904dc3473", "node_info": null}, "7": {"text": "The docstore.py file contains the DocumentStore class, which is used to store documents of different types. It has methods to serialize documents to a dictionary, check if it contains an IndexStruct, load documents from a dictionary, add documents, get a new ID, update the store, get a document, check if a document exists, delete a document, and get the length of the store. It also contains the TYPE_KEY constant, which is used to store the type of document.", "doc_id": null, "embedding": null, "extra_info": null, "index": 7, "child_indices": [0, 1, 2, 3, 4, 5, 6], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"7": {"text": "The docstore.py file contains the DocumentStore class, which is used to store documents of different types. It has methods to serialize documents to a dictionary, check if it contains an IndexStruct, load documents from a dictionary, add documents, get a new ID, update the store, get a document, check if a document exists, delete a document, and get the length of the store. It also contains the TYPE_KEY constant, which is used to store the type of document.", "doc_id": null, "embedding": null, "extra_info": null, "index": 7, "child_indices": [0, 1, 2, 3, 4, 5, 6], "ref_doc_id": null, "node_info": null}}}, "docstore": {"docs": {"523dc2d189441cf16be18c8f3896fae904dc3473": {"text": "\"\"\"Document store.\"\"\"\n\nfrom dataclasses import dataclass, field\nfrom typing import Any, Dict, List, Optional, Type, Union\n\nfrom dataclasses_json import DataClassJsonMixin\n\nfrom gpt_index.data_structs.data_structs import IndexStruct\nfrom gpt_index.readers.schema.base import Document\nfrom gpt_index.utils import get_new_id\n\nDOC_TYPE = Union[IndexStruct, Document]\n\n# type key: used to store type of document\nTYPE_KEY = \"__type__\"\n\n\n@dataclass\nclass DocumentStore(DataClassJsonMixin):\n    \"\"\"Document store.\"\"\"\n\n    docs: Dict[str, DOC_TYPE] = field(default_factory=dict)\n\n    def serialize_to_dict(self) -> Dict[str, Any]:\n        \"\"\"Serialize to dict.\"\"\"\n        docs_dict = {}\n        for doc_id, doc in self.docs.items():\n            doc_dict = doc.to_dict()\n            doc_dict[TYPE_KEY] = doc.get_type()\n            docs_dict[doc_id] = doc_dict\n        return {\"docs\": docs_dict}\n\n    def contains_index_struct(self, exclude_ids: Optional[List[str]] = None) -> bool:\n        \"\"\"Check if contains index struct.\"\"\"\n        exclude_ids = exclude_ids or []\n        for doc in self.docs.values():\n            if isinstance(doc, IndexStruct) and doc.get_doc_id() not in exclude_ids:\n                return True\n        return False\n\n    @classmethod\n    def load_from_dict(\n        cls,\n        docs_dict: Dict[str, Any],\n        type_to_struct: Optional[Dict[str, Type[IndexStruct]]] = None,\n    ) -> \"DocumentStore\":\n        \"\"\"Load from dict.\"\"\"\n        docs_obj_dict = {}\n        for doc_id, doc_dict in docs_dict[\"docs\"].items():\n            doc_type = doc_dict.pop(TYPE_KEY, None)\n            if doc_type == \"Document\" or doc_type is None:\n                doc: DOC_TYPE = Document.from_dict(doc_dict)\n            else:\n                if type_to_struct is None:\n                    raise ValueError(\n                        \"type_to_struct must be provided if type is index struct.\"\n                    )\n                # try using IndexStructType to retrieve documents\n                if doc_type not in type_to_struct:\n                    raise ValueError(\n                        f\"doc_type {doc_type} not found in type_to_struct. \"\n                        \"Make sure that it was registered in the index registry.\"\n                    )\n                doc = type_to_struct[doc_type].from_dict(doc_dict)\n                # doc = index_struct_cls.from_dict(doc_dict)\n            docs_obj_dict[doc_id] = doc\n        return cls(docs=docs_obj_dict)\n\n    @classmethod\n    def from_documents(cls, docs: List[DOC_TYPE]) -> \"DocumentStore\":\n        \"\"\"Create from documents.\"\"\"\n        obj = cls()\n        obj.add_documents(docs)\n        return obj\n\n    def get_new_id(self) -> str:\n        \"\"\"Get a new ID.\"\"\"\n        return get_new_id(set(self.docs.keys()))\n\n    def update_docstore(self, other: \"DocumentStore\") -> None:\n        \"\"\"Update docstore.\"\"\"\n        self.docs.update(other.docs)\n\n    def add_documents(self, docs: List[DOC_TYPE], generate_id: bool = True) -> None:\n        \"\"\"Add a document to the store.\n\n        If generate_id = True, then generate id for doc if doc_id doesn't exist.\n\n        \"\"\"\n        for doc in docs:\n            if doc.is_doc_id_none:\n                if generate_id:\n                    doc.doc_id = self.get_new_id()\n                else:\n                    raise ValueError(\n                        \"doc_id not set (to generate id, please set generate_id=True).\"\n                    )\n\n            # NOTE: doc could already exist in the store, but we overwrite it\n            self.docs[doc.get_doc_id()] = doc\n\n    def get_document(self, doc_id: str, raise_error: bool = True) -> Optional[DOC_TYPE]:\n        \"\"\"Get a document from the store.\"\"\"\n        doc = self.docs.get(doc_id, None)\n        if doc is None and raise_error:\n            raise ValueError(f\"doc_id {doc_id} not found.\")\n        return doc\n\n    def document_exists(self, doc_id: str) -> bool:\n        \"\"\"Check if document exists.\"\"\"\n        return doc_id in self.docs\n\n    def delete_document(\n        self, doc_id: str, raise_error: bool = True\n    ) -> Optional[DOC_TYPE]:\n        \"\"\"Delete a document from the store.\"\"\"\n        doc = self.docs.pop(doc_id, None)\n        if doc is None and raise_error:\n            raise ValueError(f\"doc_id {doc_id} not found.\")\n        return doc\n\n    def __len__(self) -> int:\n        \"\"\"Get length.\"\"\"\n        return len(self.docs.keys())\n", "doc_id": "523dc2d189441cf16be18c8f3896fae904dc3473", "embedding": null, "extra_info": {"file_path": "gpt_index/docstore.py", "file_name": "docstore.py"}, "__type__": "Document"}, "4bb47f6b-2c70-42ce-9233-0137340dd2de": {"text": "\nThe docstore.py file contains the DocumentStore class, which provides a way to store documents of different types and access them easily. It uses the DataClassJsonMixin to serialize documents to a dictionary and the IndexStruct class to store documents. The DocumentStore class has methods to serialize documents to a dictionary, check if it contains an IndexStruct, load documents from a dictionary, add documents, get a new ID, update the store, get a document, check if a document exists, delete a document, and get the length of the store. The TYPE_KEY constant is used to store the type of document. The purpose of the code is to provide an efficient way to store and access documents of different types.", "doc_id": "4bb47f6b-2c70-42ce-9233-0137340dd2de", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"Document store.\"\"\"\n\nfrom dataclasses import dataclass, field\nfrom typing import Any, Dict, List, Optional, Type, Union\n\nfrom dataclasses_json import DataClassJsonMixin\n\nfrom gpt_index.data_structs.data_structs import IndexStruct\nfrom gpt_index.readers.schema.base import Document\nfrom gpt_index.utils import get_new_id\n\nDOC_TYPE = Union[IndexStruct, Document]\n\n# type key: used to store type of document\nTYPE_KEY = \"__type__\"\n\n\n@dataclass\nclass DocumentStore(DataClassJsonMixin):\n    \"\"\"Document store.\"\"\"\n\n    docs: Dict[str, DOC_TYPE] = field(default_factory=dict)\n\n    def serialize_to_dict(self) -> Dict[str, Any]:\n        \"\"\"Serialize to dict.\"\"\"\n        docs_dict = {}\n        for doc_id, doc in self.docs.items():\n            doc_dict = doc.to_dict()\n            doc_dict[TYPE_KEY] = doc.get_type()\n            docs_dict[doc_id] = doc_dict\n        return {\"docs\": docs_dict}\n\n    def", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/docstore.py", "file_name": "docstore.py"}, "index": 0, "child_indices": [], "ref_doc_id": "523dc2d189441cf16be18c8f3896fae904dc3473", "node_info": null}, "1": {"text": "       return {\"docs\": docs_dict}\n\n    def contains_index_struct(self, exclude_ids: Optional[List[str]] = None) -> bool:\n        \"\"\"Check if contains index struct.\"\"\"\n        exclude_ids = exclude_ids or []\n        for doc in self.docs.values():\n            if isinstance(doc, IndexStruct) and doc.get_doc_id() not in exclude_ids:\n                return True\n        return False\n\n    @classmethod\n    def load_from_dict(\n        cls,\n        docs_dict: Dict[str, Any],\n        type_to_struct: Optional[Dict[str, Type[IndexStruct]]] = None,\n    ) -> \"DocumentStore\":\n        \"\"\"Load from dict.\"\"\"\n        docs_obj_dict = {}\n        for doc_id, doc_dict in docs_dict[\"docs\"].items():\n            doc_type = doc_dict.pop(TYPE_KEY, None)\n            if doc_type ==", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/docstore.py", "file_name": "docstore.py"}, "index": 1, "child_indices": [], "ref_doc_id": "523dc2d189441cf16be18c8f3896fae904dc3473", "node_info": null}, "2": {"text": "None)\n            if doc_type == \"Document\" or doc_type is None:\n                doc: DOC_TYPE = Document.from_dict(doc_dict)\n            else:\n                if type_to_struct is None:\n                    raise ValueError(\n                        \"type_to_struct must be provided if type is index struct.\"\n                    )\n                # try using IndexStructType to retrieve documents\n                if doc_type not in type_to_struct:\n                    raise ValueError(\n                        f\"doc_type {doc_type} not found in type_to_struct. \"\n                        \"Make sure that it was registered in the index registry.\"\n        ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/docstore.py", "file_name": "docstore.py"}, "index": 2, "child_indices": [], "ref_doc_id": "523dc2d189441cf16be18c8f3896fae904dc3473", "node_info": null}, "3": {"text": "sure that it was registered in the index registry.\"\n                    )\n                doc = type_to_struct[doc_type].from_dict(doc_dict)\n                # doc = index_struct_cls.from_dict(doc_dict)\n            docs_obj_dict[doc_id] = doc\n        return cls(docs=docs_obj_dict)\n\n    @classmethod\n    def from_documents(cls, docs: List[DOC_TYPE]) -> \"DocumentStore\":\n        \"\"\"Create from documents.\"\"\"\n        obj = cls()\n        obj.add_documents(docs)\n        return obj\n\n    def get_new_id(self) -> str:\n        \"\"\"Get a new ID.\"\"\"\n        return get_new_id(set(self.docs.keys()))\n\n    def update_docstore(self, other: \"DocumentStore\") -> None:\n        \"\"\"Update docstore.\"\"\"\n        self.docs.update(other.docs)\n\n    def", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/docstore.py", "file_name": "docstore.py"}, "index": 3, "child_indices": [], "ref_doc_id": "523dc2d189441cf16be18c8f3896fae904dc3473", "node_info": null}, "4": {"text": "     self.docs.update(other.docs)\n\n    def add_documents(self, docs: List[DOC_TYPE], generate_id: bool = True) -> None:\n        \"\"\"Add a document to the store.\n\n        If generate_id = True, then generate id for doc if doc_id doesn't exist.\n\n        \"\"\"\n        for doc in docs:\n            if doc.is_doc_id_none:\n                if generate_id:\n                    doc.doc_id = self.get_new_id()\n                else:\n                    raise ValueError(\n                        \"doc_id not set (to generate id, please set generate_id=True).\"\n                    )\n\n            # NOTE: doc could already exist in the store, but we overwrite it\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/docstore.py", "file_name": "docstore.py"}, "index": 4, "child_indices": [], "ref_doc_id": "523dc2d189441cf16be18c8f3896fae904dc3473", "node_info": null}, "5": {"text": "the store, but we overwrite it\n            self.docs[doc.get_doc_id()] = doc\n\n    def get_document(self, doc_id: str, raise_error: bool = True) -> Optional[DOC_TYPE]:\n        \"\"\"Get a document from the store.\"\"\"\n        doc = self.docs.get(doc_id, None)\n        if doc is None and raise_error:\n            raise ValueError(f\"doc_id {doc_id} not found.\")\n        return doc\n\n    def document_exists(self, doc_id: str) -> bool:\n        \"\"\"Check if document exists.\"\"\"\n        return doc_id in self.docs\n\n    def delete_document(\n        self, doc_id: str, raise_error: bool = True\n    ) -> Optional[DOC_TYPE]:\n        \"\"\"Delete a document from the store.\"\"\"\n        doc = self.docs.pop(doc_id, None)\n        if doc is None and raise_error:\n            raise ValueError(f\"doc_id {doc_id} not found.\")\n        return", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/docstore.py", "file_name": "docstore.py"}, "index": 5, "child_indices": [], "ref_doc_id": "523dc2d189441cf16be18c8f3896fae904dc3473", "node_info": null}, "6": {"text": "{doc_id} not found.\")\n        return doc\n\n    def __len__(self) -> int:\n        \"\"\"Get length.\"\"\"\n        return len(self.docs.keys())\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/docstore.py", "file_name": "docstore.py"}, "index": 6, "child_indices": [], "ref_doc_id": "523dc2d189441cf16be18c8f3896fae904dc3473", "node_info": null}, "7": {"text": "The docstore.py file contains the DocumentStore class, which is used to store documents of different types. It has methods to serialize documents to a dictionary, check if it contains an IndexStruct, load documents from a dictionary, add documents, get a new ID, update the store, get a document, check if a document exists, delete a document, and get the length of the store. It also contains the TYPE_KEY constant, which is used to store the type of document.", "doc_id": null, "embedding": null, "extra_info": null, "index": 7, "child_indices": [0, 1, 2, 3, 4, 5, 6], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"7": {"text": "The docstore.py file contains the DocumentStore class, which is used to store documents of different types. It has methods to serialize documents to a dictionary, check if it contains an IndexStruct, load documents from a dictionary, add documents, get a new ID, update the store, get a document, check if a document exists, delete a document, and get the length of the store. It also contains the TYPE_KEY constant, which is used to store the type of document.", "doc_id": null, "embedding": null, "extra_info": null, "index": 7, "child_indices": [0, 1, 2, 3, 4, 5, 6], "ref_doc_id": null, "node_info": null}}, "__type__": "tree"}}}}