{"index_struct": {"text": "\nQueryRunner is a class that provides a convenient way to perform queries with the right classes and parameters. It takes in a query request and uses the IndexRegistry to map the query type to the appropriate query class. It then uses the query class to perform the query, and provides a recursive option to pass itself as a query_runner to each individual query. The query_kwargs are also updated with default arguments if not present. This allows for a higher-level wrapper for a given query, making it easier to use and understand.", "doc_id": "4639af8d-fde3-4cd0-9af9-59482e350eed", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"Query runner.\"\"\"\n\nfrom typing import Any, Dict, List, Optional, Union, cast\n\nfrom gpt_index.data_structs.data_structs import IndexStruct\nfrom gpt_index.docstore import DocumentStore\nfrom gpt_index.embeddings.base import BaseEmbedding\nfrom gpt_index.indices.prompt_helper import PromptHelper\nfrom gpt_index.indices.query.base import BaseQueryRunner\nfrom gpt_index.indices.query.schema import QueryConfig, QueryMode\nfrom gpt_index.indices.registry import IndexRegistry\nfrom gpt_index.langchain_helpers.chain_wrapper import LLMPredictor\nfrom gpt_index.response.schema import Response\n\n# TMP: refactor query config type\nQUERY_CONFIG_TYPE = Union[Dict, QueryConfig]\n\n\nclass QueryRunner(BaseQueryRunner):\n    \"\"\"Tool to take in a query request and perform a query with the right classes.\n\n    Higher-level wrapper over a given query.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        llm_predictor: LLMPredictor,\n        prompt_helper: PromptHelper,\n        embed_model: BaseEmbedding,\n        docstore: DocumentStore,\n ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/query/query_runner.py", "file_name": "query_runner.py"}, "index": 0, "child_indices": [], "ref_doc_id": "266fe6e986b73943246d77bc2f38623ad4ca18c7", "node_info": null}, "1": {"text": "       docstore: DocumentStore,\n        index_registry: IndexRegistry,\n        query_configs: Optional[List[QUERY_CONFIG_TYPE]] = None,\n        recursive: bool = False,\n    ) -> None:\n        \"\"\"Init params.\"\"\"\n        config_dict: Dict[str, QueryConfig] = {}\n        if query_configs is None or len(query_configs) == 0:\n            query_config_objs: List[QueryConfig] = []\n        elif isinstance(query_configs[0], Dict):\n            query_config_objs = [\n                QueryConfig.from_dict(cast(Dict, qc)) for qc in query_configs\n            ]\n        else:\n            query_config_objs = [cast(QueryConfig, q) for q in query_configs]\n\n        for qc in query_config_objs:\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/query/query_runner.py", "file_name": "query_runner.py"}, "index": 1, "child_indices": [], "ref_doc_id": "266fe6e986b73943246d77bc2f38623ad4ca18c7", "node_info": null}, "2": {"text": "in query_config_objs:\n            config_dict[qc.index_struct_type] = qc\n\n        self._config_dict = config_dict\n        self._llm_predictor = llm_predictor\n        self._prompt_helper = prompt_helper\n        self._embed_model = embed_model\n        self._docstore = docstore\n        self._index_registry = index_registry\n        self._recursive = recursive\n\n    def _get_query_kwargs(self, config: QueryConfig) -> Dict[str, Any]:\n        \"\"\"Get query kwargs.\n\n        Also update with default arguments if not present.\n\n        \"\"\"\n        query_kwargs = {k: v for k, v in config.query_kwargs.items()}\n        if \"prompt_helper\" not in query_kwargs:\n            query_kwargs[\"prompt_helper\"] = self._prompt_helper\n        if \"llm_predictor\" not in query_kwargs:\n   ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/query/query_runner.py", "file_name": "query_runner.py"}, "index": 2, "child_indices": [], "ref_doc_id": "266fe6e986b73943246d77bc2f38623ad4ca18c7", "node_info": null}, "3": {"text": "if \"llm_predictor\" not in query_kwargs:\n            query_kwargs[\"llm_predictor\"] = self._llm_predictor\n        if \"embed_model\" not in query_kwargs:\n            query_kwargs[\"embed_model\"] = self._embed_model\n        return query_kwargs\n\n    def query(self, query_str: str, index_struct: IndexStruct) -> Response:\n        \"\"\"Run query.\"\"\"\n        index_struct_type = index_struct.get_type()\n        if index_struct_type not in self._config_dict:\n            config = QueryConfig(\n                index_struct_type=index_struct_type, query_mode=QueryMode.DEFAULT\n            )\n        else:\n            config = self._config_dict[index_struct_type]\n        mode = config.query_mode\n\n        query_cls = self._index_registry.type_to_query[index_struct_type][mode]\n ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/query/query_runner.py", "file_name": "query_runner.py"}, "index": 3, "child_indices": [], "ref_doc_id": "266fe6e986b73943246d77bc2f38623ad4ca18c7", "node_info": null}, "4": {"text": "       # if recursive, pass self as query_runner to each individual query\n        query_runner = self if self._recursive else None\n        query_kwargs = self._get_query_kwargs(config)\n        query_obj = query_cls(\n            index_struct,\n            **query_kwargs,\n            query_runner=query_runner,\n            docstore=self._docstore,\n        )\n\n        return query_obj.query(query_str)\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/query/query_runner.py", "file_name": "query_runner.py"}, "index": 4, "child_indices": [], "ref_doc_id": "266fe6e986b73943246d77bc2f38623ad4ca18c7", "node_info": null}, "5": {"text": "QueryRunner is a class that provides a higher-level wrapper over a given query. It takes in a query request and performs a query with the right classes. It uses the IndexRegistry to map the query type to the appropriate query class, and then uses the query class to perform the query. It also provides a recursive option, which allows it to pass itself as a query_runner to each individual query. The query_kwargs are also updated with default arguments if not present.", "doc_id": null, "embedding": null, "extra_info": null, "index": 5, "child_indices": [0, 1, 2, 3, 4], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"5": {"text": "QueryRunner is a class that provides a higher-level wrapper over a given query. It takes in a query request and performs a query with the right classes. It uses the IndexRegistry to map the query type to the appropriate query class, and then uses the query class to perform the query. It also provides a recursive option, which allows it to pass itself as a query_runner to each individual query. The query_kwargs are also updated with default arguments if not present.", "doc_id": null, "embedding": null, "extra_info": null, "index": 5, "child_indices": [0, 1, 2, 3, 4], "ref_doc_id": null, "node_info": null}}}, "docstore": {"docs": {"266fe6e986b73943246d77bc2f38623ad4ca18c7": {"text": "\"\"\"Query runner.\"\"\"\n\nfrom typing import Any, Dict, List, Optional, Union, cast\n\nfrom gpt_index.data_structs.data_structs import IndexStruct\nfrom gpt_index.docstore import DocumentStore\nfrom gpt_index.embeddings.base import BaseEmbedding\nfrom gpt_index.indices.prompt_helper import PromptHelper\nfrom gpt_index.indices.query.base import BaseQueryRunner\nfrom gpt_index.indices.query.schema import QueryConfig, QueryMode\nfrom gpt_index.indices.registry import IndexRegistry\nfrom gpt_index.langchain_helpers.chain_wrapper import LLMPredictor\nfrom gpt_index.response.schema import Response\n\n# TMP: refactor query config type\nQUERY_CONFIG_TYPE = Union[Dict, QueryConfig]\n\n\nclass QueryRunner(BaseQueryRunner):\n    \"\"\"Tool to take in a query request and perform a query with the right classes.\n\n    Higher-level wrapper over a given query.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        llm_predictor: LLMPredictor,\n        prompt_helper: PromptHelper,\n        embed_model: BaseEmbedding,\n        docstore: DocumentStore,\n        index_registry: IndexRegistry,\n        query_configs: Optional[List[QUERY_CONFIG_TYPE]] = None,\n        recursive: bool = False,\n    ) -> None:\n        \"\"\"Init params.\"\"\"\n        config_dict: Dict[str, QueryConfig] = {}\n        if query_configs is None or len(query_configs) == 0:\n            query_config_objs: List[QueryConfig] = []\n        elif isinstance(query_configs[0], Dict):\n            query_config_objs = [\n                QueryConfig.from_dict(cast(Dict, qc)) for qc in query_configs\n            ]\n        else:\n            query_config_objs = [cast(QueryConfig, q) for q in query_configs]\n\n        for qc in query_config_objs:\n            config_dict[qc.index_struct_type] = qc\n\n        self._config_dict = config_dict\n        self._llm_predictor = llm_predictor\n        self._prompt_helper = prompt_helper\n        self._embed_model = embed_model\n        self._docstore = docstore\n        self._index_registry = index_registry\n        self._recursive = recursive\n\n    def _get_query_kwargs(self, config: QueryConfig) -> Dict[str, Any]:\n        \"\"\"Get query kwargs.\n\n        Also update with default arguments if not present.\n\n        \"\"\"\n        query_kwargs = {k: v for k, v in config.query_kwargs.items()}\n        if \"prompt_helper\" not in query_kwargs:\n            query_kwargs[\"prompt_helper\"] = self._prompt_helper\n        if \"llm_predictor\" not in query_kwargs:\n            query_kwargs[\"llm_predictor\"] = self._llm_predictor\n        if \"embed_model\" not in query_kwargs:\n            query_kwargs[\"embed_model\"] = self._embed_model\n        return query_kwargs\n\n    def query(self, query_str: str, index_struct: IndexStruct) -> Response:\n        \"\"\"Run query.\"\"\"\n        index_struct_type = index_struct.get_type()\n        if index_struct_type not in self._config_dict:\n            config = QueryConfig(\n                index_struct_type=index_struct_type, query_mode=QueryMode.DEFAULT\n            )\n        else:\n            config = self._config_dict[index_struct_type]\n        mode = config.query_mode\n\n        query_cls = self._index_registry.type_to_query[index_struct_type][mode]\n        # if recursive, pass self as query_runner to each individual query\n        query_runner = self if self._recursive else None\n        query_kwargs = self._get_query_kwargs(config)\n        query_obj = query_cls(\n            index_struct,\n            **query_kwargs,\n            query_runner=query_runner,\n            docstore=self._docstore,\n        )\n\n        return query_obj.query(query_str)\n", "doc_id": "266fe6e986b73943246d77bc2f38623ad4ca18c7", "embedding": null, "extra_info": {"file_path": "gpt_index/indices/query/query_runner.py", "file_name": "query_runner.py"}, "__type__": "Document"}, "4639af8d-fde3-4cd0-9af9-59482e350eed": {"text": "\nQueryRunner is a class that provides a convenient way to perform queries with the right classes and parameters. It takes in a query request and uses the IndexRegistry to map the query type to the appropriate query class. It then uses the query class to perform the query, and provides a recursive option to pass itself as a query_runner to each individual query. The query_kwargs are also updated with default arguments if not present. This allows for a higher-level wrapper for a given query, making it easier to use and understand.", "doc_id": "4639af8d-fde3-4cd0-9af9-59482e350eed", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"Query runner.\"\"\"\n\nfrom typing import Any, Dict, List, Optional, Union, cast\n\nfrom gpt_index.data_structs.data_structs import IndexStruct\nfrom gpt_index.docstore import DocumentStore\nfrom gpt_index.embeddings.base import BaseEmbedding\nfrom gpt_index.indices.prompt_helper import PromptHelper\nfrom gpt_index.indices.query.base import BaseQueryRunner\nfrom gpt_index.indices.query.schema import QueryConfig, QueryMode\nfrom gpt_index.indices.registry import IndexRegistry\nfrom gpt_index.langchain_helpers.chain_wrapper import LLMPredictor\nfrom gpt_index.response.schema import Response\n\n# TMP: refactor query config type\nQUERY_CONFIG_TYPE = Union[Dict, QueryConfig]\n\n\nclass QueryRunner(BaseQueryRunner):\n    \"\"\"Tool to take in a query request and perform a query with the right classes.\n\n    Higher-level wrapper over a given query.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        llm_predictor: LLMPredictor,\n        prompt_helper: PromptHelper,\n        embed_model: BaseEmbedding,\n        docstore: DocumentStore,\n ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/query/query_runner.py", "file_name": "query_runner.py"}, "index": 0, "child_indices": [], "ref_doc_id": "266fe6e986b73943246d77bc2f38623ad4ca18c7", "node_info": null}, "1": {"text": "       docstore: DocumentStore,\n        index_registry: IndexRegistry,\n        query_configs: Optional[List[QUERY_CONFIG_TYPE]] = None,\n        recursive: bool = False,\n    ) -> None:\n        \"\"\"Init params.\"\"\"\n        config_dict: Dict[str, QueryConfig] = {}\n        if query_configs is None or len(query_configs) == 0:\n            query_config_objs: List[QueryConfig] = []\n        elif isinstance(query_configs[0], Dict):\n            query_config_objs = [\n                QueryConfig.from_dict(cast(Dict, qc)) for qc in query_configs\n            ]\n        else:\n            query_config_objs = [cast(QueryConfig, q) for q in query_configs]\n\n        for qc in query_config_objs:\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/query/query_runner.py", "file_name": "query_runner.py"}, "index": 1, "child_indices": [], "ref_doc_id": "266fe6e986b73943246d77bc2f38623ad4ca18c7", "node_info": null}, "2": {"text": "in query_config_objs:\n            config_dict[qc.index_struct_type] = qc\n\n        self._config_dict = config_dict\n        self._llm_predictor = llm_predictor\n        self._prompt_helper = prompt_helper\n        self._embed_model = embed_model\n        self._docstore = docstore\n        self._index_registry = index_registry\n        self._recursive = recursive\n\n    def _get_query_kwargs(self, config: QueryConfig) -> Dict[str, Any]:\n        \"\"\"Get query kwargs.\n\n        Also update with default arguments if not present.\n\n        \"\"\"\n        query_kwargs = {k: v for k, v in config.query_kwargs.items()}\n        if \"prompt_helper\" not in query_kwargs:\n            query_kwargs[\"prompt_helper\"] = self._prompt_helper\n        if \"llm_predictor\" not in query_kwargs:\n   ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/query/query_runner.py", "file_name": "query_runner.py"}, "index": 2, "child_indices": [], "ref_doc_id": "266fe6e986b73943246d77bc2f38623ad4ca18c7", "node_info": null}, "3": {"text": "if \"llm_predictor\" not in query_kwargs:\n            query_kwargs[\"llm_predictor\"] = self._llm_predictor\n        if \"embed_model\" not in query_kwargs:\n            query_kwargs[\"embed_model\"] = self._embed_model\n        return query_kwargs\n\n    def query(self, query_str: str, index_struct: IndexStruct) -> Response:\n        \"\"\"Run query.\"\"\"\n        index_struct_type = index_struct.get_type()\n        if index_struct_type not in self._config_dict:\n            config = QueryConfig(\n                index_struct_type=index_struct_type, query_mode=QueryMode.DEFAULT\n            )\n        else:\n            config = self._config_dict[index_struct_type]\n        mode = config.query_mode\n\n        query_cls = self._index_registry.type_to_query[index_struct_type][mode]\n ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/query/query_runner.py", "file_name": "query_runner.py"}, "index": 3, "child_indices": [], "ref_doc_id": "266fe6e986b73943246d77bc2f38623ad4ca18c7", "node_info": null}, "4": {"text": "       # if recursive, pass self as query_runner to each individual query\n        query_runner = self if self._recursive else None\n        query_kwargs = self._get_query_kwargs(config)\n        query_obj = query_cls(\n            index_struct,\n            **query_kwargs,\n            query_runner=query_runner,\n            docstore=self._docstore,\n        )\n\n        return query_obj.query(query_str)\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/query/query_runner.py", "file_name": "query_runner.py"}, "index": 4, "child_indices": [], "ref_doc_id": "266fe6e986b73943246d77bc2f38623ad4ca18c7", "node_info": null}, "5": {"text": "QueryRunner is a class that provides a higher-level wrapper over a given query. It takes in a query request and performs a query with the right classes. It uses the IndexRegistry to map the query type to the appropriate query class, and then uses the query class to perform the query. It also provides a recursive option, which allows it to pass itself as a query_runner to each individual query. The query_kwargs are also updated with default arguments if not present.", "doc_id": null, "embedding": null, "extra_info": null, "index": 5, "child_indices": [0, 1, 2, 3, 4], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"5": {"text": "QueryRunner is a class that provides a higher-level wrapper over a given query. It takes in a query request and performs a query with the right classes. It uses the IndexRegistry to map the query type to the appropriate query class, and then uses the query class to perform the query. It also provides a recursive option, which allows it to pass itself as a query_runner to each individual query. The query_kwargs are also updated with default arguments if not present.", "doc_id": null, "embedding": null, "extra_info": null, "index": 5, "child_indices": [0, 1, 2, 3, 4], "ref_doc_id": null, "node_info": null}}, "__type__": "tree"}}}}