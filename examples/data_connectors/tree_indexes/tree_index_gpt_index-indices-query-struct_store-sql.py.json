{"index_struct": {"text": "\nThis code file provides a way to query a structured database using either raw SQL or natural language queries. It contains two classes, GPTSQLStructStoreIndexQuery and GPTNLStructStoreIndexQuery, which use the SQLDatabase class and the Response class to run queries and return results. The GPTSQLStructStoreIndexQuery class runs raw SQL queries over a GPTSQLStructStoreIndex and uses the BaseGPTIndexQuery class to initialize parameters. The GPTNLStructStoreIndexQuery class extracts natural language queries to SQL and runs them over the same index, using the TextToSQLPrompt class to parse natural language queries into SQL queries.", "doc_id": "5dfa88f6-5dae-42ff-bc10-46850639c86a", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"Default query for GPTFaissIndex.\"\"\"\nimport logging\nfrom typing import Any, Optional\n\nfrom gpt_index.data_structs.table import SQLStructTable\nfrom gpt_index.indices.query.base import BaseGPTIndexQuery\nfrom gpt_index.langchain_helpers.sql_wrapper import SQLDatabase\nfrom gpt_index.prompts.default_prompts import DEFAULT_TEXT_TO_SQL_PROMPT\nfrom gpt_index.prompts.prompts import TextToSQLPrompt\nfrom gpt_index.response.schema import Response\nfrom gpt_index.token_counter.token_counter import llm_token_counter\n\n\nclass GPTSQLStructStoreIndexQuery(BaseGPTIndexQuery[SQLStructTable]):\n    \"\"\"GPT SQL query over a structured database.\n\n    Runs raw SQL over a GPTSQLStructStoreIndex. No LLM calls are made here.\n    NOTE: this query cannot work with composed indices - if the index\n    contains subindices, those subindices will not be queried.\n\n    .. code-block:: python\n\n        response = index.query(\"<query_str>\", mode=\"sql\")\n\n    \"\"\"\n\n    def __init__(\n        self,\n        index_struct: SQLStructTable,\n      ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/query/struct_store/sql.py", "file_name": "sql.py"}, "index": 0, "child_indices": [], "ref_doc_id": "b79e77bbf92c6bb7c326003d445709bae24fc168", "node_info": null}, "1": {"text": "     index_struct: SQLStructTable,\n        sql_database: Optional[SQLDatabase] = None,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"Initialize params.\"\"\"\n        super().__init__(index_struct=index_struct, **kwargs)\n        if sql_database is None:\n            raise ValueError(\"sql_database must be provided.\")\n        self._sql_database = sql_database\n\n    @llm_token_counter(\"query\")\n    def query(self, query_str: str) -> Response:\n        \"\"\"Answer a query.\"\"\"\n        # NOTE: override query method in order to fetch the right results.\n        # NOTE: since the query_str is a SQL query, it doesn't make sense\n        # to use ResponseBuilder anywhere.\n        response_str, extra_info = self._sql_database.run_sql(query_str)\n        response = Response(response=response_str, extra_info=extra_info)\n        return response\n\n\nclass", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/query/struct_store/sql.py", "file_name": "sql.py"}, "index": 1, "child_indices": [], "ref_doc_id": "b79e77bbf92c6bb7c326003d445709bae24fc168", "node_info": null}, "2": {"text": "       return response\n\n\nclass GPTNLStructStoreIndexQuery(BaseGPTIndexQuery[SQLStructTable]):\n    \"\"\"GPT natural language query over a structured database.\n\n    Given a natural language query, we will extract the query to SQL.\n    Runs raw SQL over a GPTSQLStructStoreIndex. No LLM calls are made here.\n    NOTE: this query cannot work with composed indices - if the index\n    contains subindices, those subindices will not be queried.\n\n    .. code-block:: python\n\n        response = index.query(\"<query_str>\", mode=\"sql\")\n\n    \"\"\"\n\n    def __init__(\n        self,\n        index_struct: SQLStructTable,\n        sql_database: Optional[SQLDatabase] = None,\n        ref_doc_id_column: Optional[str] = None,\n        text_to_sql_prompt: Optional[TextToSQLPrompt] = None,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"Initialize params.\"\"\"\n        super().__init__(index_struct=index_struct, **kwargs)\n      ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/query/struct_store/sql.py", "file_name": "sql.py"}, "index": 2, "child_indices": [], "ref_doc_id": "b79e77bbf92c6bb7c326003d445709bae24fc168", "node_info": null}, "3": {"text": "**kwargs)\n        if sql_database is None:\n            raise ValueError(\"sql_database must be provided.\")\n        self._sql_database = sql_database\n        self._ref_doc_id_column = ref_doc_id_column\n        self._text_to_sql_prompt = text_to_sql_prompt or DEFAULT_TEXT_TO_SQL_PROMPT\n\n    def _parse_response_to_sql(self, response: str) -> str:\n        \"\"\"Parse response to SQL.\"\"\"\n        result_response = response.strip()\n        return result_response\n\n    def _get_all_tables_desc(self) -> str:\n        \"\"\"Get tables schema + optional context as a single string.\"\"\"\n        tables_desc = []\n        for table_name in self._sql_database.get_table_names():\n            table_desc = self._sql_database.get_single_table_info(table_name)\n            table_text = f\"Schema of table {table_name}:\\n\"", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/query/struct_store/sql.py", "file_name": "sql.py"}, "index": 3, "child_indices": [], "ref_doc_id": "b79e77bbf92c6bb7c326003d445709bae24fc168", "node_info": null}, "4": {"text": "  table_text = f\"Schema of table {table_name}:\\n\" f\"{table_desc}\\n\"\n            if table_name in self._index_struct.context_dict:\n                table_text += f\"Context of table {table_name}:\\n\"\n                table_text += self._index_struct.context_dict[table_name]\n            tables_desc.append(table_text)\n        return \"\\n\\n\".join(tables_desc)\n\n    def _query(self, query_str: str) -> Response:\n        \"\"\"Answer a query.\"\"\"\n        table_desc_str = self._get_all_tables_desc()\n        logging.info(f\"table desc str: {table_desc_str}\")\n        response_str, _ = self._llm_predictor.predict(\n            self._text_to_sql_prompt, query_str=query_str, schema=table_desc_str\n        )\n\n        sql_query_str =", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/query/struct_store/sql.py", "file_name": "sql.py"}, "index": 4, "child_indices": [], "ref_doc_id": "b79e77bbf92c6bb7c326003d445709bae24fc168", "node_info": null}, "5": {"text": "     )\n\n        sql_query_str = self._parse_response_to_sql(response_str)\n        # assume that it's a valid SQL query\n        logging.debug(f\"> Predicted SQL query: {sql_query_str}\")\n\n        response_str, extra_info = self._sql_database.run_sql(sql_query_str)\n        response = Response(response=response_str, extra_info=extra_info)\n        return response\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/query/struct_store/sql.py", "file_name": "sql.py"}, "index": 5, "child_indices": [], "ref_doc_id": "b79e77bbf92c6bb7c326003d445709bae24fc168", "node_info": null}, "6": {"text": "This code file contains two classes, GPTSQLStructStoreIndexQuery and GPTNLStructStoreIndexQuery, which are used to query a structured database using either raw SQL or natural language queries. The GPTSQLStructStoreIndexQuery class runs raw SQL queries over a GPTSQLStructStoreIndex, while the GPTNLStructStoreIndexQuery class extracts natural language queries to SQL and runs them over the same index. Both classes use the SQLDatabase class to run the queries and the Response class to return the results.", "doc_id": null, "embedding": null, "extra_info": null, "index": 6, "child_indices": [0, 1, 2, 3, 4, 5], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"6": {"text": "This code file contains two classes, GPTSQLStructStoreIndexQuery and GPTNLStructStoreIndexQuery, which are used to query a structured database using either raw SQL or natural language queries. The GPTSQLStructStoreIndexQuery class runs raw SQL queries over a GPTSQLStructStoreIndex, while the GPTNLStructStoreIndexQuery class extracts natural language queries to SQL and runs them over the same index. Both classes use the SQLDatabase class to run the queries and the Response class to return the results.", "doc_id": null, "embedding": null, "extra_info": null, "index": 6, "child_indices": [0, 1, 2, 3, 4, 5], "ref_doc_id": null, "node_info": null}}}, "docstore": {"docs": {"b79e77bbf92c6bb7c326003d445709bae24fc168": {"text": "\"\"\"Default query for GPTFaissIndex.\"\"\"\nimport logging\nfrom typing import Any, Optional\n\nfrom gpt_index.data_structs.table import SQLStructTable\nfrom gpt_index.indices.query.base import BaseGPTIndexQuery\nfrom gpt_index.langchain_helpers.sql_wrapper import SQLDatabase\nfrom gpt_index.prompts.default_prompts import DEFAULT_TEXT_TO_SQL_PROMPT\nfrom gpt_index.prompts.prompts import TextToSQLPrompt\nfrom gpt_index.response.schema import Response\nfrom gpt_index.token_counter.token_counter import llm_token_counter\n\n\nclass GPTSQLStructStoreIndexQuery(BaseGPTIndexQuery[SQLStructTable]):\n    \"\"\"GPT SQL query over a structured database.\n\n    Runs raw SQL over a GPTSQLStructStoreIndex. No LLM calls are made here.\n    NOTE: this query cannot work with composed indices - if the index\n    contains subindices, those subindices will not be queried.\n\n    .. code-block:: python\n\n        response = index.query(\"<query_str>\", mode=\"sql\")\n\n    \"\"\"\n\n    def __init__(\n        self,\n        index_struct: SQLStructTable,\n        sql_database: Optional[SQLDatabase] = None,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"Initialize params.\"\"\"\n        super().__init__(index_struct=index_struct, **kwargs)\n        if sql_database is None:\n            raise ValueError(\"sql_database must be provided.\")\n        self._sql_database = sql_database\n\n    @llm_token_counter(\"query\")\n    def query(self, query_str: str) -> Response:\n        \"\"\"Answer a query.\"\"\"\n        # NOTE: override query method in order to fetch the right results.\n        # NOTE: since the query_str is a SQL query, it doesn't make sense\n        # to use ResponseBuilder anywhere.\n        response_str, extra_info = self._sql_database.run_sql(query_str)\n        response = Response(response=response_str, extra_info=extra_info)\n        return response\n\n\nclass GPTNLStructStoreIndexQuery(BaseGPTIndexQuery[SQLStructTable]):\n    \"\"\"GPT natural language query over a structured database.\n\n    Given a natural language query, we will extract the query to SQL.\n    Runs raw SQL over a GPTSQLStructStoreIndex. No LLM calls are made here.\n    NOTE: this query cannot work with composed indices - if the index\n    contains subindices, those subindices will not be queried.\n\n    .. code-block:: python\n\n        response = index.query(\"<query_str>\", mode=\"sql\")\n\n    \"\"\"\n\n    def __init__(\n        self,\n        index_struct: SQLStructTable,\n        sql_database: Optional[SQLDatabase] = None,\n        ref_doc_id_column: Optional[str] = None,\n        text_to_sql_prompt: Optional[TextToSQLPrompt] = None,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"Initialize params.\"\"\"\n        super().__init__(index_struct=index_struct, **kwargs)\n        if sql_database is None:\n            raise ValueError(\"sql_database must be provided.\")\n        self._sql_database = sql_database\n        self._ref_doc_id_column = ref_doc_id_column\n        self._text_to_sql_prompt = text_to_sql_prompt or DEFAULT_TEXT_TO_SQL_PROMPT\n\n    def _parse_response_to_sql(self, response: str) -> str:\n        \"\"\"Parse response to SQL.\"\"\"\n        result_response = response.strip()\n        return result_response\n\n    def _get_all_tables_desc(self) -> str:\n        \"\"\"Get tables schema + optional context as a single string.\"\"\"\n        tables_desc = []\n        for table_name in self._sql_database.get_table_names():\n            table_desc = self._sql_database.get_single_table_info(table_name)\n            table_text = f\"Schema of table {table_name}:\\n\" f\"{table_desc}\\n\"\n            if table_name in self._index_struct.context_dict:\n                table_text += f\"Context of table {table_name}:\\n\"\n                table_text += self._index_struct.context_dict[table_name]\n            tables_desc.append(table_text)\n        return \"\\n\\n\".join(tables_desc)\n\n    def _query(self, query_str: str) -> Response:\n        \"\"\"Answer a query.\"\"\"\n        table_desc_str = self._get_all_tables_desc()\n        logging.info(f\"table desc str: {table_desc_str}\")\n        response_str, _ = self._llm_predictor.predict(\n            self._text_to_sql_prompt, query_str=query_str, schema=table_desc_str\n        )\n\n        sql_query_str = self._parse_response_to_sql(response_str)\n        # assume that it's a valid SQL query\n        logging.debug(f\"> Predicted SQL query: {sql_query_str}\")\n\n        response_str, extra_info = self._sql_database.run_sql(sql_query_str)\n        response = Response(response=response_str, extra_info=extra_info)\n        return response\n", "doc_id": "b79e77bbf92c6bb7c326003d445709bae24fc168", "embedding": null, "extra_info": {"file_path": "gpt_index/indices/query/struct_store/sql.py", "file_name": "sql.py"}, "__type__": "Document"}, "5dfa88f6-5dae-42ff-bc10-46850639c86a": {"text": "\nThis code file provides a way to query a structured database using either raw SQL or natural language queries. It contains two classes, GPTSQLStructStoreIndexQuery and GPTNLStructStoreIndexQuery, which use the SQLDatabase class and the Response class to run queries and return results. The GPTSQLStructStoreIndexQuery class runs raw SQL queries over a GPTSQLStructStoreIndex and uses the BaseGPTIndexQuery class to initialize parameters. The GPTNLStructStoreIndexQuery class extracts natural language queries to SQL and runs them over the same index, using the TextToSQLPrompt class to parse natural language queries into SQL queries.", "doc_id": "5dfa88f6-5dae-42ff-bc10-46850639c86a", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"Default query for GPTFaissIndex.\"\"\"\nimport logging\nfrom typing import Any, Optional\n\nfrom gpt_index.data_structs.table import SQLStructTable\nfrom gpt_index.indices.query.base import BaseGPTIndexQuery\nfrom gpt_index.langchain_helpers.sql_wrapper import SQLDatabase\nfrom gpt_index.prompts.default_prompts import DEFAULT_TEXT_TO_SQL_PROMPT\nfrom gpt_index.prompts.prompts import TextToSQLPrompt\nfrom gpt_index.response.schema import Response\nfrom gpt_index.token_counter.token_counter import llm_token_counter\n\n\nclass GPTSQLStructStoreIndexQuery(BaseGPTIndexQuery[SQLStructTable]):\n    \"\"\"GPT SQL query over a structured database.\n\n    Runs raw SQL over a GPTSQLStructStoreIndex. No LLM calls are made here.\n    NOTE: this query cannot work with composed indices - if the index\n    contains subindices, those subindices will not be queried.\n\n    .. code-block:: python\n\n        response = index.query(\"<query_str>\", mode=\"sql\")\n\n    \"\"\"\n\n    def __init__(\n        self,\n        index_struct: SQLStructTable,\n      ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/query/struct_store/sql.py", "file_name": "sql.py"}, "index": 0, "child_indices": [], "ref_doc_id": "b79e77bbf92c6bb7c326003d445709bae24fc168", "node_info": null}, "1": {"text": "     index_struct: SQLStructTable,\n        sql_database: Optional[SQLDatabase] = None,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"Initialize params.\"\"\"\n        super().__init__(index_struct=index_struct, **kwargs)\n        if sql_database is None:\n            raise ValueError(\"sql_database must be provided.\")\n        self._sql_database = sql_database\n\n    @llm_token_counter(\"query\")\n    def query(self, query_str: str) -> Response:\n        \"\"\"Answer a query.\"\"\"\n        # NOTE: override query method in order to fetch the right results.\n        # NOTE: since the query_str is a SQL query, it doesn't make sense\n        # to use ResponseBuilder anywhere.\n        response_str, extra_info = self._sql_database.run_sql(query_str)\n        response = Response(response=response_str, extra_info=extra_info)\n        return response\n\n\nclass", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/query/struct_store/sql.py", "file_name": "sql.py"}, "index": 1, "child_indices": [], "ref_doc_id": "b79e77bbf92c6bb7c326003d445709bae24fc168", "node_info": null}, "2": {"text": "       return response\n\n\nclass GPTNLStructStoreIndexQuery(BaseGPTIndexQuery[SQLStructTable]):\n    \"\"\"GPT natural language query over a structured database.\n\n    Given a natural language query, we will extract the query to SQL.\n    Runs raw SQL over a GPTSQLStructStoreIndex. No LLM calls are made here.\n    NOTE: this query cannot work with composed indices - if the index\n    contains subindices, those subindices will not be queried.\n\n    .. code-block:: python\n\n        response = index.query(\"<query_str>\", mode=\"sql\")\n\n    \"\"\"\n\n    def __init__(\n        self,\n        index_struct: SQLStructTable,\n        sql_database: Optional[SQLDatabase] = None,\n        ref_doc_id_column: Optional[str] = None,\n        text_to_sql_prompt: Optional[TextToSQLPrompt] = None,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"Initialize params.\"\"\"\n        super().__init__(index_struct=index_struct, **kwargs)\n      ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/query/struct_store/sql.py", "file_name": "sql.py"}, "index": 2, "child_indices": [], "ref_doc_id": "b79e77bbf92c6bb7c326003d445709bae24fc168", "node_info": null}, "3": {"text": "**kwargs)\n        if sql_database is None:\n            raise ValueError(\"sql_database must be provided.\")\n        self._sql_database = sql_database\n        self._ref_doc_id_column = ref_doc_id_column\n        self._text_to_sql_prompt = text_to_sql_prompt or DEFAULT_TEXT_TO_SQL_PROMPT\n\n    def _parse_response_to_sql(self, response: str) -> str:\n        \"\"\"Parse response to SQL.\"\"\"\n        result_response = response.strip()\n        return result_response\n\n    def _get_all_tables_desc(self) -> str:\n        \"\"\"Get tables schema + optional context as a single string.\"\"\"\n        tables_desc = []\n        for table_name in self._sql_database.get_table_names():\n            table_desc = self._sql_database.get_single_table_info(table_name)\n            table_text = f\"Schema of table {table_name}:\\n\"", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/query/struct_store/sql.py", "file_name": "sql.py"}, "index": 3, "child_indices": [], "ref_doc_id": "b79e77bbf92c6bb7c326003d445709bae24fc168", "node_info": null}, "4": {"text": "  table_text = f\"Schema of table {table_name}:\\n\" f\"{table_desc}\\n\"\n            if table_name in self._index_struct.context_dict:\n                table_text += f\"Context of table {table_name}:\\n\"\n                table_text += self._index_struct.context_dict[table_name]\n            tables_desc.append(table_text)\n        return \"\\n\\n\".join(tables_desc)\n\n    def _query(self, query_str: str) -> Response:\n        \"\"\"Answer a query.\"\"\"\n        table_desc_str = self._get_all_tables_desc()\n        logging.info(f\"table desc str: {table_desc_str}\")\n        response_str, _ = self._llm_predictor.predict(\n            self._text_to_sql_prompt, query_str=query_str, schema=table_desc_str\n        )\n\n        sql_query_str =", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/query/struct_store/sql.py", "file_name": "sql.py"}, "index": 4, "child_indices": [], "ref_doc_id": "b79e77bbf92c6bb7c326003d445709bae24fc168", "node_info": null}, "5": {"text": "     )\n\n        sql_query_str = self._parse_response_to_sql(response_str)\n        # assume that it's a valid SQL query\n        logging.debug(f\"> Predicted SQL query: {sql_query_str}\")\n\n        response_str, extra_info = self._sql_database.run_sql(sql_query_str)\n        response = Response(response=response_str, extra_info=extra_info)\n        return response\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/query/struct_store/sql.py", "file_name": "sql.py"}, "index": 5, "child_indices": [], "ref_doc_id": "b79e77bbf92c6bb7c326003d445709bae24fc168", "node_info": null}, "6": {"text": "This code file contains two classes, GPTSQLStructStoreIndexQuery and GPTNLStructStoreIndexQuery, which are used to query a structured database using either raw SQL or natural language queries. The GPTSQLStructStoreIndexQuery class runs raw SQL queries over a GPTSQLStructStoreIndex, while the GPTNLStructStoreIndexQuery class extracts natural language queries to SQL and runs them over the same index. Both classes use the SQLDatabase class to run the queries and the Response class to return the results.", "doc_id": null, "embedding": null, "extra_info": null, "index": 6, "child_indices": [0, 1, 2, 3, 4, 5], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"6": {"text": "This code file contains two classes, GPTSQLStructStoreIndexQuery and GPTNLStructStoreIndexQuery, which are used to query a structured database using either raw SQL or natural language queries. The GPTSQLStructStoreIndexQuery class runs raw SQL queries over a GPTSQLStructStoreIndex, while the GPTNLStructStoreIndexQuery class extracts natural language queries to SQL and runs them over the same index. Both classes use the SQLDatabase class to run the queries and the Response class to return the results.", "doc_id": null, "embedding": null, "extra_info": null, "index": 6, "child_indices": [0, 1, 2, 3, 4, 5], "ref_doc_id": null, "node_info": null}}, "__type__": "tree"}}}}