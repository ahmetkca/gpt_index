{"index_struct": {"text": "\nThe GPTTreeIndex is a data structure that organizes external data into a tree structure that can be queried. It takes in a set of text documents as input and builds up a tree-index in a bottom-up fashion, with each parent node summarizing the children nodes using a general summarization prompt. The index can be saved to disk as a JSON and loaded for future use. There are two query modes: `default` and `retrieve`. The `default` mode uses a query prompt template to recursively perform tree traversal in a top-down fashion in order to answer a question. The `retrieve` mode simply uses the root nodes as context to synthesize an answer to the query. The GPTTreeIndex is an efficient way to store and query data, as it allows for quick traversal of the tree structure and is cost-effective. The code file implements a data structure that organizes external data into a tree structure, which can be queried using two different modes. The `default` mode uses a query prompt template to traverse the tree in a top-down fashion, while the `retrieve` mode uses the root nodes as context to synthesize an answer. The index can be saved to disk as a", "doc_id": "93d93cc9-721c-4d9f-a331-e31d63bdccbd", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\n\n\ud83c\udf32 Tree Index\n\nCurrently the tree index refers to the `GPTTreeIndex` class. It organizes external data into a tree structure that can be queried.\n\n\n\n\n\nIndex Construction\n\nThe `GPTTreeIndex` first takes in a set of text documents as input. It then builds up a tree-index in a bottom-up fashion; each parent node is able to summarize the children nodes using a general **summarization prompt**; each intermediate node contains text summarizing the components below. Once the index is built, it can be saved to disk as a JSON and loaded for future use.\n\n\n\n\n\nQuery\n\nThere are two query modes: `default` and `retrieve`.\n\n**Default (GPTTreeIndexLeafQuery)**\n\nUsing a **query prompt template**, the GPTTreeIndex will be able to recursively perform tree traversal in a top-down fashion in order to answer a question. For example, in the very beginning GPT-3 is tasked with selecting between _n_ top-level nodes which best answers a provided query, by outputting a number as a multiple-choice problem. The GPTTreeIndex then uses the number to select the corresponding node, and the process repeats recursively among the children nodes until a leaf node is reached.\n\n**Retrieve (GPTTreeIndexRetQuery)**\n\nSimply use the root nodes as context to", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/tree/README.md", "file_name": "gpt_index/indices/tree/README.md"}, "index": 0, "child_indices": [], "ref_doc_id": "aa53c642b9c9f3e8695dcbe11ea3a6a33628a1fd", "node_info": null}, "1": {"text": "(GPTTreeIndexRetQuery)**\n\nSimply use the root nodes as context to synthesize an answer to the query. This is especially effective if the tree is preseeded with a `query_str`.\n\n\n\n\n\nUsage\n\n```python\nfrom gpt_index import GPTTreeIndex, SimpleDirectoryReader\n\n\n\n\n\nbuild index\ndocuments = SimpleDirectoryReader('data').load_data()\nindex = GPTTreeIndex(documents)\n\n\n\n\nsave index\nindex.save_to_disk('index_tree.json')\n\n\n\n\nload index from disk\nindex = GPTListIndex.load_from_disk('index_tree.json')\n\n\n\n\nquery\nresponse = index.query(\"\", mode=\"default\")\n```\n\n\n\n\n\nFAQ\n\n**Why build a tree? Why not just incrementally go through each chunk?**\n\nAlgorithmically speaking, $O(\\log N)$ is better than $O(N)$.\n\nMore broadly, building a tree helps us to test GPT's capabilities in modeling information in a hierarchy. It seems to me that our brains organize information in a similar way (citation needed). We can use this design to test how GPT can use its own hierarchy to answer questions.\n\nPractically speaking, it is much cheaper to do so and I want to limit my monthly spending (see below for costs).\n\n**How much does this cost to run?**\n\nWe currently use", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/tree/README.md", "file_name": "gpt_index/indices/tree/README.md"}, "index": 1, "child_indices": [], "ref_doc_id": "aa53c642b9c9f3e8695dcbe11ea3a6a33628a1fd", "node_info": null}, "2": {"text": "costs).\n\n**How much does this cost to run?**\n\nWe currently use the Davinci model for good results. Unfortunately Davinci is quite expensive. The cost of building the tree is roughly\n$cN\\log(N)\\frac{p}{1000}$, where $p=4096$ is the prompt limit and $c$ is the cost per 1000 tokens ($0.02 as mentioned on the pricing page). The cost of querying the tree is roughly \n$c\\log(N)\\frac{p}{1000}$.\n\nFor the NYC example, this equates to \\$~0.40 per query.\n\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/tree/README.md", "file_name": "gpt_index/indices/tree/README.md"}, "index": 2, "child_indices": [], "ref_doc_id": "aa53c642b9c9f3e8695dcbe11ea3a6a33628a1fd", "node_info": null}, "3": {"text": "The GPTTreeIndex is a data structure that organizes external data into a tree structure that can be queried. It takes in a set of text documents as input and builds up a tree-index in a bottom-up fashion, with each parent node summarizing the children nodes using a general summarization prompt. The index can be saved to disk as a JSON and loaded for future use. There are two query modes: `default` and `retrieve`. The `default` mode uses a query prompt template to recursively perform tree traversal in a top-down fashion in order to answer a question. The `retrieve` mode simply uses the root nodes as context to synthesize an answer to the query. The cost of building the tree is roughly $cN\\log(N)\\frac{p}{1000}$, where $p=4096$ is the prompt limit and $c$ is the cost per 1000 tokens. The cost of querying the tree is roughly $c\\log(N)\\frac{p}{1000}$.", "doc_id": null, "embedding": null, "extra_info": null, "index": 3, "child_indices": [0, 1, 2], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"3": {"text": "The GPTTreeIndex is a data structure that organizes external data into a tree structure that can be queried. It takes in a set of text documents as input and builds up a tree-index in a bottom-up fashion, with each parent node summarizing the children nodes using a general summarization prompt. The index can be saved to disk as a JSON and loaded for future use. There are two query modes: `default` and `retrieve`. The `default` mode uses a query prompt template to recursively perform tree traversal in a top-down fashion in order to answer a question. The `retrieve` mode simply uses the root nodes as context to synthesize an answer to the query. The cost of building the tree is roughly $cN\\log(N)\\frac{p}{1000}$, where $p=4096$ is the prompt limit and $c$ is the cost per 1000 tokens. The cost of querying the tree is roughly $c\\log(N)\\frac{p}{1000}$.", "doc_id": null, "embedding": null, "extra_info": null, "index": 3, "child_indices": [0, 1, 2], "ref_doc_id": null, "node_info": null}}}, "docstore": {"docs": {"aa53c642b9c9f3e8695dcbe11ea3a6a33628a1fd": {"text": "\n\n\ud83c\udf32 Tree Index\n\nCurrently the tree index refers to the `GPTTreeIndex` class. It organizes external data into a tree structure that can be queried.\n\n\n\n\n\nIndex Construction\n\nThe `GPTTreeIndex` first takes in a set of text documents as input. It then builds up a tree-index in a bottom-up fashion; each parent node is able to summarize the children nodes using a general **summarization prompt**; each intermediate node contains text summarizing the components below. Once the index is built, it can be saved to disk as a JSON and loaded for future use.\n\n\n\n\n\nQuery\n\nThere are two query modes: `default` and `retrieve`.\n\n**Default (GPTTreeIndexLeafQuery)**\n\nUsing a **query prompt template**, the GPTTreeIndex will be able to recursively perform tree traversal in a top-down fashion in order to answer a question. For example, in the very beginning GPT-3 is tasked with selecting between _n_ top-level nodes which best answers a provided query, by outputting a number as a multiple-choice problem. The GPTTreeIndex then uses the number to select the corresponding node, and the process repeats recursively among the children nodes until a leaf node is reached.\n\n**Retrieve (GPTTreeIndexRetQuery)**\n\nSimply use the root nodes as context to synthesize an answer to the query. This is especially effective if the tree is preseeded with a `query_str`.\n\n\n\n\n\nUsage\n\n```python\nfrom gpt_index import GPTTreeIndex, SimpleDirectoryReader\n\n\n\n\n\nbuild index\ndocuments = SimpleDirectoryReader('data').load_data()\nindex = GPTTreeIndex(documents)\n\n\n\n\nsave index\nindex.save_to_disk('index_tree.json')\n\n\n\n\nload index from disk\nindex = GPTListIndex.load_from_disk('index_tree.json')\n\n\n\n\nquery\nresponse = index.query(\"\", mode=\"default\")\n```\n\n\n\n\n\nFAQ\n\n**Why build a tree? Why not just incrementally go through each chunk?**\n\nAlgorithmically speaking, $O(\\log N)$ is better than $O(N)$.\n\nMore broadly, building a tree helps us to test GPT's capabilities in modeling information in a hierarchy. It seems to me that our brains organize information in a similar way (citation needed). We can use this design to test how GPT can use its own hierarchy to answer questions.\n\nPractically speaking, it is much cheaper to do so and I want to limit my monthly spending (see below for costs).\n\n**How much does this cost to run?**\n\nWe currently use the Davinci model for good results. Unfortunately Davinci is quite expensive. The cost of building the tree is roughly\n$cN\\log(N)\\frac{p}{1000}$, where $p=4096$ is the prompt limit and $c$ is the cost per 1000 tokens ($0.02 as mentioned on the pricing page). The cost of querying the tree is roughly \n$c\\log(N)\\frac{p}{1000}$.\n\nFor the NYC example, this equates to \\$~0.40 per query.\n\n", "doc_id": "aa53c642b9c9f3e8695dcbe11ea3a6a33628a1fd", "embedding": null, "extra_info": {"file_path": "gpt_index/indices/tree/README.md", "file_name": "gpt_index/indices/tree/README.md"}, "__type__": "Document"}, "93d93cc9-721c-4d9f-a331-e31d63bdccbd": {"text": "\nThe GPTTreeIndex is a data structure that organizes external data into a tree structure that can be queried. It takes in a set of text documents as input and builds up a tree-index in a bottom-up fashion, with each parent node summarizing the children nodes using a general summarization prompt. The index can be saved to disk as a JSON and loaded for future use. There are two query modes: `default` and `retrieve`. The `default` mode uses a query prompt template to recursively perform tree traversal in a top-down fashion in order to answer a question. The `retrieve` mode simply uses the root nodes as context to synthesize an answer to the query. The GPTTreeIndex is an efficient way to store and query data, as it allows for quick traversal of the tree structure and is cost-effective. The code file implements a data structure that organizes external data into a tree structure, which can be queried using two different modes. The `default` mode uses a query prompt template to traverse the tree in a top-down fashion, while the `retrieve` mode uses the root nodes as context to synthesize an answer. The index can be saved to disk as a", "doc_id": "93d93cc9-721c-4d9f-a331-e31d63bdccbd", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\n\n\ud83c\udf32 Tree Index\n\nCurrently the tree index refers to the `GPTTreeIndex` class. It organizes external data into a tree structure that can be queried.\n\n\n\n\n\nIndex Construction\n\nThe `GPTTreeIndex` first takes in a set of text documents as input. It then builds up a tree-index in a bottom-up fashion; each parent node is able to summarize the children nodes using a general **summarization prompt**; each intermediate node contains text summarizing the components below. Once the index is built, it can be saved to disk as a JSON and loaded for future use.\n\n\n\n\n\nQuery\n\nThere are two query modes: `default` and `retrieve`.\n\n**Default (GPTTreeIndexLeafQuery)**\n\nUsing a **query prompt template**, the GPTTreeIndex will be able to recursively perform tree traversal in a top-down fashion in order to answer a question. For example, in the very beginning GPT-3 is tasked with selecting between _n_ top-level nodes which best answers a provided query, by outputting a number as a multiple-choice problem. The GPTTreeIndex then uses the number to select the corresponding node, and the process repeats recursively among the children nodes until a leaf node is reached.\n\n**Retrieve (GPTTreeIndexRetQuery)**\n\nSimply use the root nodes as context to", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/tree/README.md", "file_name": "gpt_index/indices/tree/README.md"}, "index": 0, "child_indices": [], "ref_doc_id": "aa53c642b9c9f3e8695dcbe11ea3a6a33628a1fd", "node_info": null}, "1": {"text": "(GPTTreeIndexRetQuery)**\n\nSimply use the root nodes as context to synthesize an answer to the query. This is especially effective if the tree is preseeded with a `query_str`.\n\n\n\n\n\nUsage\n\n```python\nfrom gpt_index import GPTTreeIndex, SimpleDirectoryReader\n\n\n\n\n\nbuild index\ndocuments = SimpleDirectoryReader('data').load_data()\nindex = GPTTreeIndex(documents)\n\n\n\n\nsave index\nindex.save_to_disk('index_tree.json')\n\n\n\n\nload index from disk\nindex = GPTListIndex.load_from_disk('index_tree.json')\n\n\n\n\nquery\nresponse = index.query(\"\", mode=\"default\")\n```\n\n\n\n\n\nFAQ\n\n**Why build a tree? Why not just incrementally go through each chunk?**\n\nAlgorithmically speaking, $O(\\log N)$ is better than $O(N)$.\n\nMore broadly, building a tree helps us to test GPT's capabilities in modeling information in a hierarchy. It seems to me that our brains organize information in a similar way (citation needed). We can use this design to test how GPT can use its own hierarchy to answer questions.\n\nPractically speaking, it is much cheaper to do so and I want to limit my monthly spending (see below for costs).\n\n**How much does this cost to run?**\n\nWe currently use", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/tree/README.md", "file_name": "gpt_index/indices/tree/README.md"}, "index": 1, "child_indices": [], "ref_doc_id": "aa53c642b9c9f3e8695dcbe11ea3a6a33628a1fd", "node_info": null}, "2": {"text": "costs).\n\n**How much does this cost to run?**\n\nWe currently use the Davinci model for good results. Unfortunately Davinci is quite expensive. The cost of building the tree is roughly\n$cN\\log(N)\\frac{p}{1000}$, where $p=4096$ is the prompt limit and $c$ is the cost per 1000 tokens ($0.02 as mentioned on the pricing page). The cost of querying the tree is roughly \n$c\\log(N)\\frac{p}{1000}$.\n\nFor the NYC example, this equates to \\$~0.40 per query.\n\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/tree/README.md", "file_name": "gpt_index/indices/tree/README.md"}, "index": 2, "child_indices": [], "ref_doc_id": "aa53c642b9c9f3e8695dcbe11ea3a6a33628a1fd", "node_info": null}, "3": {"text": "The GPTTreeIndex is a data structure that organizes external data into a tree structure that can be queried. It takes in a set of text documents as input and builds up a tree-index in a bottom-up fashion, with each parent node summarizing the children nodes using a general summarization prompt. The index can be saved to disk as a JSON and loaded for future use. There are two query modes: `default` and `retrieve`. The `default` mode uses a query prompt template to recursively perform tree traversal in a top-down fashion in order to answer a question. The `retrieve` mode simply uses the root nodes as context to synthesize an answer to the query. The cost of building the tree is roughly $cN\\log(N)\\frac{p}{1000}$, where $p=4096$ is the prompt limit and $c$ is the cost per 1000 tokens. The cost of querying the tree is roughly $c\\log(N)\\frac{p}{1000}$.", "doc_id": null, "embedding": null, "extra_info": null, "index": 3, "child_indices": [0, 1, 2], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"3": {"text": "The GPTTreeIndex is a data structure that organizes external data into a tree structure that can be queried. It takes in a set of text documents as input and builds up a tree-index in a bottom-up fashion, with each parent node summarizing the children nodes using a general summarization prompt. The index can be saved to disk as a JSON and loaded for future use. There are two query modes: `default` and `retrieve`. The `default` mode uses a query prompt template to recursively perform tree traversal in a top-down fashion in order to answer a question. The `retrieve` mode simply uses the root nodes as context to synthesize an answer to the query. The cost of building the tree is roughly $cN\\log(N)\\frac{p}{1000}$, where $p=4096$ is the prompt limit and $c$ is the cost per 1000 tokens. The cost of querying the tree is roughly $c\\log(N)\\frac{p}{1000}$.", "doc_id": null, "embedding": null, "extra_info": null, "index": 3, "child_indices": [0, 1, 2], "ref_doc_id": null, "node_info": null}}, "__type__": "tree"}}}}