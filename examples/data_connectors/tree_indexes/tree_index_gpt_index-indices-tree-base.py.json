{"index_struct": {"text": "\nThe GPTTreeIndex class is a tree-structured index used to store documents. It is built using a bottoms-up approach, with each node summarizing its children nodes. The class contains methods for building the index from documents, inserting documents, and deleting documents. It also contains parameters for the number of children each node should have, a summarization prompt, an insertion prompt, and a language model predictor. The class also contains methods for validating that the index supports modes that require trees and for preprocessing queries. The purpose of the code is to provide an efficient way to store and query documents, allowing for quick retrieval of relevant information.", "doc_id": "c3a9ea9a-a3bf-4311-bebf-094b087ce03e", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"Tree-based index.\"\"\"\n\nfrom typing import Any, Dict, Optional, Sequence, Type\n\nfrom gpt_index.data_structs.data_structs import IndexGraph\nfrom gpt_index.indices.base import DOCUMENTS_INPUT, BaseGPTIndex\nfrom gpt_index.indices.common.tree.base import GPTTreeIndexBuilder\nfrom gpt_index.indices.query.base import BaseGPTIndexQuery\nfrom gpt_index.indices.query.schema import QueryMode\nfrom gpt_index.indices.query.tree.embedding_query import GPTTreeIndexEmbeddingQuery\nfrom gpt_index.indices.query.tree.leaf_query import GPTTreeIndexLeafQuery\nfrom gpt_index.indices.query.tree.retrieve_query import GPTTreeIndexRetQuery\nfrom gpt_index.indices.query.tree.summarize_query import GPTTreeIndexSummarizeQuery\nfrom gpt_index.indices.tree.inserter import GPTIndexInserter\nfrom gpt_index.langchain_helpers.chain_wrapper import LLMPredictor\nfrom gpt_index.prompts.default_prompts import (\n    DEFAULT_INSERT_PROMPT,\n    DEFAULT_SUMMARY_PROMPT,\n)\nfrom gpt_index.prompts.prompts import SummaryPrompt, TreeInsertPrompt\nfrom", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/tree/base.py", "file_name": "base.py"}, "index": 0, "child_indices": [], "ref_doc_id": "e627d6f084fdbaefa7f0a5c7d67f5efba7ae8b39", "node_info": null}, "1": {"text": "import SummaryPrompt, TreeInsertPrompt\nfrom gpt_index.schema import BaseDocument\n\nREQUIRE_TREE_MODES = {\n    QueryMode.DEFAULT,\n    QueryMode.EMBEDDING,\n    QueryMode.RETRIEVE,\n}\n\n\nclass GPTTreeIndex(BaseGPTIndex[IndexGraph]):\n    \"\"\"GPT Tree Index.\n\n    The tree index is a tree-structured index, where each node is a summary of\n    the children nodes. During index construction, the tree is constructed\n    in a bottoms-up fashion until we end up with a set of root_nodes.\n\n    There are a few different options during query time (see :ref:`Ref-Query`).\n    The main option is to traverse down the tree from the root nodes.\n    A secondary answer is to directly synthesize the answer from the root nodes.\n\n    Args:\n        summary_template (Optional[SummaryPrompt]): A Summarization Prompt\n            (see :ref:`Prompt-Templates`).\n        insert_prompt (Optional[TreeInsertPrompt]): An Tree Insertion Prompt\n            (see :ref:`Prompt-Templates`).\n        num_children", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/tree/base.py", "file_name": "base.py"}, "index": 1, "child_indices": [], "ref_doc_id": "e627d6f084fdbaefa7f0a5c7d67f5efba7ae8b39", "node_info": null}, "2": {"text": "       num_children (int): The number of children each node should have.\n        build_tree (bool): Whether to build the tree during index construction.\n\n    \"\"\"\n\n    index_struct_cls = IndexGraph\n\n    def __init__(\n        self,\n        documents: Optional[Sequence[DOCUMENTS_INPUT]] = None,\n        index_struct: Optional[IndexGraph] = None,\n        summary_template: Optional[SummaryPrompt] = None,\n        insert_prompt: Optional[TreeInsertPrompt] = None,\n        num_children: int = 10,\n        llm_predictor: Optional[LLMPredictor] = None,\n        build_tree: bool = True,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"Initialize params.\"\"\"\n        # need to set parameters before building index in base class.\n        self.num_children = num_children\n        self.summary_template = summary_template or DEFAULT_SUMMARY_PROMPT\n        self.insert_prompt:", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/tree/base.py", "file_name": "base.py"}, "index": 2, "child_indices": [], "ref_doc_id": "e627d6f084fdbaefa7f0a5c7d67f5efba7ae8b39", "node_info": null}, "3": {"text": "       self.insert_prompt: TreeInsertPrompt = insert_prompt or DEFAULT_INSERT_PROMPT\n        self.build_tree = build_tree\n        super().__init__(\n            documents=documents,\n            index_struct=index_struct,\n            llm_predictor=llm_predictor,\n            **kwargs,\n        )\n\n    @classmethod\n    def get_query_map(self) -> Dict[str, Type[BaseGPTIndexQuery]]:\n        \"\"\"Get query map.\"\"\"\n        return {\n            QueryMode.DEFAULT: GPTTreeIndexLeafQuery,\n            QueryMode.EMBEDDING: GPTTreeIndexEmbeddingQuery,\n            QueryMode.RETRIEVE: GPTTreeIndexRetQuery,\n            QueryMode.SUMMARIZE: GPTTreeIndexSummarizeQuery,\n        }\n\n    def _validate_build_tree_required(self,", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/tree/base.py", "file_name": "base.py"}, "index": 3, "child_indices": [], "ref_doc_id": "e627d6f084fdbaefa7f0a5c7d67f5efba7ae8b39", "node_info": null}, "4": {"text": "  }\n\n    def _validate_build_tree_required(self, mode: QueryMode) -> None:\n        \"\"\"Check if index supports modes that require trees.\"\"\"\n        if mode in REQUIRE_TREE_MODES and not self.build_tree:\n            raise ValueError(\n                \"Index was constructed without building trees, \"\n                f\"but mode {mode} requires trees.\"\n            )\n\n    def _preprocess_query(self, mode: QueryMode, query_kwargs: Any) -> None:\n        \"\"\"Query mode to class.\"\"\"\n        super()._preprocess_query(mode, query_kwargs)\n        self._validate_build_tree_required(mode)\n\n    def _build_index_from_documents(\n        self, documents: Sequence[BaseDocument]\n    ) -> IndexGraph:\n        \"\"\"Build the index from documents.\"\"\"\n        # do simple concatenation\n        index_builder = GPTTreeIndexBuilder(\n         ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/tree/base.py", "file_name": "base.py"}, "index": 4, "child_indices": [], "ref_doc_id": "e627d6f084fdbaefa7f0a5c7d67f5efba7ae8b39", "node_info": null}, "5": {"text": "index_builder = GPTTreeIndexBuilder(\n            self.num_children,\n            self.summary_template,\n            self._llm_predictor,\n            self._prompt_helper,\n        )\n        index_graph = index_builder.build_from_text(\n            documents, build_tree=self.build_tree\n        )\n        return index_graph\n\n    def _insert(self, document: BaseDocument, **insert_kwargs: Any) -> None:\n        \"\"\"Insert a document.\"\"\"\n        # TODO: allow to customize insert prompt\n        inserter = GPTIndexInserter(\n            self.index_struct,\n            num_children=self.num_children,\n            insert_prompt=self.insert_prompt,\n            summary_prompt=self.summary_template,\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/tree/base.py", "file_name": "base.py"}, "index": 5, "child_indices": [], "ref_doc_id": "e627d6f084fdbaefa7f0a5c7d67f5efba7ae8b39", "node_info": null}, "6": {"text": "           llm_predictor=self._llm_predictor,\n            prompt_helper=self._prompt_helper,\n        )\n        inserter.insert(document)\n\n    def _delete(self, doc_id: str, **delete_kwargs: Any) -> None:\n        \"\"\"Delete a document.\"\"\"\n        raise NotImplementedError(\"Delete not implemented for tree index.\")\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/tree/base.py", "file_name": "base.py"}, "index": 6, "child_indices": [], "ref_doc_id": "e627d6f084fdbaefa7f0a5c7d67f5efba7ae8b39", "node_info": null}, "7": {"text": "This code file contains the GPTTreeIndex class, which is a tree-structured index used to store documents. It is built in a bottoms-up fashion, with each node being a summary of its children nodes. During query time, the tree can be traversed from the root nodes or the answer can be synthesized from the root nodes. The class also contains methods for building the index from documents, inserting documents, and deleting documents.", "doc_id": null, "embedding": null, "extra_info": null, "index": 7, "child_indices": [0, 1, 2, 3, 4, 5, 6], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"7": {"text": "This code file contains the GPTTreeIndex class, which is a tree-structured index used to store documents. It is built in a bottoms-up fashion, with each node being a summary of its children nodes. During query time, the tree can be traversed from the root nodes or the answer can be synthesized from the root nodes. The class also contains methods for building the index from documents, inserting documents, and deleting documents.", "doc_id": null, "embedding": null, "extra_info": null, "index": 7, "child_indices": [0, 1, 2, 3, 4, 5, 6], "ref_doc_id": null, "node_info": null}}}, "docstore": {"docs": {"e627d6f084fdbaefa7f0a5c7d67f5efba7ae8b39": {"text": "\"\"\"Tree-based index.\"\"\"\n\nfrom typing import Any, Dict, Optional, Sequence, Type\n\nfrom gpt_index.data_structs.data_structs import IndexGraph\nfrom gpt_index.indices.base import DOCUMENTS_INPUT, BaseGPTIndex\nfrom gpt_index.indices.common.tree.base import GPTTreeIndexBuilder\nfrom gpt_index.indices.query.base import BaseGPTIndexQuery\nfrom gpt_index.indices.query.schema import QueryMode\nfrom gpt_index.indices.query.tree.embedding_query import GPTTreeIndexEmbeddingQuery\nfrom gpt_index.indices.query.tree.leaf_query import GPTTreeIndexLeafQuery\nfrom gpt_index.indices.query.tree.retrieve_query import GPTTreeIndexRetQuery\nfrom gpt_index.indices.query.tree.summarize_query import GPTTreeIndexSummarizeQuery\nfrom gpt_index.indices.tree.inserter import GPTIndexInserter\nfrom gpt_index.langchain_helpers.chain_wrapper import LLMPredictor\nfrom gpt_index.prompts.default_prompts import (\n    DEFAULT_INSERT_PROMPT,\n    DEFAULT_SUMMARY_PROMPT,\n)\nfrom gpt_index.prompts.prompts import SummaryPrompt, TreeInsertPrompt\nfrom gpt_index.schema import BaseDocument\n\nREQUIRE_TREE_MODES = {\n    QueryMode.DEFAULT,\n    QueryMode.EMBEDDING,\n    QueryMode.RETRIEVE,\n}\n\n\nclass GPTTreeIndex(BaseGPTIndex[IndexGraph]):\n    \"\"\"GPT Tree Index.\n\n    The tree index is a tree-structured index, where each node is a summary of\n    the children nodes. During index construction, the tree is constructed\n    in a bottoms-up fashion until we end up with a set of root_nodes.\n\n    There are a few different options during query time (see :ref:`Ref-Query`).\n    The main option is to traverse down the tree from the root nodes.\n    A secondary answer is to directly synthesize the answer from the root nodes.\n\n    Args:\n        summary_template (Optional[SummaryPrompt]): A Summarization Prompt\n            (see :ref:`Prompt-Templates`).\n        insert_prompt (Optional[TreeInsertPrompt]): An Tree Insertion Prompt\n            (see :ref:`Prompt-Templates`).\n        num_children (int): The number of children each node should have.\n        build_tree (bool): Whether to build the tree during index construction.\n\n    \"\"\"\n\n    index_struct_cls = IndexGraph\n\n    def __init__(\n        self,\n        documents: Optional[Sequence[DOCUMENTS_INPUT]] = None,\n        index_struct: Optional[IndexGraph] = None,\n        summary_template: Optional[SummaryPrompt] = None,\n        insert_prompt: Optional[TreeInsertPrompt] = None,\n        num_children: int = 10,\n        llm_predictor: Optional[LLMPredictor] = None,\n        build_tree: bool = True,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"Initialize params.\"\"\"\n        # need to set parameters before building index in base class.\n        self.num_children = num_children\n        self.summary_template = summary_template or DEFAULT_SUMMARY_PROMPT\n        self.insert_prompt: TreeInsertPrompt = insert_prompt or DEFAULT_INSERT_PROMPT\n        self.build_tree = build_tree\n        super().__init__(\n            documents=documents,\n            index_struct=index_struct,\n            llm_predictor=llm_predictor,\n            **kwargs,\n        )\n\n    @classmethod\n    def get_query_map(self) -> Dict[str, Type[BaseGPTIndexQuery]]:\n        \"\"\"Get query map.\"\"\"\n        return {\n            QueryMode.DEFAULT: GPTTreeIndexLeafQuery,\n            QueryMode.EMBEDDING: GPTTreeIndexEmbeddingQuery,\n            QueryMode.RETRIEVE: GPTTreeIndexRetQuery,\n            QueryMode.SUMMARIZE: GPTTreeIndexSummarizeQuery,\n        }\n\n    def _validate_build_tree_required(self, mode: QueryMode) -> None:\n        \"\"\"Check if index supports modes that require trees.\"\"\"\n        if mode in REQUIRE_TREE_MODES and not self.build_tree:\n            raise ValueError(\n                \"Index was constructed without building trees, \"\n                f\"but mode {mode} requires trees.\"\n            )\n\n    def _preprocess_query(self, mode: QueryMode, query_kwargs: Any) -> None:\n        \"\"\"Query mode to class.\"\"\"\n        super()._preprocess_query(mode, query_kwargs)\n        self._validate_build_tree_required(mode)\n\n    def _build_index_from_documents(\n        self, documents: Sequence[BaseDocument]\n    ) -> IndexGraph:\n        \"\"\"Build the index from documents.\"\"\"\n        # do simple concatenation\n        index_builder = GPTTreeIndexBuilder(\n            self.num_children,\n            self.summary_template,\n            self._llm_predictor,\n            self._prompt_helper,\n        )\n        index_graph = index_builder.build_from_text(\n            documents, build_tree=self.build_tree\n        )\n        return index_graph\n\n    def _insert(self, document: BaseDocument, **insert_kwargs: Any) -> None:\n        \"\"\"Insert a document.\"\"\"\n        # TODO: allow to customize insert prompt\n        inserter = GPTIndexInserter(\n            self.index_struct,\n            num_children=self.num_children,\n            insert_prompt=self.insert_prompt,\n            summary_prompt=self.summary_template,\n            llm_predictor=self._llm_predictor,\n            prompt_helper=self._prompt_helper,\n        )\n        inserter.insert(document)\n\n    def _delete(self, doc_id: str, **delete_kwargs: Any) -> None:\n        \"\"\"Delete a document.\"\"\"\n        raise NotImplementedError(\"Delete not implemented for tree index.\")\n", "doc_id": "e627d6f084fdbaefa7f0a5c7d67f5efba7ae8b39", "embedding": null, "extra_info": {"file_path": "gpt_index/indices/tree/base.py", "file_name": "base.py"}, "__type__": "Document"}, "c3a9ea9a-a3bf-4311-bebf-094b087ce03e": {"text": "\nThe GPTTreeIndex class is a tree-structured index used to store documents. It is built using a bottoms-up approach, with each node summarizing its children nodes. The class contains methods for building the index from documents, inserting documents, and deleting documents. It also contains parameters for the number of children each node should have, a summarization prompt, an insertion prompt, and a language model predictor. The class also contains methods for validating that the index supports modes that require trees and for preprocessing queries. The purpose of the code is to provide an efficient way to store and query documents, allowing for quick retrieval of relevant information.", "doc_id": "c3a9ea9a-a3bf-4311-bebf-094b087ce03e", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"Tree-based index.\"\"\"\n\nfrom typing import Any, Dict, Optional, Sequence, Type\n\nfrom gpt_index.data_structs.data_structs import IndexGraph\nfrom gpt_index.indices.base import DOCUMENTS_INPUT, BaseGPTIndex\nfrom gpt_index.indices.common.tree.base import GPTTreeIndexBuilder\nfrom gpt_index.indices.query.base import BaseGPTIndexQuery\nfrom gpt_index.indices.query.schema import QueryMode\nfrom gpt_index.indices.query.tree.embedding_query import GPTTreeIndexEmbeddingQuery\nfrom gpt_index.indices.query.tree.leaf_query import GPTTreeIndexLeafQuery\nfrom gpt_index.indices.query.tree.retrieve_query import GPTTreeIndexRetQuery\nfrom gpt_index.indices.query.tree.summarize_query import GPTTreeIndexSummarizeQuery\nfrom gpt_index.indices.tree.inserter import GPTIndexInserter\nfrom gpt_index.langchain_helpers.chain_wrapper import LLMPredictor\nfrom gpt_index.prompts.default_prompts import (\n    DEFAULT_INSERT_PROMPT,\n    DEFAULT_SUMMARY_PROMPT,\n)\nfrom gpt_index.prompts.prompts import SummaryPrompt, TreeInsertPrompt\nfrom", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/tree/base.py", "file_name": "base.py"}, "index": 0, "child_indices": [], "ref_doc_id": "e627d6f084fdbaefa7f0a5c7d67f5efba7ae8b39", "node_info": null}, "1": {"text": "import SummaryPrompt, TreeInsertPrompt\nfrom gpt_index.schema import BaseDocument\n\nREQUIRE_TREE_MODES = {\n    QueryMode.DEFAULT,\n    QueryMode.EMBEDDING,\n    QueryMode.RETRIEVE,\n}\n\n\nclass GPTTreeIndex(BaseGPTIndex[IndexGraph]):\n    \"\"\"GPT Tree Index.\n\n    The tree index is a tree-structured index, where each node is a summary of\n    the children nodes. During index construction, the tree is constructed\n    in a bottoms-up fashion until we end up with a set of root_nodes.\n\n    There are a few different options during query time (see :ref:`Ref-Query`).\n    The main option is to traverse down the tree from the root nodes.\n    A secondary answer is to directly synthesize the answer from the root nodes.\n\n    Args:\n        summary_template (Optional[SummaryPrompt]): A Summarization Prompt\n            (see :ref:`Prompt-Templates`).\n        insert_prompt (Optional[TreeInsertPrompt]): An Tree Insertion Prompt\n            (see :ref:`Prompt-Templates`).\n        num_children", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/tree/base.py", "file_name": "base.py"}, "index": 1, "child_indices": [], "ref_doc_id": "e627d6f084fdbaefa7f0a5c7d67f5efba7ae8b39", "node_info": null}, "2": {"text": "       num_children (int): The number of children each node should have.\n        build_tree (bool): Whether to build the tree during index construction.\n\n    \"\"\"\n\n    index_struct_cls = IndexGraph\n\n    def __init__(\n        self,\n        documents: Optional[Sequence[DOCUMENTS_INPUT]] = None,\n        index_struct: Optional[IndexGraph] = None,\n        summary_template: Optional[SummaryPrompt] = None,\n        insert_prompt: Optional[TreeInsertPrompt] = None,\n        num_children: int = 10,\n        llm_predictor: Optional[LLMPredictor] = None,\n        build_tree: bool = True,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"Initialize params.\"\"\"\n        # need to set parameters before building index in base class.\n        self.num_children = num_children\n        self.summary_template = summary_template or DEFAULT_SUMMARY_PROMPT\n        self.insert_prompt:", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/tree/base.py", "file_name": "base.py"}, "index": 2, "child_indices": [], "ref_doc_id": "e627d6f084fdbaefa7f0a5c7d67f5efba7ae8b39", "node_info": null}, "3": {"text": "       self.insert_prompt: TreeInsertPrompt = insert_prompt or DEFAULT_INSERT_PROMPT\n        self.build_tree = build_tree\n        super().__init__(\n            documents=documents,\n            index_struct=index_struct,\n            llm_predictor=llm_predictor,\n            **kwargs,\n        )\n\n    @classmethod\n    def get_query_map(self) -> Dict[str, Type[BaseGPTIndexQuery]]:\n        \"\"\"Get query map.\"\"\"\n        return {\n            QueryMode.DEFAULT: GPTTreeIndexLeafQuery,\n            QueryMode.EMBEDDING: GPTTreeIndexEmbeddingQuery,\n            QueryMode.RETRIEVE: GPTTreeIndexRetQuery,\n            QueryMode.SUMMARIZE: GPTTreeIndexSummarizeQuery,\n        }\n\n    def _validate_build_tree_required(self,", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/tree/base.py", "file_name": "base.py"}, "index": 3, "child_indices": [], "ref_doc_id": "e627d6f084fdbaefa7f0a5c7d67f5efba7ae8b39", "node_info": null}, "4": {"text": "  }\n\n    def _validate_build_tree_required(self, mode: QueryMode) -> None:\n        \"\"\"Check if index supports modes that require trees.\"\"\"\n        if mode in REQUIRE_TREE_MODES and not self.build_tree:\n            raise ValueError(\n                \"Index was constructed without building trees, \"\n                f\"but mode {mode} requires trees.\"\n            )\n\n    def _preprocess_query(self, mode: QueryMode, query_kwargs: Any) -> None:\n        \"\"\"Query mode to class.\"\"\"\n        super()._preprocess_query(mode, query_kwargs)\n        self._validate_build_tree_required(mode)\n\n    def _build_index_from_documents(\n        self, documents: Sequence[BaseDocument]\n    ) -> IndexGraph:\n        \"\"\"Build the index from documents.\"\"\"\n        # do simple concatenation\n        index_builder = GPTTreeIndexBuilder(\n         ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/tree/base.py", "file_name": "base.py"}, "index": 4, "child_indices": [], "ref_doc_id": "e627d6f084fdbaefa7f0a5c7d67f5efba7ae8b39", "node_info": null}, "5": {"text": "index_builder = GPTTreeIndexBuilder(\n            self.num_children,\n            self.summary_template,\n            self._llm_predictor,\n            self._prompt_helper,\n        )\n        index_graph = index_builder.build_from_text(\n            documents, build_tree=self.build_tree\n        )\n        return index_graph\n\n    def _insert(self, document: BaseDocument, **insert_kwargs: Any) -> None:\n        \"\"\"Insert a document.\"\"\"\n        # TODO: allow to customize insert prompt\n        inserter = GPTIndexInserter(\n            self.index_struct,\n            num_children=self.num_children,\n            insert_prompt=self.insert_prompt,\n            summary_prompt=self.summary_template,\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/tree/base.py", "file_name": "base.py"}, "index": 5, "child_indices": [], "ref_doc_id": "e627d6f084fdbaefa7f0a5c7d67f5efba7ae8b39", "node_info": null}, "6": {"text": "           llm_predictor=self._llm_predictor,\n            prompt_helper=self._prompt_helper,\n        )\n        inserter.insert(document)\n\n    def _delete(self, doc_id: str, **delete_kwargs: Any) -> None:\n        \"\"\"Delete a document.\"\"\"\n        raise NotImplementedError(\"Delete not implemented for tree index.\")\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/indices/tree/base.py", "file_name": "base.py"}, "index": 6, "child_indices": [], "ref_doc_id": "e627d6f084fdbaefa7f0a5c7d67f5efba7ae8b39", "node_info": null}, "7": {"text": "This code file contains the GPTTreeIndex class, which is a tree-structured index used to store documents. It is built in a bottoms-up fashion, with each node being a summary of its children nodes. During query time, the tree can be traversed from the root nodes or the answer can be synthesized from the root nodes. The class also contains methods for building the index from documents, inserting documents, and deleting documents.", "doc_id": null, "embedding": null, "extra_info": null, "index": 7, "child_indices": [0, 1, 2, 3, 4, 5, 6], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"7": {"text": "This code file contains the GPTTreeIndex class, which is a tree-structured index used to store documents. It is built in a bottoms-up fashion, with each node being a summary of its children nodes. During query time, the tree can be traversed from the root nodes or the answer can be synthesized from the root nodes. The class also contains methods for building the index from documents, inserting documents, and deleting documents.", "doc_id": null, "embedding": null, "extra_info": null, "index": 7, "child_indices": [0, 1, 2, 3, 4, 5, 6], "ref_doc_id": null, "node_info": null}}, "__type__": "tree"}}}}