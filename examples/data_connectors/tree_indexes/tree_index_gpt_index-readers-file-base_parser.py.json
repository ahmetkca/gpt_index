{"index_struct": {"text": "\nThis code file contains the BaseParser class, which is a base class for all parsers. It provides methods for initializing the parser with a config, checking if the parser config is set, and parsing a file. The class uses the abc module to define abstract methods, and the pathlib module to work with file paths. The data structures used are dictionaries and lists. The purpose of this code is to provide a base class for all parsers, with methods for initializing the parser, checking if the parser config is set, and parsing a file. The BaseParser class provides a framework for creating parsers that can be used to read and interpret data from files. The abc module is used to define abstract methods, and the pathlib module is used to work with file paths. The data structures used are dictionaries and lists, which are used to store and manipulate the data. The code provides a way to easily create parsers that can be used to read and interpret data from files.", "doc_id": "f6630316-f16b-4b8a-bca2-beae4a010a1e", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"Base parser and config class.\"\"\"\n\nfrom abc import abstractmethod\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Union\n\n\nclass BaseParser:\n    \"\"\"Base class for all parsers.\"\"\"\n\n    def __init__(self, parser_config: Optional[Dict] = None):\n        \"\"\"Init params.\"\"\"\n        self._parser_config = parser_config\n\n    def init_parser(self) -> None:\n        \"\"\"Init parser and store it.\"\"\"\n        parser_config = self._init_parser()\n        self._parser_config = parser_config\n\n    @property\n    def parser_config_set(self) -> bool:\n        \"\"\"Check if parser config is set.\"\"\"\n        return self._parser_config is not None\n\n    @property\n    def parser_config(self) -> Dict:\n        \"\"\"Check if parser config is set.\"\"\"\n        if self._parser_config is None:\n            raise ValueError(\"Parser config not set.\")\n        return self._parser_config\n\n    @abstractmethod\n    def _init_parser(self) -> Dict:\n  ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/file/base_parser.py", "file_name": "base_parser.py"}, "index": 0, "child_indices": [], "ref_doc_id": "753a56f9797432f053fb96a72bdb782a2b20bd05", "node_info": null}, "1": {"text": "   def _init_parser(self) -> Dict:\n        \"\"\"Initialize the parser with the config.\"\"\"\n\n    @abstractmethod\n    def parse_file(self, file: Path, errors: str = \"ignore\") -> Union[str, List[str]]:\n        \"\"\"Parse file.\"\"\"\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/file/base_parser.py", "file_name": "base_parser.py"}, "index": 1, "child_indices": [], "ref_doc_id": "753a56f9797432f053fb96a72bdb782a2b20bd05", "node_info": null}, "2": {"text": "This code file contains the BaseParser class, which is a base class for all parsers. It contains methods for initializing the parser with a config, checking if the parser config is set, and parsing a file. The class uses the abc module to define abstract methods, and the pathlib module to work with file paths. The data structures used are dictionaries and lists.\n\nThe purpose of this code is to provide a base class for all parsers, with methods for initializing the parser, checking if the parser config is set, and parsing a file.\n\"\"\"", "doc_id": null, "embedding": null, "extra_info": null, "index": 2, "child_indices": [0, 1], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"2": {"text": "This code file contains the BaseParser class, which is a base class for all parsers. It contains methods for initializing the parser with a config, checking if the parser config is set, and parsing a file. The class uses the abc module to define abstract methods, and the pathlib module to work with file paths. The data structures used are dictionaries and lists.\n\nThe purpose of this code is to provide a base class for all parsers, with methods for initializing the parser, checking if the parser config is set, and parsing a file.\n\"\"\"", "doc_id": null, "embedding": null, "extra_info": null, "index": 2, "child_indices": [0, 1], "ref_doc_id": null, "node_info": null}}}, "docstore": {"docs": {"753a56f9797432f053fb96a72bdb782a2b20bd05": {"text": "\"\"\"Base parser and config class.\"\"\"\n\nfrom abc import abstractmethod\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Union\n\n\nclass BaseParser:\n    \"\"\"Base class for all parsers.\"\"\"\n\n    def __init__(self, parser_config: Optional[Dict] = None):\n        \"\"\"Init params.\"\"\"\n        self._parser_config = parser_config\n\n    def init_parser(self) -> None:\n        \"\"\"Init parser and store it.\"\"\"\n        parser_config = self._init_parser()\n        self._parser_config = parser_config\n\n    @property\n    def parser_config_set(self) -> bool:\n        \"\"\"Check if parser config is set.\"\"\"\n        return self._parser_config is not None\n\n    @property\n    def parser_config(self) -> Dict:\n        \"\"\"Check if parser config is set.\"\"\"\n        if self._parser_config is None:\n            raise ValueError(\"Parser config not set.\")\n        return self._parser_config\n\n    @abstractmethod\n    def _init_parser(self) -> Dict:\n        \"\"\"Initialize the parser with the config.\"\"\"\n\n    @abstractmethod\n    def parse_file(self, file: Path, errors: str = \"ignore\") -> Union[str, List[str]]:\n        \"\"\"Parse file.\"\"\"\n", "doc_id": "753a56f9797432f053fb96a72bdb782a2b20bd05", "embedding": null, "extra_info": {"file_path": "gpt_index/readers/file/base_parser.py", "file_name": "base_parser.py"}, "__type__": "Document"}, "f6630316-f16b-4b8a-bca2-beae4a010a1e": {"text": "\nThis code file contains the BaseParser class, which is a base class for all parsers. It provides methods for initializing the parser with a config, checking if the parser config is set, and parsing a file. The class uses the abc module to define abstract methods, and the pathlib module to work with file paths. The data structures used are dictionaries and lists. The purpose of this code is to provide a base class for all parsers, with methods for initializing the parser, checking if the parser config is set, and parsing a file. The BaseParser class provides a framework for creating parsers that can be used to read and interpret data from files. The abc module is used to define abstract methods, and the pathlib module is used to work with file paths. The data structures used are dictionaries and lists, which are used to store and manipulate the data. The code provides a way to easily create parsers that can be used to read and interpret data from files.", "doc_id": "f6630316-f16b-4b8a-bca2-beae4a010a1e", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"Base parser and config class.\"\"\"\n\nfrom abc import abstractmethod\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Union\n\n\nclass BaseParser:\n    \"\"\"Base class for all parsers.\"\"\"\n\n    def __init__(self, parser_config: Optional[Dict] = None):\n        \"\"\"Init params.\"\"\"\n        self._parser_config = parser_config\n\n    def init_parser(self) -> None:\n        \"\"\"Init parser and store it.\"\"\"\n        parser_config = self._init_parser()\n        self._parser_config = parser_config\n\n    @property\n    def parser_config_set(self) -> bool:\n        \"\"\"Check if parser config is set.\"\"\"\n        return self._parser_config is not None\n\n    @property\n    def parser_config(self) -> Dict:\n        \"\"\"Check if parser config is set.\"\"\"\n        if self._parser_config is None:\n            raise ValueError(\"Parser config not set.\")\n        return self._parser_config\n\n    @abstractmethod\n    def _init_parser(self) -> Dict:\n  ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/file/base_parser.py", "file_name": "base_parser.py"}, "index": 0, "child_indices": [], "ref_doc_id": "753a56f9797432f053fb96a72bdb782a2b20bd05", "node_info": null}, "1": {"text": "   def _init_parser(self) -> Dict:\n        \"\"\"Initialize the parser with the config.\"\"\"\n\n    @abstractmethod\n    def parse_file(self, file: Path, errors: str = \"ignore\") -> Union[str, List[str]]:\n        \"\"\"Parse file.\"\"\"\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/file/base_parser.py", "file_name": "base_parser.py"}, "index": 1, "child_indices": [], "ref_doc_id": "753a56f9797432f053fb96a72bdb782a2b20bd05", "node_info": null}, "2": {"text": "This code file contains the BaseParser class, which is a base class for all parsers. It contains methods for initializing the parser with a config, checking if the parser config is set, and parsing a file. The class uses the abc module to define abstract methods, and the pathlib module to work with file paths. The data structures used are dictionaries and lists.\n\nThe purpose of this code is to provide a base class for all parsers, with methods for initializing the parser, checking if the parser config is set, and parsing a file.\n\"\"\"", "doc_id": null, "embedding": null, "extra_info": null, "index": 2, "child_indices": [0, 1], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"2": {"text": "This code file contains the BaseParser class, which is a base class for all parsers. It contains methods for initializing the parser with a config, checking if the parser config is set, and parsing a file. The class uses the abc module to define abstract methods, and the pathlib module to work with file paths. The data structures used are dictionaries and lists.\n\nThe purpose of this code is to provide a base class for all parsers, with methods for initializing the parser, checking if the parser config is set, and parsing a file.\n\"\"\"", "doc_id": null, "embedding": null, "extra_info": null, "index": 2, "child_indices": [0, 1], "ref_doc_id": null, "node_info": null}}, "__type__": "tree"}}}}