{"index_struct": {"text": "\nMboxParser is a code file that provides a parser for mbox files. It uses the BaseParser class to extract messages from mailbox files and the BeautifulSoup library to parse HTML content. The code returns a string including date, subject, sender, receiver and content for each message, and the max_count parameter can be used to limit the number of messages returned. The purpose of the code is to parse mbox files and extract the relevant information from each message, such as the date, sender, receiver, subject, and content. The code is designed to be easy to use and understand, and it provides a convenient way to parse mbox files and extract the desired information.", "doc_id": "bd63f988-df0d-4f29-81e9-40e5af7340a2", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"Mbox parser.\n\nContains simple parser for mbox files.\n\n\"\"\"\nfrom pathlib import Path\nfrom typing import Any, Dict, List\n\nfrom gpt_index.readers.file.base_parser import BaseParser\n\n\nclass MboxParser(BaseParser):\n    \"\"\"Mbox parser.\n\n    Extract messages from mailbox files.\n    Returns string including date, subject, sender, receiver and\n    content for each message.\n\n    \"\"\"\n\n    DEFAULT_MESSAGE_FORMAT: str = (\n        \"Date: {_date}\\n\"\n        \"From: {_from}\\n\"\n        \"To: {_to}\\n\"\n        \"Subject: {_subject}\\n\"\n        \"Content: {_content}\"\n    )\n\n    def __init__(\n        self,\n        *args: Any,\n        max_count: int = 0,\n        message_format: str = DEFAULT_MESSAGE_FORMAT,\n        **kwargs: Any\n    ) -> None:\n        \"\"\"Init params.\"\"\"\n       ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/file/mbox_parser.py", "file_name": "mbox_parser.py"}, "index": 0, "child_indices": [], "ref_doc_id": "29f2fc552f2d6f0ec85e8fb06255667555ac9e94", "node_info": null}, "1": {"text": "       \"\"\"Init params.\"\"\"\n        super().__init__(*args, **kwargs)\n        self.max_count = max_count\n        self.message_format = message_format\n\n    def _init_parser(self) -> Dict:\n        \"\"\"Initialize parser.\"\"\"\n        try:\n            from bs4 import BeautifulSoup  # noqa: F401\n        except ImportError:\n            raise ValueError(\n                \"`beautifulsoup4` package not found,\"\n                \"please run `pip install beautifulsoup4`\"\n            )\n        return {}\n\n    def parse_file(self, filepath: Path, errors: str = \"ignore\") -> List[str]:\n        \"\"\"Parse file into string.\"\"\"\n        # Import required libraries\n        import mailbox\n        from email.parser import BytesParser\n        from email.policy import default\n\n   ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/file/mbox_parser.py", "file_name": "mbox_parser.py"}, "index": 1, "child_indices": [], "ref_doc_id": "29f2fc552f2d6f0ec85e8fb06255667555ac9e94", "node_info": null}, "2": {"text": "BytesParser\n        from email.policy import default\n\n        from bs4 import BeautifulSoup\n\n        i = 0\n        results: List[str] = []\n        # Load file using mailbox\n        bytes_parser = BytesParser(policy=default).parse\n        mbox = mailbox.mbox(filepath, factory=bytes_parser)  # type: ignore\n\n        # Iterate through all messages\n        for _, _msg in enumerate(mbox):\n            msg: mailbox.mboxMessage = _msg\n            # Parse multipart messages\n            if msg.is_multipart():\n                for part in msg.walk():\n                    ctype = part.get_content_type()\n                    cdispo = str(part.get(\"Content-Disposition\"))\n                    if ctype == \"text/plain\" and", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/file/mbox_parser.py", "file_name": "mbox_parser.py"}, "index": 2, "child_indices": [], "ref_doc_id": "29f2fc552f2d6f0ec85e8fb06255667555ac9e94", "node_info": null}, "3": {"text": "          if ctype == \"text/plain\" and \"attachment\" not in cdispo:\n                        content = part.get_payload(decode=True)  # decode\n                        break\n            # Get plain message payload for non-multipart messages\n            else:\n                content = msg.get_payload(decode=True)\n\n            # Parse message HTML content and remove unneeded whitespace\n            soup = BeautifulSoup(content)\n            stripped_content = \" \".join(soup.get_text().split())\n            # Format message to include date, sender, receiver and subject\n            msg_string = self.message_format.format(\n                _date=msg[\"date\"],\n                _from=msg[\"from\"],\n   ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/file/mbox_parser.py", "file_name": "mbox_parser.py"}, "index": 3, "child_indices": [], "ref_doc_id": "29f2fc552f2d6f0ec85e8fb06255667555ac9e94", "node_info": null}, "4": {"text": "         _from=msg[\"from\"],\n                _to=msg[\"to\"],\n                _subject=msg[\"subject\"],\n                _content=stripped_content,\n            )\n            # Add message string to results\n            results.append(msg_string)\n            # Increment counter and return if max count is met\n            i += 1\n            if self.max_count > 0 and i >= self.max_count:\n                break\n        return results\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/file/mbox_parser.py", "file_name": "mbox_parser.py"}, "index": 4, "child_indices": [], "ref_doc_id": "29f2fc552f2d6f0ec85e8fb06255667555ac9e94", "node_info": null}, "5": {"text": "Mbox parser is a code file that contains a parser for mbox files. It uses the BaseParser class to extract messages from mailbox files and returns a string including date, subject, sender, receiver and content for each message. It also uses the BeautifulSoup library to parse HTML content and remove unneeded whitespace. The code also has a max_count parameter that can be used to limit the number of messages returned.", "doc_id": null, "embedding": null, "extra_info": null, "index": 5, "child_indices": [0, 1, 2, 3, 4], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"5": {"text": "Mbox parser is a code file that contains a parser for mbox files. It uses the BaseParser class to extract messages from mailbox files and returns a string including date, subject, sender, receiver and content for each message. It also uses the BeautifulSoup library to parse HTML content and remove unneeded whitespace. The code also has a max_count parameter that can be used to limit the number of messages returned.", "doc_id": null, "embedding": null, "extra_info": null, "index": 5, "child_indices": [0, 1, 2, 3, 4], "ref_doc_id": null, "node_info": null}}}, "docstore": {"docs": {"29f2fc552f2d6f0ec85e8fb06255667555ac9e94": {"text": "\"\"\"Mbox parser.\n\nContains simple parser for mbox files.\n\n\"\"\"\nfrom pathlib import Path\nfrom typing import Any, Dict, List\n\nfrom gpt_index.readers.file.base_parser import BaseParser\n\n\nclass MboxParser(BaseParser):\n    \"\"\"Mbox parser.\n\n    Extract messages from mailbox files.\n    Returns string including date, subject, sender, receiver and\n    content for each message.\n\n    \"\"\"\n\n    DEFAULT_MESSAGE_FORMAT: str = (\n        \"Date: {_date}\\n\"\n        \"From: {_from}\\n\"\n        \"To: {_to}\\n\"\n        \"Subject: {_subject}\\n\"\n        \"Content: {_content}\"\n    )\n\n    def __init__(\n        self,\n        *args: Any,\n        max_count: int = 0,\n        message_format: str = DEFAULT_MESSAGE_FORMAT,\n        **kwargs: Any\n    ) -> None:\n        \"\"\"Init params.\"\"\"\n        super().__init__(*args, **kwargs)\n        self.max_count = max_count\n        self.message_format = message_format\n\n    def _init_parser(self) -> Dict:\n        \"\"\"Initialize parser.\"\"\"\n        try:\n            from bs4 import BeautifulSoup  # noqa: F401\n        except ImportError:\n            raise ValueError(\n                \"`beautifulsoup4` package not found,\"\n                \"please run `pip install beautifulsoup4`\"\n            )\n        return {}\n\n    def parse_file(self, filepath: Path, errors: str = \"ignore\") -> List[str]:\n        \"\"\"Parse file into string.\"\"\"\n        # Import required libraries\n        import mailbox\n        from email.parser import BytesParser\n        from email.policy import default\n\n        from bs4 import BeautifulSoup\n\n        i = 0\n        results: List[str] = []\n        # Load file using mailbox\n        bytes_parser = BytesParser(policy=default).parse\n        mbox = mailbox.mbox(filepath, factory=bytes_parser)  # type: ignore\n\n        # Iterate through all messages\n        for _, _msg in enumerate(mbox):\n            msg: mailbox.mboxMessage = _msg\n            # Parse multipart messages\n            if msg.is_multipart():\n                for part in msg.walk():\n                    ctype = part.get_content_type()\n                    cdispo = str(part.get(\"Content-Disposition\"))\n                    if ctype == \"text/plain\" and \"attachment\" not in cdispo:\n                        content = part.get_payload(decode=True)  # decode\n                        break\n            # Get plain message payload for non-multipart messages\n            else:\n                content = msg.get_payload(decode=True)\n\n            # Parse message HTML content and remove unneeded whitespace\n            soup = BeautifulSoup(content)\n            stripped_content = \" \".join(soup.get_text().split())\n            # Format message to include date, sender, receiver and subject\n            msg_string = self.message_format.format(\n                _date=msg[\"date\"],\n                _from=msg[\"from\"],\n                _to=msg[\"to\"],\n                _subject=msg[\"subject\"],\n                _content=stripped_content,\n            )\n            # Add message string to results\n            results.append(msg_string)\n            # Increment counter and return if max count is met\n            i += 1\n            if self.max_count > 0 and i >= self.max_count:\n                break\n        return results\n", "doc_id": "29f2fc552f2d6f0ec85e8fb06255667555ac9e94", "embedding": null, "extra_info": {"file_path": "gpt_index/readers/file/mbox_parser.py", "file_name": "mbox_parser.py"}, "__type__": "Document"}, "bd63f988-df0d-4f29-81e9-40e5af7340a2": {"text": "\nMboxParser is a code file that provides a parser for mbox files. It uses the BaseParser class to extract messages from mailbox files and the BeautifulSoup library to parse HTML content. The code returns a string including date, subject, sender, receiver and content for each message, and the max_count parameter can be used to limit the number of messages returned. The purpose of the code is to parse mbox files and extract the relevant information from each message, such as the date, sender, receiver, subject, and content. The code is designed to be easy to use and understand, and it provides a convenient way to parse mbox files and extract the desired information.", "doc_id": "bd63f988-df0d-4f29-81e9-40e5af7340a2", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"Mbox parser.\n\nContains simple parser for mbox files.\n\n\"\"\"\nfrom pathlib import Path\nfrom typing import Any, Dict, List\n\nfrom gpt_index.readers.file.base_parser import BaseParser\n\n\nclass MboxParser(BaseParser):\n    \"\"\"Mbox parser.\n\n    Extract messages from mailbox files.\n    Returns string including date, subject, sender, receiver and\n    content for each message.\n\n    \"\"\"\n\n    DEFAULT_MESSAGE_FORMAT: str = (\n        \"Date: {_date}\\n\"\n        \"From: {_from}\\n\"\n        \"To: {_to}\\n\"\n        \"Subject: {_subject}\\n\"\n        \"Content: {_content}\"\n    )\n\n    def __init__(\n        self,\n        *args: Any,\n        max_count: int = 0,\n        message_format: str = DEFAULT_MESSAGE_FORMAT,\n        **kwargs: Any\n    ) -> None:\n        \"\"\"Init params.\"\"\"\n       ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/file/mbox_parser.py", "file_name": "mbox_parser.py"}, "index": 0, "child_indices": [], "ref_doc_id": "29f2fc552f2d6f0ec85e8fb06255667555ac9e94", "node_info": null}, "1": {"text": "       \"\"\"Init params.\"\"\"\n        super().__init__(*args, **kwargs)\n        self.max_count = max_count\n        self.message_format = message_format\n\n    def _init_parser(self) -> Dict:\n        \"\"\"Initialize parser.\"\"\"\n        try:\n            from bs4 import BeautifulSoup  # noqa: F401\n        except ImportError:\n            raise ValueError(\n                \"`beautifulsoup4` package not found,\"\n                \"please run `pip install beautifulsoup4`\"\n            )\n        return {}\n\n    def parse_file(self, filepath: Path, errors: str = \"ignore\") -> List[str]:\n        \"\"\"Parse file into string.\"\"\"\n        # Import required libraries\n        import mailbox\n        from email.parser import BytesParser\n        from email.policy import default\n\n   ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/file/mbox_parser.py", "file_name": "mbox_parser.py"}, "index": 1, "child_indices": [], "ref_doc_id": "29f2fc552f2d6f0ec85e8fb06255667555ac9e94", "node_info": null}, "2": {"text": "BytesParser\n        from email.policy import default\n\n        from bs4 import BeautifulSoup\n\n        i = 0\n        results: List[str] = []\n        # Load file using mailbox\n        bytes_parser = BytesParser(policy=default).parse\n        mbox = mailbox.mbox(filepath, factory=bytes_parser)  # type: ignore\n\n        # Iterate through all messages\n        for _, _msg in enumerate(mbox):\n            msg: mailbox.mboxMessage = _msg\n            # Parse multipart messages\n            if msg.is_multipart():\n                for part in msg.walk():\n                    ctype = part.get_content_type()\n                    cdispo = str(part.get(\"Content-Disposition\"))\n                    if ctype == \"text/plain\" and", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/file/mbox_parser.py", "file_name": "mbox_parser.py"}, "index": 2, "child_indices": [], "ref_doc_id": "29f2fc552f2d6f0ec85e8fb06255667555ac9e94", "node_info": null}, "3": {"text": "          if ctype == \"text/plain\" and \"attachment\" not in cdispo:\n                        content = part.get_payload(decode=True)  # decode\n                        break\n            # Get plain message payload for non-multipart messages\n            else:\n                content = msg.get_payload(decode=True)\n\n            # Parse message HTML content and remove unneeded whitespace\n            soup = BeautifulSoup(content)\n            stripped_content = \" \".join(soup.get_text().split())\n            # Format message to include date, sender, receiver and subject\n            msg_string = self.message_format.format(\n                _date=msg[\"date\"],\n                _from=msg[\"from\"],\n   ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/file/mbox_parser.py", "file_name": "mbox_parser.py"}, "index": 3, "child_indices": [], "ref_doc_id": "29f2fc552f2d6f0ec85e8fb06255667555ac9e94", "node_info": null}, "4": {"text": "         _from=msg[\"from\"],\n                _to=msg[\"to\"],\n                _subject=msg[\"subject\"],\n                _content=stripped_content,\n            )\n            # Add message string to results\n            results.append(msg_string)\n            # Increment counter and return if max count is met\n            i += 1\n            if self.max_count > 0 and i >= self.max_count:\n                break\n        return results\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/file/mbox_parser.py", "file_name": "mbox_parser.py"}, "index": 4, "child_indices": [], "ref_doc_id": "29f2fc552f2d6f0ec85e8fb06255667555ac9e94", "node_info": null}, "5": {"text": "Mbox parser is a code file that contains a parser for mbox files. It uses the BaseParser class to extract messages from mailbox files and returns a string including date, subject, sender, receiver and content for each message. It also uses the BeautifulSoup library to parse HTML content and remove unneeded whitespace. The code also has a max_count parameter that can be used to limit the number of messages returned.", "doc_id": null, "embedding": null, "extra_info": null, "index": 5, "child_indices": [0, 1, 2, 3, 4], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"5": {"text": "Mbox parser is a code file that contains a parser for mbox files. It uses the BaseParser class to extract messages from mailbox files and returns a string including date, subject, sender, receiver and content for each message. It also uses the BeautifulSoup library to parse HTML content and remove unneeded whitespace. The code also has a max_count parameter that can be used to limit the number of messages returned.", "doc_id": null, "embedding": null, "extra_info": null, "index": 5, "child_indices": [0, 1, 2, 3, 4], "ref_doc_id": null, "node_info": null}}, "__type__": "tree"}}}}