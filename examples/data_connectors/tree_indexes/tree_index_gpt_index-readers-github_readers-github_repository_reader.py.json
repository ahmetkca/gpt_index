{"index_struct": {"text": "\nThis code file is a Python script that reads data from a GitHub repository. It uses the GithubRepositoryReader class to read data from a specified commit or branch. The GithubRepositoryReader class uses a tree data structure to recursively traverse the repository and extract the files. It also uses a BufferedGitBlobDataIterator to make concurrent requests to the GitHub API. The data is parsed using a parser and stored in a Document object. The code also includes a timeit decorator to measure the time taken to run a function. The parser can parse supported files and generate documents from them. The code also has a function to decode the files as base64 and utf-8 and generate documents from them. The GithubRepositoryReader class has methods to recurse through the tree of files in the repository, generate documents from the files, and parse supported files. The class also has variables to store the owner, repo, verbose, ignore_directories, ignore_file_extensions, concurrent_requests, and use_parser. The code provides two examples of how to use the GithubRepositoryReader class to read data from a commit or branch. The purpose of the code is to read and parse files from a Github repository and generate", "doc_id": "7f450286-03ad-45a0-970a-cb1efc605427", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"\nGithub repository reader.\n\nRetrieves the contents of a Github repository and returns a list of documents.\nThe documents are either the contents of the files in the repository or\nthe text extracted from the files using the parser.\n\"\"\"\n\nimport asyncio\nimport base64\nimport binascii\nimport logging\nimport os\nimport pathlib\nimport tempfile\nfrom typing import Any, Callable, List, Optional, Tuple\n\nfrom gpt_index.readers.base import BaseReader\nfrom gpt_index.readers.file.base import DEFAULT_FILE_EXTRACTOR\nfrom gpt_index.readers.github_readers.github_api_client import (\n    GitBranchResponseModel,\n    GitCommitResponseModel,\n    GithubClient,\n    GitTreeResponseModel,\n)\nfrom gpt_index.readers.github_readers.utils import (\n    BufferedGitBlobDataIterator,\n    get_file_extension,\n    print_if_verbose,\n)\nfrom gpt_index.readers.schema.base import Document\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass GithubRepositoryReader(BaseReader):\n    \"\"\"\n  ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 0, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "1": {"text": "GithubRepositoryReader(BaseReader):\n    \"\"\"\n    Github repository reader.\n\n    Retrieves the contents of a Github repository and returns a list of documents.\n    The documents are either the contents of the files in the repository or the text\n    extracted from the files using the parser.\n\n    Examples:\n        >>> reader = GithubRepositoryReader(\"owner\", \"repo\")\n        >>> branch_documents = reader.load_data(branch=\"branch\")\n        >>> commit_documents = reader.load_data(commit_sha=\"commit_sha\")\n\n    \"\"\"\n\n    def __init__(\n        self,\n        owner: str,\n        repo: str,\n        use_parser: bool = True,\n        verbose: bool = False,\n        github_token: Optional[str] = None,\n        concurrent_requests: int = 5,\n        ignore_file_extensions: Optional[List[str]] = None,\n        ignore_directories: Optional[List[str]] = None,\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 1, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "2": {"text": "     ignore_directories: Optional[List[str]] = None,\n    ):\n        \"\"\"\n        Initialize params.\n\n        Args:\n            - owner (str): Owner of the repository.\n            - repo (str): Name of the repository.\n            - use_parser (bool): Whether to use the parser to extract\n                the text from the files.\n            - verbose (bool): Whether to print verbose messages.\n            - github_token (str): Github token. If not provided,\n                it will be read from the GITHUB_TOKEN environment variable.\n            - concurrent_requests (int): Number of concurrent requests to\n                make to the Github API.\n            - ignore_file_extensions (List[str]): List of file extensions to ignore.\n             ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 2, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "3": {"text": "file extensions to ignore.\n                i.e. ['.png', '.jpg']\n            - ignore_directories (List[str]): List of directories to ignore.\n                i.e. ['node_modules', 'dist']\n\n        Raises:\n            - `ValueError`: If the github_token is not provided and\n                the GITHUB_TOKEN environment variable is not set.\n        \"\"\"\n        super().__init__()\n        if github_token is None:\n            github_token = os.getenv(\"GITHUB_TOKEN\")\n            if github_token is None:\n                raise ValueError(\n                    \"Please provide a Github token. \"\n                    \"You can do so by passing it as an argument or\"\n       ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 3, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "4": {"text": "can do so by passing it as an argument or\"\n                    + \"by setting the GITHUB_TOKEN environment variable.\"\n                )\n\n        self._owner = owner\n        self._repo = repo\n        self._use_parser = use_parser\n        self._verbose = verbose\n        self._concurrent_requests = concurrent_requests\n        self._ignore_file_extensions = ignore_file_extensions\n        self._ignore_directories = ignore_directories\n\n        # Set up the event loop\n        try:\n            self._loop = asyncio.get_running_loop()\n        except RuntimeError:\n            # If there is no running loop, create a new one\n            self._loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(self._loop)\n\n        self._client", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 4, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "5": {"text": "       self._client = GithubClient(github_token)\n\n    def _load_data_from_commit(self, commit_sha: str) -> List[Document]:\n        \"\"\"\n        Load data from a commit.\n\n        Loads github repository data from a specific commit sha.\n\n        :param `commit`: commit sha\n\n        :return: list of documents\n        \"\"\"\n        commit_response: GitCommitResponseModel = self._loop.run_until_complete(\n            self._client.get_commit(self._owner, self._repo, commit_sha)\n        )\n\n        tree_sha = commit_response.commit.tree.sha\n        blobs_and_paths = self._loop.run_until_complete(self._recurse_tree(tree_sha))\n\n        print_if_verbose(self._verbose, f\"got {len(blobs_and_paths)} blobs\")\n\n        return self._loop.run_until_complete(\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 5, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "6": {"text": "           self._generate_documents(blobs_and_paths=blobs_and_paths)\n        )\n\n    def _load_data_from_branch(self, branch: str) -> List[Document]:\n        \"\"\"\n        Load data from a branch.\n\n        Loads github repository data from a specific branch.\n\n        :param `branch`: branch name\n\n        :return: list of documents\n        \"\"\"\n        branch_data: GitBranchResponseModel = self._loop.run_until_complete(\n            self._client.get_branch(self._owner, self._repo, branch)\n        )\n\n        tree_sha = branch_data.commit.commit.tree.sha\n        blobs_and_paths = self._loop.run_until_complete(self._recurse_tree(tree_sha))\n\n        print_if_verbose(self._verbose, f\"got {len(blobs_and_paths)} blobs\")\n\n      ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 6, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "7": {"text": "blobs\")\n\n        return self._loop.run_until_complete(\n            self._generate_documents(blobs_and_paths=blobs_and_paths)\n        )\n\n    def load_data(\n        self,\n        commit_sha: Optional[str] = None,\n        branch: Optional[str] = None,\n    ) -> List[Document]:\n        \"\"\"\n        Load data from a commit or a branch.\n\n        Loads github repository data from a specific commit sha or a branch.\n\n        :param `commit`: commit sha\n        :param `branch`: branch name\n\n        :return: list of documents\n        \"\"\"\n        if commit_sha is not None and branch is not None:\n            raise ValueError(\"You can only specify one of commit or branch.\")\n\n        if commit_sha is None and branch is None:\n            raise ValueError(\"You must specify one of", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 7, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "8": {"text": "          raise ValueError(\"You must specify one of commit or branch.\")\n\n        if commit_sha is not None:\n            return self._load_data_from_commit(commit_sha)\n\n        if branch is not None:\n            return self._load_data_from_branch(branch)\n\n        raise ValueError(\"You must specify one of commit or branch.\")\n\n    async def _recurse_tree(\n        self, tree_sha: str, current_path: str = \"\", current_depth: int = 0\n    ) -> Any:\n        \"\"\"\n        Recursively get all blob tree objects in a tree.\n\n        And construct their full path relative to the root of the repository.\n        (see GitTreeResponseModel.GitTreeObject in\n            github_api_client.py for more information)\n\n        :param `tree_sha`: sha of the tree to recurse\n        :param `current_path`: current path of the tree\n       ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 8, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "9": {"text": "`current_path`: current path of the tree\n        :param `current_depth`: current depth of the tree\n        :return: list of tuples of\n            (tree object, file's full path realtive to the root of the repo)\n        \"\"\"\n        blobs_and_full_paths: List[Tuple[GitTreeResponseModel.GitTreeObject, str]] = []\n        print_if_verbose(\n            self._verbose, \"\\t\" * current_depth + f\"current path: {current_path}\"\n        )\n\n        tree_data: GitTreeResponseModel = await self._client.get_tree(\n            self._owner, self._repo, tree_sha\n        )\n        print_if_verbose(\n            self._verbose, \"\\t\" * current_depth + f\"processing tree {tree_sha}\"\n        )\n        for tree_obj in tree_data.tree:\n         ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 9, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "10": {"text": "tree_obj in tree_data.tree:\n            file_path = os.path.join(current_path, tree_obj.path)\n            if tree_obj.type == \"tree\":\n                print_if_verbose(\n                    self._verbose,\n                    \"\\t\" * current_depth + f\"recursing into {tree_obj.path}\",\n                )\n                if self._ignore_directories is not None:\n                    if file_path in self._ignore_directories:\n                        print_if_verbose(\n                            self._verbose,\n                            \"\\t\" * current_depth\n   ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 10, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "11": {"text": "        \"\\t\" * current_depth\n                            + f\"ignoring tree {tree_obj.path} due to directory\",\n                        )\n                        continue\n\n                blobs_and_full_paths.extend(\n                    await self._recurse_tree(tree_obj.sha, file_path, current_depth + 1)\n                )\n            elif tree_obj.type == \"blob\":\n                print_if_verbose(\n                    self._verbose, \"\\t\" * current_depth + f\"found blob {tree_obj.path}\"\n                )\n                if", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 11, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "12": {"text": "  )\n                if self._ignore_file_extensions is not None:\n                    if get_file_extension(file_path) in self._ignore_file_extensions:\n                        print_if_verbose(\n                            self._verbose,\n                            \"\\t\" * current_depth\n                            + f\"ignoring blob {tree_obj.path} due to file extension\",\n                        )\n                        continue\n                blobs_and_full_paths.append((tree_obj, file_path))\n        return blobs_and_full_paths\n\n    async def", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 12, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "13": {"text": "   return blobs_and_full_paths\n\n    async def _generate_documents(\n        self, blobs_and_paths: List[Tuple[GitTreeResponseModel.GitTreeObject, str]]\n    ) -> List[Document]:\n        \"\"\"\n        Generate documents from a list of blobs and their full paths.\n\n        :param `blobs_and_paths`: list of tuples of\n            (tree object, file's full path in the repo realtive to the root of the repo)\n        :return: list of documents\n        \"\"\"\n        buffered_iterator = BufferedGitBlobDataIterator(\n            blobs_and_paths=blobs_and_paths,\n            github_client=self._client,\n            owner=self._owner,\n            repo=self._repo,\n            loop=self._loop,\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 13, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "14": {"text": "  loop=self._loop,\n            buffer_size=self._concurrent_requests,  # TODO: make this configurable\n            verbose=self._verbose,\n        )\n\n        documents = []\n        async for blob_data, full_path in buffered_iterator:\n            print_if_verbose(self._verbose, f\"generating document for {full_path}\")\n            assert (\n                blob_data.encoding == \"base64\"\n            ), f\"blob encoding {blob_data.encoding} not supported\"\n            decoded_bytes = None\n            try:\n                decoded_bytes = base64.b64decode(blob_data.content)\n                del blob_data.content\n            except binascii.Error:\n      ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 14, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "15": {"text": "     except binascii.Error:\n                print_if_verbose(\n                    self._verbose, f\"could not decode {full_path} as base64\"\n                )\n                continue\n\n            if self._use_parser:\n                document = self._parse_supported_file(\n                    file_path=full_path,\n                    file_content=decoded_bytes,\n                    tree_sha=blob_data.sha,\n                    tree_path=full_path,\n                )\n                if document is not None:\n                   ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 15, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "16": {"text": "                   documents.append(document)\n                else:\n                    continue\n\n            try:\n                if decoded_bytes is None:\n                    raise ValueError(\"decoded_bytes is None\")\n                decoded_text = decoded_bytes.decode(\"utf-8\")\n            except UnicodeDecodeError:\n                print_if_verbose(\n                    self._verbose, f\"could not decode {full_path} as utf-8\"\n                )\n                continue\n            print_if_verbose(\n                self._verbose,\n         ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 16, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "17": {"text": "     self._verbose,\n                f\"got {len(decoded_text)} characters\"\n                + f\"- adding to documents - {full_path}\",\n            )\n            document = Document(\n                text=decoded_text,\n                doc_id=blob_data.sha,\n                extra_info={\n                    \"file_path\": full_path,\n                    \"file_name\": full_path.split(\"/\")[-1],\n                },\n            )\n            documents.append(document)\n        return documents\n\n    def _parse_supported_file(\n        self, file_path: str, file_content: bytes, tree_sha: str,", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 17, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "18": {"text": "self, file_path: str, file_content: bytes, tree_sha: str, tree_path: str\n    ) -> Optional[Document]:\n        \"\"\"\n        Parse a file if it is supported by a parser.\n\n        :param `file_path`: path of the file in the repo\n        :param `file_content`: content of the file\n        :return: Document if the file is supported by a parser, None otherwise\n        \"\"\"\n        file_extension = get_file_extension(file_path)\n        if (parser := DEFAULT_FILE_EXTRACTOR.get(file_extension)) is not None:\n            parser.init_parser()\n            print_if_verbose(\n                self._verbose,\n                f\"parsing {file_path}\"\n                + f\"as {file_extension} with \"\n                +", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 18, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "19": {"text": "with \"\n                + f\"{parser.__class__.__name__}\",\n            )\n            with tempfile.TemporaryDirectory() as tmpdirname:\n                with tempfile.NamedTemporaryFile(\n                    dir=tmpdirname,\n                    suffix=f\".{file_extension}\",\n                    mode=\"w+b\",\n                    delete=False,\n                ) as tmpfile:\n                    print_if_verbose(\n                        self._verbose,\n                        \"created a temporary file\"\n                     ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 19, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "20": {"text": "                      + f\"{tmpfile.name} for parsing {file_path}\",\n                    )\n                    tmpfile.write(file_content)\n                    tmpfile.flush()\n                    tmpfile.close()\n                    try:\n                        parsed_file = parser.parse_file(pathlib.Path(tmpfile.name))\n                        parsed_file = \"\\n\\n\".join(parsed_file)\n                    except Exception as e:\n                        print_if_verbose(\n                         ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 20, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "21": {"text": "                      self._verbose, f\"error while parsing {file_path}\"\n                        )\n                        logger.error(\n                            \"Error while parsing \"\n                            + f\"{file_path} with \"\n                            + f\"{parser.__class__.__name__}:\\n{e}\"\n                        )\n                        parsed_file = None\n                    finally:\n                        os.remove(tmpfile.name)\n         ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 21, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "22": {"text": " os.remove(tmpfile.name)\n                    if parsed_file is None:\n                        return None\n                    return Document(\n                        text=parsed_file,\n                        doc_id=tree_sha,\n                        extra_info={\n                            \"file_path\": file_path,\n                            \"file_name\": tree_path,\n                        },\n                    )\n        return None\n\n\nif __name__ == \"__main__\":\n    import time\n\n    def", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 22, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "23": {"text": "__name__ == \"__main__\":\n    import time\n\n    def timeit(func: Callable) -> Callable:\n        \"\"\"Time a function.\"\"\"\n\n        def wrapper(*args: Any, **kwargs: Any) -> None:\n            \"\"\"Callcuate time taken to run a function.\"\"\"\n            start = time.time()\n            func(*args, **kwargs)\n            end = time.time()\n            print(f\"Time taken: {end - start} seconds for {func.__name__}\")\n\n        return wrapper\n\n    reader1 = GithubRepositoryReader(\n        github_token=os.environ[\"GITHUB_TOKEN\"],\n        owner=\"jerryjliu\",\n        repo=\"gpt_index\",\n        use_parser=False,\n        verbose=True,\n        ignore_directories=[\"examples\"],\n    )\n\n    @timeit\n    def load_data_from_commit() ->", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 23, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "24": {"text": "   @timeit\n    def load_data_from_commit() -> None:\n        \"\"\"Load data from a commit.\"\"\"\n        documents = reader1.load_data(\n            commit_sha=\"22e198b3b166b5facd2843d6a62ac0db07894a13\"\n        )\n        for document in documents:\n            print(document.extra_info)\n\n    @timeit\n    def load_data_from_branch() -> None:\n        \"\"\"Load data from a branch.\"\"\"\n        documents = reader1.load_data(branch=\"main\")\n        for document in documents:\n            print(document.extra_info)\n\n    input(\"Press enter to load github repository from branch name...\")\n\n    load_data_from_branch()\n\n    input(\"Press enter to load github repository from commit sha...\")\n\n    load_data_from_commit()\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 24, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "25": {"text": "GithubRepositoryReader is a class that retrieves the contents of a Github repository and returns a list of documents. It can either return the contents of the files in the repository or the text extracted from the files using the parser. It has methods to load data from a commit or a branch, and it also has methods to recursively get all blob tree objects in a tree and construct their full path relative to the root of the repository. It uses the GithubClient class to make requests to the Github API.", "doc_id": null, "embedding": null, "extra_info": null, "index": 25, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "ref_doc_id": null, "node_info": null}, "26": {"text": "This code file is a Python script that reads a GitHub repository and generates documents from the files in the repository. It uses a tree data structure to recursively traverse the repository and extract the files. It also uses a BufferedGitBlobDataIterator to make concurrent requests to the GitHub API. The code also has a parser that can parse supported files and generate documents from them. Finally, it also has a function to decode the files as base64 and utf-8 and generate documents from them.", "doc_id": null, "embedding": null, "extra_info": null, "index": 26, "child_indices": [10, 11, 12, 13, 14, 15, 16, 17, 18, 19], "ref_doc_id": null, "node_info": null}, "27": {"text": "This code file is a Python script that reads data from a GitHub repository. It uses the GithubRepositoryReader class to read data from a specified commit or branch. The data is parsed using a parser and stored in a Document object. The code also includes a timeit decorator to measure the time taken to run a function. Finally, the code provides two examples of how to use the GithubRepositoryReader class to read data from a commit or branch.", "doc_id": null, "embedding": null, "extra_info": null, "index": 27, "child_indices": [20, 21, 22, 23, 24], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"25": {"text": "GithubRepositoryReader is a class that retrieves the contents of a Github repository and returns a list of documents. It can either return the contents of the files in the repository or the text extracted from the files using the parser. It has methods to load data from a commit or a branch, and it also has methods to recursively get all blob tree objects in a tree and construct their full path relative to the root of the repository. It uses the GithubClient class to make requests to the Github API.", "doc_id": null, "embedding": null, "extra_info": null, "index": 25, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "ref_doc_id": null, "node_info": null}, "26": {"text": "This code file is a Python script that reads a GitHub repository and generates documents from the files in the repository. It uses a tree data structure to recursively traverse the repository and extract the files. It also uses a BufferedGitBlobDataIterator to make concurrent requests to the GitHub API. The code also has a parser that can parse supported files and generate documents from them. Finally, it also has a function to decode the files as base64 and utf-8 and generate documents from them.", "doc_id": null, "embedding": null, "extra_info": null, "index": 26, "child_indices": [10, 11, 12, 13, 14, 15, 16, 17, 18, 19], "ref_doc_id": null, "node_info": null}, "27": {"text": "This code file is a Python script that reads data from a GitHub repository. It uses the GithubRepositoryReader class to read data from a specified commit or branch. The data is parsed using a parser and stored in a Document object. The code also includes a timeit decorator to measure the time taken to run a function. Finally, the code provides two examples of how to use the GithubRepositoryReader class to read data from a commit or branch.", "doc_id": null, "embedding": null, "extra_info": null, "index": 27, "child_indices": [20, 21, 22, 23, 24], "ref_doc_id": null, "node_info": null}}}, "docstore": {"docs": {"ec1c0caaaba1db2a4017ee3087cfa942ade43a9a": {"text": "\"\"\"\nGithub repository reader.\n\nRetrieves the contents of a Github repository and returns a list of documents.\nThe documents are either the contents of the files in the repository or\nthe text extracted from the files using the parser.\n\"\"\"\n\nimport asyncio\nimport base64\nimport binascii\nimport logging\nimport os\nimport pathlib\nimport tempfile\nfrom typing import Any, Callable, List, Optional, Tuple\n\nfrom gpt_index.readers.base import BaseReader\nfrom gpt_index.readers.file.base import DEFAULT_FILE_EXTRACTOR\nfrom gpt_index.readers.github_readers.github_api_client import (\n    GitBranchResponseModel,\n    GitCommitResponseModel,\n    GithubClient,\n    GitTreeResponseModel,\n)\nfrom gpt_index.readers.github_readers.utils import (\n    BufferedGitBlobDataIterator,\n    get_file_extension,\n    print_if_verbose,\n)\nfrom gpt_index.readers.schema.base import Document\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass GithubRepositoryReader(BaseReader):\n    \"\"\"\n    Github repository reader.\n\n    Retrieves the contents of a Github repository and returns a list of documents.\n    The documents are either the contents of the files in the repository or the text\n    extracted from the files using the parser.\n\n    Examples:\n        >>> reader = GithubRepositoryReader(\"owner\", \"repo\")\n        >>> branch_documents = reader.load_data(branch=\"branch\")\n        >>> commit_documents = reader.load_data(commit_sha=\"commit_sha\")\n\n    \"\"\"\n\n    def __init__(\n        self,\n        owner: str,\n        repo: str,\n        use_parser: bool = True,\n        verbose: bool = False,\n        github_token: Optional[str] = None,\n        concurrent_requests: int = 5,\n        ignore_file_extensions: Optional[List[str]] = None,\n        ignore_directories: Optional[List[str]] = None,\n    ):\n        \"\"\"\n        Initialize params.\n\n        Args:\n            - owner (str): Owner of the repository.\n            - repo (str): Name of the repository.\n            - use_parser (bool): Whether to use the parser to extract\n                the text from the files.\n            - verbose (bool): Whether to print verbose messages.\n            - github_token (str): Github token. If not provided,\n                it will be read from the GITHUB_TOKEN environment variable.\n            - concurrent_requests (int): Number of concurrent requests to\n                make to the Github API.\n            - ignore_file_extensions (List[str]): List of file extensions to ignore.\n                i.e. ['.png', '.jpg']\n            - ignore_directories (List[str]): List of directories to ignore.\n                i.e. ['node_modules', 'dist']\n\n        Raises:\n            - `ValueError`: If the github_token is not provided and\n                the GITHUB_TOKEN environment variable is not set.\n        \"\"\"\n        super().__init__()\n        if github_token is None:\n            github_token = os.getenv(\"GITHUB_TOKEN\")\n            if github_token is None:\n                raise ValueError(\n                    \"Please provide a Github token. \"\n                    \"You can do so by passing it as an argument or\"\n                    + \"by setting the GITHUB_TOKEN environment variable.\"\n                )\n\n        self._owner = owner\n        self._repo = repo\n        self._use_parser = use_parser\n        self._verbose = verbose\n        self._concurrent_requests = concurrent_requests\n        self._ignore_file_extensions = ignore_file_extensions\n        self._ignore_directories = ignore_directories\n\n        # Set up the event loop\n        try:\n            self._loop = asyncio.get_running_loop()\n        except RuntimeError:\n            # If there is no running loop, create a new one\n            self._loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(self._loop)\n\n        self._client = GithubClient(github_token)\n\n    def _load_data_from_commit(self, commit_sha: str) -> List[Document]:\n        \"\"\"\n        Load data from a commit.\n\n        Loads github repository data from a specific commit sha.\n\n        :param `commit`: commit sha\n\n        :return: list of documents\n        \"\"\"\n        commit_response: GitCommitResponseModel = self._loop.run_until_complete(\n            self._client.get_commit(self._owner, self._repo, commit_sha)\n        )\n\n        tree_sha = commit_response.commit.tree.sha\n        blobs_and_paths = self._loop.run_until_complete(self._recurse_tree(tree_sha))\n\n        print_if_verbose(self._verbose, f\"got {len(blobs_and_paths)} blobs\")\n\n        return self._loop.run_until_complete(\n            self._generate_documents(blobs_and_paths=blobs_and_paths)\n        )\n\n    def _load_data_from_branch(self, branch: str) -> List[Document]:\n        \"\"\"\n        Load data from a branch.\n\n        Loads github repository data from a specific branch.\n\n        :param `branch`: branch name\n\n        :return: list of documents\n        \"\"\"\n        branch_data: GitBranchResponseModel = self._loop.run_until_complete(\n            self._client.get_branch(self._owner, self._repo, branch)\n        )\n\n        tree_sha = branch_data.commit.commit.tree.sha\n        blobs_and_paths = self._loop.run_until_complete(self._recurse_tree(tree_sha))\n\n        print_if_verbose(self._verbose, f\"got {len(blobs_and_paths)} blobs\")\n\n        return self._loop.run_until_complete(\n            self._generate_documents(blobs_and_paths=blobs_and_paths)\n        )\n\n    def load_data(\n        self,\n        commit_sha: Optional[str] = None,\n        branch: Optional[str] = None,\n    ) -> List[Document]:\n        \"\"\"\n        Load data from a commit or a branch.\n\n        Loads github repository data from a specific commit sha or a branch.\n\n        :param `commit`: commit sha\n        :param `branch`: branch name\n\n        :return: list of documents\n        \"\"\"\n        if commit_sha is not None and branch is not None:\n            raise ValueError(\"You can only specify one of commit or branch.\")\n\n        if commit_sha is None and branch is None:\n            raise ValueError(\"You must specify one of commit or branch.\")\n\n        if commit_sha is not None:\n            return self._load_data_from_commit(commit_sha)\n\n        if branch is not None:\n            return self._load_data_from_branch(branch)\n\n        raise ValueError(\"You must specify one of commit or branch.\")\n\n    async def _recurse_tree(\n        self, tree_sha: str, current_path: str = \"\", current_depth: int = 0\n    ) -> Any:\n        \"\"\"\n        Recursively get all blob tree objects in a tree.\n\n        And construct their full path relative to the root of the repository.\n        (see GitTreeResponseModel.GitTreeObject in\n            github_api_client.py for more information)\n\n        :param `tree_sha`: sha of the tree to recurse\n        :param `current_path`: current path of the tree\n        :param `current_depth`: current depth of the tree\n        :return: list of tuples of\n            (tree object, file's full path realtive to the root of the repo)\n        \"\"\"\n        blobs_and_full_paths: List[Tuple[GitTreeResponseModel.GitTreeObject, str]] = []\n        print_if_verbose(\n            self._verbose, \"\\t\" * current_depth + f\"current path: {current_path}\"\n        )\n\n        tree_data: GitTreeResponseModel = await self._client.get_tree(\n            self._owner, self._repo, tree_sha\n        )\n        print_if_verbose(\n            self._verbose, \"\\t\" * current_depth + f\"processing tree {tree_sha}\"\n        )\n        for tree_obj in tree_data.tree:\n            file_path = os.path.join(current_path, tree_obj.path)\n            if tree_obj.type == \"tree\":\n                print_if_verbose(\n                    self._verbose,\n                    \"\\t\" * current_depth + f\"recursing into {tree_obj.path}\",\n                )\n                if self._ignore_directories is not None:\n                    if file_path in self._ignore_directories:\n                        print_if_verbose(\n                            self._verbose,\n                            \"\\t\" * current_depth\n                            + f\"ignoring tree {tree_obj.path} due to directory\",\n                        )\n                        continue\n\n                blobs_and_full_paths.extend(\n                    await self._recurse_tree(tree_obj.sha, file_path, current_depth + 1)\n                )\n            elif tree_obj.type == \"blob\":\n                print_if_verbose(\n                    self._verbose, \"\\t\" * current_depth + f\"found blob {tree_obj.path}\"\n                )\n                if self._ignore_file_extensions is not None:\n                    if get_file_extension(file_path) in self._ignore_file_extensions:\n                        print_if_verbose(\n                            self._verbose,\n                            \"\\t\" * current_depth\n                            + f\"ignoring blob {tree_obj.path} due to file extension\",\n                        )\n                        continue\n                blobs_and_full_paths.append((tree_obj, file_path))\n        return blobs_and_full_paths\n\n    async def _generate_documents(\n        self, blobs_and_paths: List[Tuple[GitTreeResponseModel.GitTreeObject, str]]\n    ) -> List[Document]:\n        \"\"\"\n        Generate documents from a list of blobs and their full paths.\n\n        :param `blobs_and_paths`: list of tuples of\n            (tree object, file's full path in the repo realtive to the root of the repo)\n        :return: list of documents\n        \"\"\"\n        buffered_iterator = BufferedGitBlobDataIterator(\n            blobs_and_paths=blobs_and_paths,\n            github_client=self._client,\n            owner=self._owner,\n            repo=self._repo,\n            loop=self._loop,\n            buffer_size=self._concurrent_requests,  # TODO: make this configurable\n            verbose=self._verbose,\n        )\n\n        documents = []\n        async for blob_data, full_path in buffered_iterator:\n            print_if_verbose(self._verbose, f\"generating document for {full_path}\")\n            assert (\n                blob_data.encoding == \"base64\"\n            ), f\"blob encoding {blob_data.encoding} not supported\"\n            decoded_bytes = None\n            try:\n                decoded_bytes = base64.b64decode(blob_data.content)\n                del blob_data.content\n            except binascii.Error:\n                print_if_verbose(\n                    self._verbose, f\"could not decode {full_path} as base64\"\n                )\n                continue\n\n            if self._use_parser:\n                document = self._parse_supported_file(\n                    file_path=full_path,\n                    file_content=decoded_bytes,\n                    tree_sha=blob_data.sha,\n                    tree_path=full_path,\n                )\n                if document is not None:\n                    documents.append(document)\n                else:\n                    continue\n\n            try:\n                if decoded_bytes is None:\n                    raise ValueError(\"decoded_bytes is None\")\n                decoded_text = decoded_bytes.decode(\"utf-8\")\n            except UnicodeDecodeError:\n                print_if_verbose(\n                    self._verbose, f\"could not decode {full_path} as utf-8\"\n                )\n                continue\n            print_if_verbose(\n                self._verbose,\n                f\"got {len(decoded_text)} characters\"\n                + f\"- adding to documents - {full_path}\",\n            )\n            document = Document(\n                text=decoded_text,\n                doc_id=blob_data.sha,\n                extra_info={\n                    \"file_path\": full_path,\n                    \"file_name\": full_path.split(\"/\")[-1],\n                },\n            )\n            documents.append(document)\n        return documents\n\n    def _parse_supported_file(\n        self, file_path: str, file_content: bytes, tree_sha: str, tree_path: str\n    ) -> Optional[Document]:\n        \"\"\"\n        Parse a file if it is supported by a parser.\n\n        :param `file_path`: path of the file in the repo\n        :param `file_content`: content of the file\n        :return: Document if the file is supported by a parser, None otherwise\n        \"\"\"\n        file_extension = get_file_extension(file_path)\n        if (parser := DEFAULT_FILE_EXTRACTOR.get(file_extension)) is not None:\n            parser.init_parser()\n            print_if_verbose(\n                self._verbose,\n                f\"parsing {file_path}\"\n                + f\"as {file_extension} with \"\n                + f\"{parser.__class__.__name__}\",\n            )\n            with tempfile.TemporaryDirectory() as tmpdirname:\n                with tempfile.NamedTemporaryFile(\n                    dir=tmpdirname,\n                    suffix=f\".{file_extension}\",\n                    mode=\"w+b\",\n                    delete=False,\n                ) as tmpfile:\n                    print_if_verbose(\n                        self._verbose,\n                        \"created a temporary file\"\n                        + f\"{tmpfile.name} for parsing {file_path}\",\n                    )\n                    tmpfile.write(file_content)\n                    tmpfile.flush()\n                    tmpfile.close()\n                    try:\n                        parsed_file = parser.parse_file(pathlib.Path(tmpfile.name))\n                        parsed_file = \"\\n\\n\".join(parsed_file)\n                    except Exception as e:\n                        print_if_verbose(\n                            self._verbose, f\"error while parsing {file_path}\"\n                        )\n                        logger.error(\n                            \"Error while parsing \"\n                            + f\"{file_path} with \"\n                            + f\"{parser.__class__.__name__}:\\n{e}\"\n                        )\n                        parsed_file = None\n                    finally:\n                        os.remove(tmpfile.name)\n                    if parsed_file is None:\n                        return None\n                    return Document(\n                        text=parsed_file,\n                        doc_id=tree_sha,\n                        extra_info={\n                            \"file_path\": file_path,\n                            \"file_name\": tree_path,\n                        },\n                    )\n        return None\n\n\nif __name__ == \"__main__\":\n    import time\n\n    def timeit(func: Callable) -> Callable:\n        \"\"\"Time a function.\"\"\"\n\n        def wrapper(*args: Any, **kwargs: Any) -> None:\n            \"\"\"Callcuate time taken to run a function.\"\"\"\n            start = time.time()\n            func(*args, **kwargs)\n            end = time.time()\n            print(f\"Time taken: {end - start} seconds for {func.__name__}\")\n\n        return wrapper\n\n    reader1 = GithubRepositoryReader(\n        github_token=os.environ[\"GITHUB_TOKEN\"],\n        owner=\"jerryjliu\",\n        repo=\"gpt_index\",\n        use_parser=False,\n        verbose=True,\n        ignore_directories=[\"examples\"],\n    )\n\n    @timeit\n    def load_data_from_commit() -> None:\n        \"\"\"Load data from a commit.\"\"\"\n        documents = reader1.load_data(\n            commit_sha=\"22e198b3b166b5facd2843d6a62ac0db07894a13\"\n        )\n        for document in documents:\n            print(document.extra_info)\n\n    @timeit\n    def load_data_from_branch() -> None:\n        \"\"\"Load data from a branch.\"\"\"\n        documents = reader1.load_data(branch=\"main\")\n        for document in documents:\n            print(document.extra_info)\n\n    input(\"Press enter to load github repository from branch name...\")\n\n    load_data_from_branch()\n\n    input(\"Press enter to load github repository from commit sha...\")\n\n    load_data_from_commit()\n", "doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "__type__": "Document"}, "7f450286-03ad-45a0-970a-cb1efc605427": {"text": "\nThis code file is a Python script that reads data from a GitHub repository. It uses the GithubRepositoryReader class to read data from a specified commit or branch. The GithubRepositoryReader class uses a tree data structure to recursively traverse the repository and extract the files. It also uses a BufferedGitBlobDataIterator to make concurrent requests to the GitHub API. The data is parsed using a parser and stored in a Document object. The code also includes a timeit decorator to measure the time taken to run a function. The parser can parse supported files and generate documents from them. The code also has a function to decode the files as base64 and utf-8 and generate documents from them. The GithubRepositoryReader class has methods to recurse through the tree of files in the repository, generate documents from the files, and parse supported files. The class also has variables to store the owner, repo, verbose, ignore_directories, ignore_file_extensions, concurrent_requests, and use_parser. The code provides two examples of how to use the GithubRepositoryReader class to read data from a commit or branch. The purpose of the code is to read and parse files from a Github repository and generate", "doc_id": "7f450286-03ad-45a0-970a-cb1efc605427", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"\nGithub repository reader.\n\nRetrieves the contents of a Github repository and returns a list of documents.\nThe documents are either the contents of the files in the repository or\nthe text extracted from the files using the parser.\n\"\"\"\n\nimport asyncio\nimport base64\nimport binascii\nimport logging\nimport os\nimport pathlib\nimport tempfile\nfrom typing import Any, Callable, List, Optional, Tuple\n\nfrom gpt_index.readers.base import BaseReader\nfrom gpt_index.readers.file.base import DEFAULT_FILE_EXTRACTOR\nfrom gpt_index.readers.github_readers.github_api_client import (\n    GitBranchResponseModel,\n    GitCommitResponseModel,\n    GithubClient,\n    GitTreeResponseModel,\n)\nfrom gpt_index.readers.github_readers.utils import (\n    BufferedGitBlobDataIterator,\n    get_file_extension,\n    print_if_verbose,\n)\nfrom gpt_index.readers.schema.base import Document\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass GithubRepositoryReader(BaseReader):\n    \"\"\"\n  ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 0, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "1": {"text": "GithubRepositoryReader(BaseReader):\n    \"\"\"\n    Github repository reader.\n\n    Retrieves the contents of a Github repository and returns a list of documents.\n    The documents are either the contents of the files in the repository or the text\n    extracted from the files using the parser.\n\n    Examples:\n        >>> reader = GithubRepositoryReader(\"owner\", \"repo\")\n        >>> branch_documents = reader.load_data(branch=\"branch\")\n        >>> commit_documents = reader.load_data(commit_sha=\"commit_sha\")\n\n    \"\"\"\n\n    def __init__(\n        self,\n        owner: str,\n        repo: str,\n        use_parser: bool = True,\n        verbose: bool = False,\n        github_token: Optional[str] = None,\n        concurrent_requests: int = 5,\n        ignore_file_extensions: Optional[List[str]] = None,\n        ignore_directories: Optional[List[str]] = None,\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 1, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "2": {"text": "     ignore_directories: Optional[List[str]] = None,\n    ):\n        \"\"\"\n        Initialize params.\n\n        Args:\n            - owner (str): Owner of the repository.\n            - repo (str): Name of the repository.\n            - use_parser (bool): Whether to use the parser to extract\n                the text from the files.\n            - verbose (bool): Whether to print verbose messages.\n            - github_token (str): Github token. If not provided,\n                it will be read from the GITHUB_TOKEN environment variable.\n            - concurrent_requests (int): Number of concurrent requests to\n                make to the Github API.\n            - ignore_file_extensions (List[str]): List of file extensions to ignore.\n             ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 2, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "3": {"text": "file extensions to ignore.\n                i.e. ['.png', '.jpg']\n            - ignore_directories (List[str]): List of directories to ignore.\n                i.e. ['node_modules', 'dist']\n\n        Raises:\n            - `ValueError`: If the github_token is not provided and\n                the GITHUB_TOKEN environment variable is not set.\n        \"\"\"\n        super().__init__()\n        if github_token is None:\n            github_token = os.getenv(\"GITHUB_TOKEN\")\n            if github_token is None:\n                raise ValueError(\n                    \"Please provide a Github token. \"\n                    \"You can do so by passing it as an argument or\"\n       ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 3, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "4": {"text": "can do so by passing it as an argument or\"\n                    + \"by setting the GITHUB_TOKEN environment variable.\"\n                )\n\n        self._owner = owner\n        self._repo = repo\n        self._use_parser = use_parser\n        self._verbose = verbose\n        self._concurrent_requests = concurrent_requests\n        self._ignore_file_extensions = ignore_file_extensions\n        self._ignore_directories = ignore_directories\n\n        # Set up the event loop\n        try:\n            self._loop = asyncio.get_running_loop()\n        except RuntimeError:\n            # If there is no running loop, create a new one\n            self._loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(self._loop)\n\n        self._client", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 4, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "5": {"text": "       self._client = GithubClient(github_token)\n\n    def _load_data_from_commit(self, commit_sha: str) -> List[Document]:\n        \"\"\"\n        Load data from a commit.\n\n        Loads github repository data from a specific commit sha.\n\n        :param `commit`: commit sha\n\n        :return: list of documents\n        \"\"\"\n        commit_response: GitCommitResponseModel = self._loop.run_until_complete(\n            self._client.get_commit(self._owner, self._repo, commit_sha)\n        )\n\n        tree_sha = commit_response.commit.tree.sha\n        blobs_and_paths = self._loop.run_until_complete(self._recurse_tree(tree_sha))\n\n        print_if_verbose(self._verbose, f\"got {len(blobs_and_paths)} blobs\")\n\n        return self._loop.run_until_complete(\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 5, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "6": {"text": "           self._generate_documents(blobs_and_paths=blobs_and_paths)\n        )\n\n    def _load_data_from_branch(self, branch: str) -> List[Document]:\n        \"\"\"\n        Load data from a branch.\n\n        Loads github repository data from a specific branch.\n\n        :param `branch`: branch name\n\n        :return: list of documents\n        \"\"\"\n        branch_data: GitBranchResponseModel = self._loop.run_until_complete(\n            self._client.get_branch(self._owner, self._repo, branch)\n        )\n\n        tree_sha = branch_data.commit.commit.tree.sha\n        blobs_and_paths = self._loop.run_until_complete(self._recurse_tree(tree_sha))\n\n        print_if_verbose(self._verbose, f\"got {len(blobs_and_paths)} blobs\")\n\n      ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 6, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "7": {"text": "blobs\")\n\n        return self._loop.run_until_complete(\n            self._generate_documents(blobs_and_paths=blobs_and_paths)\n        )\n\n    def load_data(\n        self,\n        commit_sha: Optional[str] = None,\n        branch: Optional[str] = None,\n    ) -> List[Document]:\n        \"\"\"\n        Load data from a commit or a branch.\n\n        Loads github repository data from a specific commit sha or a branch.\n\n        :param `commit`: commit sha\n        :param `branch`: branch name\n\n        :return: list of documents\n        \"\"\"\n        if commit_sha is not None and branch is not None:\n            raise ValueError(\"You can only specify one of commit or branch.\")\n\n        if commit_sha is None and branch is None:\n            raise ValueError(\"You must specify one of", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 7, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "8": {"text": "          raise ValueError(\"You must specify one of commit or branch.\")\n\n        if commit_sha is not None:\n            return self._load_data_from_commit(commit_sha)\n\n        if branch is not None:\n            return self._load_data_from_branch(branch)\n\n        raise ValueError(\"You must specify one of commit or branch.\")\n\n    async def _recurse_tree(\n        self, tree_sha: str, current_path: str = \"\", current_depth: int = 0\n    ) -> Any:\n        \"\"\"\n        Recursively get all blob tree objects in a tree.\n\n        And construct their full path relative to the root of the repository.\n        (see GitTreeResponseModel.GitTreeObject in\n            github_api_client.py for more information)\n\n        :param `tree_sha`: sha of the tree to recurse\n        :param `current_path`: current path of the tree\n       ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 8, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "9": {"text": "`current_path`: current path of the tree\n        :param `current_depth`: current depth of the tree\n        :return: list of tuples of\n            (tree object, file's full path realtive to the root of the repo)\n        \"\"\"\n        blobs_and_full_paths: List[Tuple[GitTreeResponseModel.GitTreeObject, str]] = []\n        print_if_verbose(\n            self._verbose, \"\\t\" * current_depth + f\"current path: {current_path}\"\n        )\n\n        tree_data: GitTreeResponseModel = await self._client.get_tree(\n            self._owner, self._repo, tree_sha\n        )\n        print_if_verbose(\n            self._verbose, \"\\t\" * current_depth + f\"processing tree {tree_sha}\"\n        )\n        for tree_obj in tree_data.tree:\n         ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 9, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "10": {"text": "tree_obj in tree_data.tree:\n            file_path = os.path.join(current_path, tree_obj.path)\n            if tree_obj.type == \"tree\":\n                print_if_verbose(\n                    self._verbose,\n                    \"\\t\" * current_depth + f\"recursing into {tree_obj.path}\",\n                )\n                if self._ignore_directories is not None:\n                    if file_path in self._ignore_directories:\n                        print_if_verbose(\n                            self._verbose,\n                            \"\\t\" * current_depth\n   ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 10, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "11": {"text": "        \"\\t\" * current_depth\n                            + f\"ignoring tree {tree_obj.path} due to directory\",\n                        )\n                        continue\n\n                blobs_and_full_paths.extend(\n                    await self._recurse_tree(tree_obj.sha, file_path, current_depth + 1)\n                )\n            elif tree_obj.type == \"blob\":\n                print_if_verbose(\n                    self._verbose, \"\\t\" * current_depth + f\"found blob {tree_obj.path}\"\n                )\n                if", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 11, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "12": {"text": "  )\n                if self._ignore_file_extensions is not None:\n                    if get_file_extension(file_path) in self._ignore_file_extensions:\n                        print_if_verbose(\n                            self._verbose,\n                            \"\\t\" * current_depth\n                            + f\"ignoring blob {tree_obj.path} due to file extension\",\n                        )\n                        continue\n                blobs_and_full_paths.append((tree_obj, file_path))\n        return blobs_and_full_paths\n\n    async def", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 12, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "13": {"text": "   return blobs_and_full_paths\n\n    async def _generate_documents(\n        self, blobs_and_paths: List[Tuple[GitTreeResponseModel.GitTreeObject, str]]\n    ) -> List[Document]:\n        \"\"\"\n        Generate documents from a list of blobs and their full paths.\n\n        :param `blobs_and_paths`: list of tuples of\n            (tree object, file's full path in the repo realtive to the root of the repo)\n        :return: list of documents\n        \"\"\"\n        buffered_iterator = BufferedGitBlobDataIterator(\n            blobs_and_paths=blobs_and_paths,\n            github_client=self._client,\n            owner=self._owner,\n            repo=self._repo,\n            loop=self._loop,\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 13, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "14": {"text": "  loop=self._loop,\n            buffer_size=self._concurrent_requests,  # TODO: make this configurable\n            verbose=self._verbose,\n        )\n\n        documents = []\n        async for blob_data, full_path in buffered_iterator:\n            print_if_verbose(self._verbose, f\"generating document for {full_path}\")\n            assert (\n                blob_data.encoding == \"base64\"\n            ), f\"blob encoding {blob_data.encoding} not supported\"\n            decoded_bytes = None\n            try:\n                decoded_bytes = base64.b64decode(blob_data.content)\n                del blob_data.content\n            except binascii.Error:\n      ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 14, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "15": {"text": "     except binascii.Error:\n                print_if_verbose(\n                    self._verbose, f\"could not decode {full_path} as base64\"\n                )\n                continue\n\n            if self._use_parser:\n                document = self._parse_supported_file(\n                    file_path=full_path,\n                    file_content=decoded_bytes,\n                    tree_sha=blob_data.sha,\n                    tree_path=full_path,\n                )\n                if document is not None:\n                   ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 15, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "16": {"text": "                   documents.append(document)\n                else:\n                    continue\n\n            try:\n                if decoded_bytes is None:\n                    raise ValueError(\"decoded_bytes is None\")\n                decoded_text = decoded_bytes.decode(\"utf-8\")\n            except UnicodeDecodeError:\n                print_if_verbose(\n                    self._verbose, f\"could not decode {full_path} as utf-8\"\n                )\n                continue\n            print_if_verbose(\n                self._verbose,\n         ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 16, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "17": {"text": "     self._verbose,\n                f\"got {len(decoded_text)} characters\"\n                + f\"- adding to documents - {full_path}\",\n            )\n            document = Document(\n                text=decoded_text,\n                doc_id=blob_data.sha,\n                extra_info={\n                    \"file_path\": full_path,\n                    \"file_name\": full_path.split(\"/\")[-1],\n                },\n            )\n            documents.append(document)\n        return documents\n\n    def _parse_supported_file(\n        self, file_path: str, file_content: bytes, tree_sha: str,", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 17, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "18": {"text": "self, file_path: str, file_content: bytes, tree_sha: str, tree_path: str\n    ) -> Optional[Document]:\n        \"\"\"\n        Parse a file if it is supported by a parser.\n\n        :param `file_path`: path of the file in the repo\n        :param `file_content`: content of the file\n        :return: Document if the file is supported by a parser, None otherwise\n        \"\"\"\n        file_extension = get_file_extension(file_path)\n        if (parser := DEFAULT_FILE_EXTRACTOR.get(file_extension)) is not None:\n            parser.init_parser()\n            print_if_verbose(\n                self._verbose,\n                f\"parsing {file_path}\"\n                + f\"as {file_extension} with \"\n                +", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 18, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "19": {"text": "with \"\n                + f\"{parser.__class__.__name__}\",\n            )\n            with tempfile.TemporaryDirectory() as tmpdirname:\n                with tempfile.NamedTemporaryFile(\n                    dir=tmpdirname,\n                    suffix=f\".{file_extension}\",\n                    mode=\"w+b\",\n                    delete=False,\n                ) as tmpfile:\n                    print_if_verbose(\n                        self._verbose,\n                        \"created a temporary file\"\n                     ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 19, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "20": {"text": "                      + f\"{tmpfile.name} for parsing {file_path}\",\n                    )\n                    tmpfile.write(file_content)\n                    tmpfile.flush()\n                    tmpfile.close()\n                    try:\n                        parsed_file = parser.parse_file(pathlib.Path(tmpfile.name))\n                        parsed_file = \"\\n\\n\".join(parsed_file)\n                    except Exception as e:\n                        print_if_verbose(\n                         ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 20, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "21": {"text": "                      self._verbose, f\"error while parsing {file_path}\"\n                        )\n                        logger.error(\n                            \"Error while parsing \"\n                            + f\"{file_path} with \"\n                            + f\"{parser.__class__.__name__}:\\n{e}\"\n                        )\n                        parsed_file = None\n                    finally:\n                        os.remove(tmpfile.name)\n         ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 21, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "22": {"text": " os.remove(tmpfile.name)\n                    if parsed_file is None:\n                        return None\n                    return Document(\n                        text=parsed_file,\n                        doc_id=tree_sha,\n                        extra_info={\n                            \"file_path\": file_path,\n                            \"file_name\": tree_path,\n                        },\n                    )\n        return None\n\n\nif __name__ == \"__main__\":\n    import time\n\n    def", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 22, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "23": {"text": "__name__ == \"__main__\":\n    import time\n\n    def timeit(func: Callable) -> Callable:\n        \"\"\"Time a function.\"\"\"\n\n        def wrapper(*args: Any, **kwargs: Any) -> None:\n            \"\"\"Callcuate time taken to run a function.\"\"\"\n            start = time.time()\n            func(*args, **kwargs)\n            end = time.time()\n            print(f\"Time taken: {end - start} seconds for {func.__name__}\")\n\n        return wrapper\n\n    reader1 = GithubRepositoryReader(\n        github_token=os.environ[\"GITHUB_TOKEN\"],\n        owner=\"jerryjliu\",\n        repo=\"gpt_index\",\n        use_parser=False,\n        verbose=True,\n        ignore_directories=[\"examples\"],\n    )\n\n    @timeit\n    def load_data_from_commit() ->", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 23, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "24": {"text": "   @timeit\n    def load_data_from_commit() -> None:\n        \"\"\"Load data from a commit.\"\"\"\n        documents = reader1.load_data(\n            commit_sha=\"22e198b3b166b5facd2843d6a62ac0db07894a13\"\n        )\n        for document in documents:\n            print(document.extra_info)\n\n    @timeit\n    def load_data_from_branch() -> None:\n        \"\"\"Load data from a branch.\"\"\"\n        documents = reader1.load_data(branch=\"main\")\n        for document in documents:\n            print(document.extra_info)\n\n    input(\"Press enter to load github repository from branch name...\")\n\n    load_data_from_branch()\n\n    input(\"Press enter to load github repository from commit sha...\")\n\n    load_data_from_commit()\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "gpt_index/readers/github_readers/github_repository_reader.py", "file_name": "github_repository_reader.py"}, "index": 24, "child_indices": [], "ref_doc_id": "ec1c0caaaba1db2a4017ee3087cfa942ade43a9a", "node_info": null}, "25": {"text": "GithubRepositoryReader is a class that retrieves the contents of a Github repository and returns a list of documents. It can either return the contents of the files in the repository or the text extracted from the files using the parser. It has methods to load data from a commit or a branch, and it also has methods to recursively get all blob tree objects in a tree and construct their full path relative to the root of the repository. It uses the GithubClient class to make requests to the Github API.", "doc_id": null, "embedding": null, "extra_info": null, "index": 25, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "ref_doc_id": null, "node_info": null}, "26": {"text": "This code file is a Python script that reads a GitHub repository and generates documents from the files in the repository. It uses a tree data structure to recursively traverse the repository and extract the files. It also uses a BufferedGitBlobDataIterator to make concurrent requests to the GitHub API. The code also has a parser that can parse supported files and generate documents from them. Finally, it also has a function to decode the files as base64 and utf-8 and generate documents from them.", "doc_id": null, "embedding": null, "extra_info": null, "index": 26, "child_indices": [10, 11, 12, 13, 14, 15, 16, 17, 18, 19], "ref_doc_id": null, "node_info": null}, "27": {"text": "This code file is a Python script that reads data from a GitHub repository. It uses the GithubRepositoryReader class to read data from a specified commit or branch. The data is parsed using a parser and stored in a Document object. The code also includes a timeit decorator to measure the time taken to run a function. Finally, the code provides two examples of how to use the GithubRepositoryReader class to read data from a commit or branch.", "doc_id": null, "embedding": null, "extra_info": null, "index": 27, "child_indices": [20, 21, 22, 23, 24], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"25": {"text": "GithubRepositoryReader is a class that retrieves the contents of a Github repository and returns a list of documents. It can either return the contents of the files in the repository or the text extracted from the files using the parser. It has methods to load data from a commit or a branch, and it also has methods to recursively get all blob tree objects in a tree and construct their full path relative to the root of the repository. It uses the GithubClient class to make requests to the Github API.", "doc_id": null, "embedding": null, "extra_info": null, "index": 25, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "ref_doc_id": null, "node_info": null}, "26": {"text": "This code file is a Python script that reads a GitHub repository and generates documents from the files in the repository. It uses a tree data structure to recursively traverse the repository and extract the files. It also uses a BufferedGitBlobDataIterator to make concurrent requests to the GitHub API. The code also has a parser that can parse supported files and generate documents from them. Finally, it also has a function to decode the files as base64 and utf-8 and generate documents from them.", "doc_id": null, "embedding": null, "extra_info": null, "index": 26, "child_indices": [10, 11, 12, 13, 14, 15, 16, 17, 18, 19], "ref_doc_id": null, "node_info": null}, "27": {"text": "This code file is a Python script that reads data from a GitHub repository. It uses the GithubRepositoryReader class to read data from a specified commit or branch. The data is parsed using a parser and stored in a Document object. The code also includes a timeit decorator to measure the time taken to run a function. Finally, the code provides two examples of how to use the GithubRepositoryReader class to read data from a commit or branch.", "doc_id": null, "embedding": null, "extra_info": null, "index": 27, "child_indices": [20, 21, 22, 23, 24], "ref_doc_id": null, "node_info": null}}, "__type__": "tree"}}}}