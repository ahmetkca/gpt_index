{"index_struct": {"text": "\nThis code file tests the functionality of a recursive query on GPT-Index, a library for creating composable indices. It sets up a fixture with index keyword arguments and query configs, and then tests recursive queries using mock objects to simulate the behavior of the library's components. The tests check that the query returns the expected response when it is run in recursive and non-recursive modes, and that the serialization and deserialization of the indices, as well as the total token count used in the query, are functioning correctly. The purpose of the code is to ensure that the query is working properly and that the data structures are being used correctly.", "doc_id": "110501d1-b11c-4125-9d21-715ab6e87c39", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"Test recursive queries.\"\"\"\n\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nfrom typing import Any, Dict, List, Tuple\nfrom unittest.mock import patch\n\nimport pytest\n\nfrom gpt_index.composability.graph import ComposableGraph\nfrom gpt_index.data_structs.struct_type import IndexStructType\nfrom gpt_index.indices.keyword_table.simple_base import GPTSimpleKeywordTableIndex\nfrom gpt_index.indices.list.base import GPTListIndex\nfrom gpt_index.indices.query.schema import QueryConfig, QueryMode\nfrom gpt_index.indices.tree.base import GPTTreeIndex\nfrom gpt_index.langchain_helpers.chain_wrapper import (\n    LLMChain,\n    LLMMetadata,\n    LLMPredictor,\n)\nfrom gpt_index.langchain_helpers.text_splitter import TokenTextSplitter\nfrom gpt_index.readers.schema.base import Document\nfrom tests.mock_utils.mock_predict import (\n    mock_llmchain_predict,\n    mock_llmpredictor_predict,\n)\nfrom tests.mock_utils.mock_prompts import (\n    MOCK_INSERT_PROMPT,\n   ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 0, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "1": {"text": "import (\n    MOCK_INSERT_PROMPT,\n    MOCK_KEYWORD_EXTRACT_PROMPT,\n    MOCK_QUERY_KEYWORD_EXTRACT_PROMPT,\n    MOCK_QUERY_PROMPT,\n    MOCK_REFINE_PROMPT,\n    MOCK_SUMMARY_PROMPT,\n    MOCK_TEXT_QA_PROMPT,\n)\nfrom tests.mock_utils.mock_text_splitter import mock_token_splitter_newline\n\n\n@pytest.fixture\ndef struct_kwargs() -> Tuple[Dict, List]:\n    \"\"\"Index kwargs.\"\"\"\n    index_kwargs = {\n        \"tree\": {\n            \"summary_template\": MOCK_SUMMARY_PROMPT,\n            \"insert_prompt\": MOCK_INSERT_PROMPT,\n            \"num_children\": 2,\n        },\n        \"list\": {\n            \"text_qa_template\": MOCK_TEXT_QA_PROMPT,\n        },\n       ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 1, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "2": {"text": "       },\n        \"table\": {\n            \"keyword_extract_template\": MOCK_KEYWORD_EXTRACT_PROMPT,\n        },\n    }\n    query_configs = [\n        QueryConfig(\n            index_struct_type=IndexStructType.TREE,\n            query_mode=QueryMode.DEFAULT,\n            query_kwargs={\n                \"query_template\": MOCK_QUERY_PROMPT,\n                \"text_qa_template\": MOCK_TEXT_QA_PROMPT,\n                \"refine_template\": MOCK_REFINE_PROMPT,\n            },\n        ),\n        QueryConfig(\n            index_struct_type=IndexStructType.LIST,\n            query_mode=QueryMode.DEFAULT,\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 2, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "3": {"text": "           query_kwargs={\n                \"text_qa_template\": MOCK_TEXT_QA_PROMPT,\n                \"refine_template\": MOCK_REFINE_PROMPT,\n            },\n        ),\n        QueryConfig(\n            index_struct_type=IndexStructType.KEYWORD_TABLE,\n            query_mode=QueryMode.DEFAULT,\n            query_kwargs={\n                \"query_keyword_extract_template\": MOCK_QUERY_KEYWORD_EXTRACT_PROMPT,\n                \"text_qa_template\": MOCK_TEXT_QA_PROMPT,\n                \"refine_template\": MOCK_REFINE_PROMPT,\n            },\n        ),\n    ]\n    return index_kwargs, query_configs\n\n\n@pytest.fixture\ndef", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 3, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "4": {"text": "return index_kwargs, query_configs\n\n\n@pytest.fixture\ndef documents() -> List[Document]:\n    \"\"\"Get documents.\"\"\"\n    docs = [\n        Document(\"This is a test v2.\"),\n        Document(\"This is another test.\"),\n        Document(\"This is a test.\"),\n        Document(\"Hello world.\"),\n        Document(\"Hello world.\"),\n        Document(\"This is a test.\"),\n        Document(\"This is another test.\"),\n        Document(\"This is a test v2.\"),\n    ]\n    return docs\n\n\n@patch.object(TokenTextSplitter, \"split_text\", side_effect=mock_token_splitter_newline)\n@patch.object(LLMPredictor, \"predict\", side_effect=mock_llmpredictor_predict)\n@patch.object(LLMPredictor, \"total_tokens_used\", return_value=0)\n@patch.object(LLMPredictor, \"__init__\", return_value=None)\ndef test_recursive_query_list_tree(\n    _mock_init: Any,\n    _mock_total_tokens_used: Any,\n   ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 4, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "5": {"text": "  _mock_total_tokens_used: Any,\n    _mock_predict: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test query.\"\"\"\n    index_kwargs, query_configs = struct_kwargs\n    list_kwargs = index_kwargs[\"list\"]\n    tree_kwargs = index_kwargs[\"tree\"]\n    # try building a list for every two, then a tree\n    list1 = GPTListIndex(documents[0:2], **list_kwargs)\n    list1.set_text(\"summary1\")\n    list2 = GPTListIndex(documents[2:4], **list_kwargs)\n    list2.set_text(\"summary2\")\n    list3 = GPTListIndex(documents[4:6], **list_kwargs)\n    list3.set_text(\"summary3\")\n    list4 = GPTListIndex(documents[6:8], **list_kwargs)\n    list4.set_text(\"summary4\")\n\n    # there are two root nodes in this tree: one containing [list1, list2]\n    # and the other containing [list3, list4]\n    tree", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 5, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "6": {"text": "   # and the other containing [list3, list4]\n    tree = GPTTreeIndex(\n        [\n            list1,\n            list2,\n            list3,\n            list4,\n        ],\n        **tree_kwargs\n    )\n    query_str = \"What is?\"\n    # query should first pick the left root node, then pick list1\n    # within list1, it should go through the first document and second document\n    response = tree.query(query_str, mode=\"recursive\", query_configs=query_configs)\n    assert str(response) == (\"What is?:This is a test v2.\")\n\n    # Also test a non-recursive query. This should not go down into the list\n    tree_query_kwargs = query_configs[0].query_kwargs\n    response = tree.query(query_str, mode=\"default\", **tree_query_kwargs)\n    assert str(response) == (\"What is?:summary1\")\n\n\n@patch.object(TokenTextSplitter, \"split_text\",", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 6, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "7": {"text": "\"split_text\", side_effect=mock_token_splitter_newline)\n@patch.object(LLMPredictor, \"predict\", side_effect=mock_llmpredictor_predict)\n@patch.object(LLMPredictor, \"total_tokens_used\", return_value=0)\n@patch.object(LLMPredictor, \"__init__\", return_value=None)\ndef test_recursive_query_tree_list(\n    _mock_init: Any,\n    _mock_total_tokens_used: Any,\n    _mock_predict: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test query.\"\"\"\n    index_kwargs, query_configs = struct_kwargs\n    list_kwargs = index_kwargs[\"list\"]\n    tree_kwargs = index_kwargs[\"tree\"]\n    # try building a tree for a group of 4, then a list\n    # use a diff set of documents\n    tree1 = GPTTreeIndex(documents[2:6], **tree_kwargs)\n    tree2 = GPTTreeIndex(documents[:2] + documents[6:], **tree_kwargs)\n   ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 7, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "8": {"text": "+ documents[6:], **tree_kwargs)\n    tree1.set_text(\"tree_summary1\")\n    tree2.set_text(\"tree_summary2\")\n\n    # there are two root nodes in this tree: one containing [list1, list2]\n    # and the other containing [list3, list4]\n    list_index = GPTListIndex([tree1, tree2], **list_kwargs)\n    query_str = \"What is?\"\n    # query should first pick the left root node, then pick list1\n    # within list1, it should go through the first document and second document\n    response = list_index.query(\n        query_str, mode=\"recursive\", query_configs=query_configs\n    )\n    assert str(response) == (\"What is?:This is a test.\")\n\n    # Also test a non-recursive query. This should not go down into the list\n    list_query_kwargs = query_configs[1].query_kwargs\n    response = list_index.query(query_str, mode=\"default\", **list_query_kwargs)\n    assert str(response) == (\"What is?:tree_summary1\")\n\n\n@patch.object(TokenTextSplitter, \"split_text\",", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 8, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "9": {"text": "\"split_text\", side_effect=mock_token_splitter_newline)\n@patch.object(LLMPredictor, \"predict\", side_effect=mock_llmpredictor_predict)\n@patch.object(LLMPredictor, \"total_tokens_used\", return_value=0)\n@patch.object(LLMPredictor, \"__init__\", return_value=None)\ndef test_recursive_query_table_list(\n    _mock_init: Any,\n    _mock_total_tokens_used: Any,\n    _mock_predict: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test query.\"\"\"\n    index_kwargs, query_configs = struct_kwargs\n    list_kwargs = index_kwargs[\"list\"]\n    table_kwargs = index_kwargs[\"table\"]\n    # try building a tree for a group of 4, then a list\n    # use a diff set of documents\n    table1 = GPTSimpleKeywordTableIndex(documents[4:6], **table_kwargs)\n    table2 = GPTSimpleKeywordTableIndex(documents[2:3], **table_kwargs)\n   ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 9, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "10": {"text": "**table_kwargs)\n    table1.set_text(\"table_summary1\")\n    table2.set_text(\"table_summary2\")\n    table1.set_doc_id(\"table1\")\n    table2.set_doc_id(\"table2\")\n\n    list_index = GPTListIndex([table1, table2], **list_kwargs)\n    query_str = \"World?\"\n    response = list_index.query(\n        query_str, mode=\"recursive\", query_configs=query_configs\n    )\n    assert str(response) == (\"World?:Hello world.\")\n\n    query_str = \"Test?\"\n    response = list_index.query(\n        query_str, mode=\"recursive\", query_configs=query_configs\n    )\n    assert str(response) == (\"Test?:This is a test.\")\n\n    # test serialize and then back\n    with TemporaryDirectory() as tmpdir:\n        graph = ComposableGraph.build_from_index(list_index)\n        graph.save_to_disk(str(Path(tmpdir) / \"tmp.json\"))\n        graph = ComposableGraph.load_from_disk(str(Path(tmpdir) /", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 10, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "11": {"text": "= ComposableGraph.load_from_disk(str(Path(tmpdir) / \"tmp.json\"))\n        response = graph.query(query_str, query_configs=query_configs)\n        assert str(response) == (\"Test?:This is a test.\")\n\n        # test graph.get_index\n        test_table1 = graph.get_index(\"table1\", GPTSimpleKeywordTableIndex)\n        response = test_table1.query(\"Hello\")\n        assert str(response) == (\"Hello:Hello world.\")\n\n\n@patch.object(TokenTextSplitter, \"split_text\", side_effect=mock_token_splitter_newline)\n@patch.object(LLMPredictor, \"predict\", side_effect=mock_llmpredictor_predict)\n@patch.object(LLMPredictor, \"total_tokens_used\", return_value=0)\n@patch.object(LLMPredictor, \"__init__\", return_value=None)\ndef test_recursive_query_list_table(\n    _mock_init: Any,\n    _mock_total_tokens_used: Any,\n    _mock_predict: Any,\n    _mock_split_text: Any,\n    documents:", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 11, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "12": {"text": "   _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test query.\"\"\"\n    index_kwargs, query_configs = struct_kwargs\n    list_kwargs = index_kwargs[\"list\"]\n    table_kwargs = index_kwargs[\"table\"]\n    # try building a tree for a group of 4, then a list\n    # use a diff set of documents\n    # try building a list for every two, then a tree\n    list1 = GPTListIndex(documents[0:2], **list_kwargs)\n    list1.set_text(\"foo bar\")\n    list2 = GPTListIndex(documents[2:4], **list_kwargs)\n    list2.set_text(\"apple orange\")\n    list3 = GPTListIndex(documents[4:6], **list_kwargs)\n    list3.set_text(\"toronto london\")\n    list4 = GPTListIndex(documents[6:8], **list_kwargs)\n    list4.set_text(\"cat dog\")\n\n    table = GPTSimpleKeywordTableIndex([list1, list2, list3, list4], **table_kwargs)\n    query_str =", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 12, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "13": {"text": "list3, list4], **table_kwargs)\n    query_str = \"Foo?\"\n    response = table.query(query_str, mode=\"recursive\", query_configs=query_configs)\n    assert str(response) == (\"Foo?:This is a test v2.\")\n    query_str = \"Orange?\"\n    response = table.query(query_str, mode=\"recursive\", query_configs=query_configs)\n    assert str(response) == (\"Orange?:This is a test.\")\n    query_str = \"Cat?\"\n    response = table.query(query_str, mode=\"recursive\", query_configs=query_configs)\n    assert str(response) == (\"Cat?:This is another test.\")\n\n    # test serialize and then back\n    # use composable graph struct\n    with TemporaryDirectory() as tmpdir:\n        graph = ComposableGraph.build_from_index(table)\n        graph.save_to_disk(str(Path(tmpdir) / \"tmp.json\"))\n        graph = ComposableGraph.load_from_disk(str(Path(tmpdir) / \"tmp.json\"))\n        response = graph.query(query_str, query_configs=query_configs)\n       ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 13, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "14": {"text": "query_configs=query_configs)\n        assert str(response) == (\"Cat?:This is another test.\")\n\n\n@patch.object(LLMChain, \"predict\", side_effect=mock_llmchain_predict)\n@patch(\"gpt_index.langchain_helpers.chain_wrapper.OpenAI\")\n@patch.object(LLMPredictor, \"get_llm_metadata\", return_value=LLMMetadata())\n@patch.object(LLMChain, \"__init__\", return_value=None)\ndef test_recursive_query_list_tree_token_count(\n    _mock_init: Any,\n    _mock_llm_metadata: Any,\n    _mock_llmchain: Any,\n    _mock_predict: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test query.\"\"\"\n    index_kwargs, query_configs = struct_kwargs\n    list_kwargs = index_kwargs[\"list\"]\n    tree_kwargs = index_kwargs[\"tree\"]\n    # try building a list for every two, then a tree\n    list1 = GPTListIndex(documents[0:2], **list_kwargs)\n    list1.set_text(\"summary1\")\n ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 14, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "15": {"text": "   list1.set_text(\"summary1\")\n    list2 = GPTListIndex(documents[2:4], **list_kwargs)\n    list2.set_text(\"summary2\")\n    list3 = GPTListIndex(documents[4:6], **list_kwargs)\n    list3.set_text(\"summary3\")\n    list4 = GPTListIndex(documents[6:8], **list_kwargs)\n    list4.set_text(\"summary4\")\n\n    # there are two root nodes in this tree: one containing [list1, list2]\n    # and the other containing [list3, list4]\n    # import pdb; pdb.set_trace()\n    tree = GPTTreeIndex(\n        [\n            list1,\n            list2,\n            list3,\n            list4,\n        ],\n        **tree_kwargs\n    )\n    # first pass prompt is \"summary1\\nsummary2\\n\" (6 tokens),\n    # response is the mock response (10 tokens)\n    # total is 16", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 15, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "16": {"text": "response is the mock response (10 tokens)\n    # total is 16 tokens, multiply by 2 to get the total\n    assert tree._llm_predictor.total_tokens_used == 32\n\n    query_str = \"What is?\"\n    # query should first pick the left root node, then pick list1\n    # within list1, it should go through the first document and second document\n    start_token_ct = tree._llm_predictor.total_tokens_used\n    tree.query(query_str, mode=\"recursive\", query_configs=query_configs)\n    # prompt is which is 35 tokens, plus 10 for the mock response\n    assert tree._llm_predictor.total_tokens_used - start_token_ct == 45\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 16, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "17": {"text": "This code file tests recursive queries using a combination of GPTListIndex, GPTTreeIndex, and GPTSimpleKeywordTableIndex. It sets up a fixture with index kwargs and query configs, and then tests recursive queries using a mock token splitter, mock LLMPredictor, and mock documents. The tests check that the query returns the expected response when it is run in recursive and non-recursive modes.", "doc_id": null, "embedding": null, "extra_info": null, "index": 17, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "ref_doc_id": null, "node_info": null}, "18": {"text": "This code file tests the functionality of a recursive query on a GPTListIndex and a GPTSimpleKeywordTableIndex. It tests the query on two tables, each containing two lists, and a tree containing four lists. It also tests the serialization and deserialization of the indices, as well as the total token count used in the query. The purpose of the code is to ensure that the query is functioning correctly and that the data structures are being used correctly.", "doc_id": null, "embedding": null, "extra_info": null, "index": 18, "child_indices": [10, 11, 12, 13, 14, 15, 16], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"17": {"text": "This code file tests recursive queries using a combination of GPTListIndex, GPTTreeIndex, and GPTSimpleKeywordTableIndex. It sets up a fixture with index kwargs and query configs, and then tests recursive queries using a mock token splitter, mock LLMPredictor, and mock documents. The tests check that the query returns the expected response when it is run in recursive and non-recursive modes.", "doc_id": null, "embedding": null, "extra_info": null, "index": 17, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "ref_doc_id": null, "node_info": null}, "18": {"text": "This code file tests the functionality of a recursive query on a GPTListIndex and a GPTSimpleKeywordTableIndex. It tests the query on two tables, each containing two lists, and a tree containing four lists. It also tests the serialization and deserialization of the indices, as well as the total token count used in the query. The purpose of the code is to ensure that the query is functioning correctly and that the data structures are being used correctly.", "doc_id": null, "embedding": null, "extra_info": null, "index": 18, "child_indices": [10, 11, 12, 13, 14, 15, 16], "ref_doc_id": null, "node_info": null}}}, "docstore": {"docs": {"1ed25268212c3ce05ed55f5f93ff110b69836ea8": {"text": "\"\"\"Test recursive queries.\"\"\"\n\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nfrom typing import Any, Dict, List, Tuple\nfrom unittest.mock import patch\n\nimport pytest\n\nfrom gpt_index.composability.graph import ComposableGraph\nfrom gpt_index.data_structs.struct_type import IndexStructType\nfrom gpt_index.indices.keyword_table.simple_base import GPTSimpleKeywordTableIndex\nfrom gpt_index.indices.list.base import GPTListIndex\nfrom gpt_index.indices.query.schema import QueryConfig, QueryMode\nfrom gpt_index.indices.tree.base import GPTTreeIndex\nfrom gpt_index.langchain_helpers.chain_wrapper import (\n    LLMChain,\n    LLMMetadata,\n    LLMPredictor,\n)\nfrom gpt_index.langchain_helpers.text_splitter import TokenTextSplitter\nfrom gpt_index.readers.schema.base import Document\nfrom tests.mock_utils.mock_predict import (\n    mock_llmchain_predict,\n    mock_llmpredictor_predict,\n)\nfrom tests.mock_utils.mock_prompts import (\n    MOCK_INSERT_PROMPT,\n    MOCK_KEYWORD_EXTRACT_PROMPT,\n    MOCK_QUERY_KEYWORD_EXTRACT_PROMPT,\n    MOCK_QUERY_PROMPT,\n    MOCK_REFINE_PROMPT,\n    MOCK_SUMMARY_PROMPT,\n    MOCK_TEXT_QA_PROMPT,\n)\nfrom tests.mock_utils.mock_text_splitter import mock_token_splitter_newline\n\n\n@pytest.fixture\ndef struct_kwargs() -> Tuple[Dict, List]:\n    \"\"\"Index kwargs.\"\"\"\n    index_kwargs = {\n        \"tree\": {\n            \"summary_template\": MOCK_SUMMARY_PROMPT,\n            \"insert_prompt\": MOCK_INSERT_PROMPT,\n            \"num_children\": 2,\n        },\n        \"list\": {\n            \"text_qa_template\": MOCK_TEXT_QA_PROMPT,\n        },\n        \"table\": {\n            \"keyword_extract_template\": MOCK_KEYWORD_EXTRACT_PROMPT,\n        },\n    }\n    query_configs = [\n        QueryConfig(\n            index_struct_type=IndexStructType.TREE,\n            query_mode=QueryMode.DEFAULT,\n            query_kwargs={\n                \"query_template\": MOCK_QUERY_PROMPT,\n                \"text_qa_template\": MOCK_TEXT_QA_PROMPT,\n                \"refine_template\": MOCK_REFINE_PROMPT,\n            },\n        ),\n        QueryConfig(\n            index_struct_type=IndexStructType.LIST,\n            query_mode=QueryMode.DEFAULT,\n            query_kwargs={\n                \"text_qa_template\": MOCK_TEXT_QA_PROMPT,\n                \"refine_template\": MOCK_REFINE_PROMPT,\n            },\n        ),\n        QueryConfig(\n            index_struct_type=IndexStructType.KEYWORD_TABLE,\n            query_mode=QueryMode.DEFAULT,\n            query_kwargs={\n                \"query_keyword_extract_template\": MOCK_QUERY_KEYWORD_EXTRACT_PROMPT,\n                \"text_qa_template\": MOCK_TEXT_QA_PROMPT,\n                \"refine_template\": MOCK_REFINE_PROMPT,\n            },\n        ),\n    ]\n    return index_kwargs, query_configs\n\n\n@pytest.fixture\ndef documents() -> List[Document]:\n    \"\"\"Get documents.\"\"\"\n    docs = [\n        Document(\"This is a test v2.\"),\n        Document(\"This is another test.\"),\n        Document(\"This is a test.\"),\n        Document(\"Hello world.\"),\n        Document(\"Hello world.\"),\n        Document(\"This is a test.\"),\n        Document(\"This is another test.\"),\n        Document(\"This is a test v2.\"),\n    ]\n    return docs\n\n\n@patch.object(TokenTextSplitter, \"split_text\", side_effect=mock_token_splitter_newline)\n@patch.object(LLMPredictor, \"predict\", side_effect=mock_llmpredictor_predict)\n@patch.object(LLMPredictor, \"total_tokens_used\", return_value=0)\n@patch.object(LLMPredictor, \"__init__\", return_value=None)\ndef test_recursive_query_list_tree(\n    _mock_init: Any,\n    _mock_total_tokens_used: Any,\n    _mock_predict: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test query.\"\"\"\n    index_kwargs, query_configs = struct_kwargs\n    list_kwargs = index_kwargs[\"list\"]\n    tree_kwargs = index_kwargs[\"tree\"]\n    # try building a list for every two, then a tree\n    list1 = GPTListIndex(documents[0:2], **list_kwargs)\n    list1.set_text(\"summary1\")\n    list2 = GPTListIndex(documents[2:4], **list_kwargs)\n    list2.set_text(\"summary2\")\n    list3 = GPTListIndex(documents[4:6], **list_kwargs)\n    list3.set_text(\"summary3\")\n    list4 = GPTListIndex(documents[6:8], **list_kwargs)\n    list4.set_text(\"summary4\")\n\n    # there are two root nodes in this tree: one containing [list1, list2]\n    # and the other containing [list3, list4]\n    tree = GPTTreeIndex(\n        [\n            list1,\n            list2,\n            list3,\n            list4,\n        ],\n        **tree_kwargs\n    )\n    query_str = \"What is?\"\n    # query should first pick the left root node, then pick list1\n    # within list1, it should go through the first document and second document\n    response = tree.query(query_str, mode=\"recursive\", query_configs=query_configs)\n    assert str(response) == (\"What is?:This is a test v2.\")\n\n    # Also test a non-recursive query. This should not go down into the list\n    tree_query_kwargs = query_configs[0].query_kwargs\n    response = tree.query(query_str, mode=\"default\", **tree_query_kwargs)\n    assert str(response) == (\"What is?:summary1\")\n\n\n@patch.object(TokenTextSplitter, \"split_text\", side_effect=mock_token_splitter_newline)\n@patch.object(LLMPredictor, \"predict\", side_effect=mock_llmpredictor_predict)\n@patch.object(LLMPredictor, \"total_tokens_used\", return_value=0)\n@patch.object(LLMPredictor, \"__init__\", return_value=None)\ndef test_recursive_query_tree_list(\n    _mock_init: Any,\n    _mock_total_tokens_used: Any,\n    _mock_predict: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test query.\"\"\"\n    index_kwargs, query_configs = struct_kwargs\n    list_kwargs = index_kwargs[\"list\"]\n    tree_kwargs = index_kwargs[\"tree\"]\n    # try building a tree for a group of 4, then a list\n    # use a diff set of documents\n    tree1 = GPTTreeIndex(documents[2:6], **tree_kwargs)\n    tree2 = GPTTreeIndex(documents[:2] + documents[6:], **tree_kwargs)\n    tree1.set_text(\"tree_summary1\")\n    tree2.set_text(\"tree_summary2\")\n\n    # there are two root nodes in this tree: one containing [list1, list2]\n    # and the other containing [list3, list4]\n    list_index = GPTListIndex([tree1, tree2], **list_kwargs)\n    query_str = \"What is?\"\n    # query should first pick the left root node, then pick list1\n    # within list1, it should go through the first document and second document\n    response = list_index.query(\n        query_str, mode=\"recursive\", query_configs=query_configs\n    )\n    assert str(response) == (\"What is?:This is a test.\")\n\n    # Also test a non-recursive query. This should not go down into the list\n    list_query_kwargs = query_configs[1].query_kwargs\n    response = list_index.query(query_str, mode=\"default\", **list_query_kwargs)\n    assert str(response) == (\"What is?:tree_summary1\")\n\n\n@patch.object(TokenTextSplitter, \"split_text\", side_effect=mock_token_splitter_newline)\n@patch.object(LLMPredictor, \"predict\", side_effect=mock_llmpredictor_predict)\n@patch.object(LLMPredictor, \"total_tokens_used\", return_value=0)\n@patch.object(LLMPredictor, \"__init__\", return_value=None)\ndef test_recursive_query_table_list(\n    _mock_init: Any,\n    _mock_total_tokens_used: Any,\n    _mock_predict: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test query.\"\"\"\n    index_kwargs, query_configs = struct_kwargs\n    list_kwargs = index_kwargs[\"list\"]\n    table_kwargs = index_kwargs[\"table\"]\n    # try building a tree for a group of 4, then a list\n    # use a diff set of documents\n    table1 = GPTSimpleKeywordTableIndex(documents[4:6], **table_kwargs)\n    table2 = GPTSimpleKeywordTableIndex(documents[2:3], **table_kwargs)\n    table1.set_text(\"table_summary1\")\n    table2.set_text(\"table_summary2\")\n    table1.set_doc_id(\"table1\")\n    table2.set_doc_id(\"table2\")\n\n    list_index = GPTListIndex([table1, table2], **list_kwargs)\n    query_str = \"World?\"\n    response = list_index.query(\n        query_str, mode=\"recursive\", query_configs=query_configs\n    )\n    assert str(response) == (\"World?:Hello world.\")\n\n    query_str = \"Test?\"\n    response = list_index.query(\n        query_str, mode=\"recursive\", query_configs=query_configs\n    )\n    assert str(response) == (\"Test?:This is a test.\")\n\n    # test serialize and then back\n    with TemporaryDirectory() as tmpdir:\n        graph = ComposableGraph.build_from_index(list_index)\n        graph.save_to_disk(str(Path(tmpdir) / \"tmp.json\"))\n        graph = ComposableGraph.load_from_disk(str(Path(tmpdir) / \"tmp.json\"))\n        response = graph.query(query_str, query_configs=query_configs)\n        assert str(response) == (\"Test?:This is a test.\")\n\n        # test graph.get_index\n        test_table1 = graph.get_index(\"table1\", GPTSimpleKeywordTableIndex)\n        response = test_table1.query(\"Hello\")\n        assert str(response) == (\"Hello:Hello world.\")\n\n\n@patch.object(TokenTextSplitter, \"split_text\", side_effect=mock_token_splitter_newline)\n@patch.object(LLMPredictor, \"predict\", side_effect=mock_llmpredictor_predict)\n@patch.object(LLMPredictor, \"total_tokens_used\", return_value=0)\n@patch.object(LLMPredictor, \"__init__\", return_value=None)\ndef test_recursive_query_list_table(\n    _mock_init: Any,\n    _mock_total_tokens_used: Any,\n    _mock_predict: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test query.\"\"\"\n    index_kwargs, query_configs = struct_kwargs\n    list_kwargs = index_kwargs[\"list\"]\n    table_kwargs = index_kwargs[\"table\"]\n    # try building a tree for a group of 4, then a list\n    # use a diff set of documents\n    # try building a list for every two, then a tree\n    list1 = GPTListIndex(documents[0:2], **list_kwargs)\n    list1.set_text(\"foo bar\")\n    list2 = GPTListIndex(documents[2:4], **list_kwargs)\n    list2.set_text(\"apple orange\")\n    list3 = GPTListIndex(documents[4:6], **list_kwargs)\n    list3.set_text(\"toronto london\")\n    list4 = GPTListIndex(documents[6:8], **list_kwargs)\n    list4.set_text(\"cat dog\")\n\n    table = GPTSimpleKeywordTableIndex([list1, list2, list3, list4], **table_kwargs)\n    query_str = \"Foo?\"\n    response = table.query(query_str, mode=\"recursive\", query_configs=query_configs)\n    assert str(response) == (\"Foo?:This is a test v2.\")\n    query_str = \"Orange?\"\n    response = table.query(query_str, mode=\"recursive\", query_configs=query_configs)\n    assert str(response) == (\"Orange?:This is a test.\")\n    query_str = \"Cat?\"\n    response = table.query(query_str, mode=\"recursive\", query_configs=query_configs)\n    assert str(response) == (\"Cat?:This is another test.\")\n\n    # test serialize and then back\n    # use composable graph struct\n    with TemporaryDirectory() as tmpdir:\n        graph = ComposableGraph.build_from_index(table)\n        graph.save_to_disk(str(Path(tmpdir) / \"tmp.json\"))\n        graph = ComposableGraph.load_from_disk(str(Path(tmpdir) / \"tmp.json\"))\n        response = graph.query(query_str, query_configs=query_configs)\n        assert str(response) == (\"Cat?:This is another test.\")\n\n\n@patch.object(LLMChain, \"predict\", side_effect=mock_llmchain_predict)\n@patch(\"gpt_index.langchain_helpers.chain_wrapper.OpenAI\")\n@patch.object(LLMPredictor, \"get_llm_metadata\", return_value=LLMMetadata())\n@patch.object(LLMChain, \"__init__\", return_value=None)\ndef test_recursive_query_list_tree_token_count(\n    _mock_init: Any,\n    _mock_llm_metadata: Any,\n    _mock_llmchain: Any,\n    _mock_predict: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test query.\"\"\"\n    index_kwargs, query_configs = struct_kwargs\n    list_kwargs = index_kwargs[\"list\"]\n    tree_kwargs = index_kwargs[\"tree\"]\n    # try building a list for every two, then a tree\n    list1 = GPTListIndex(documents[0:2], **list_kwargs)\n    list1.set_text(\"summary1\")\n    list2 = GPTListIndex(documents[2:4], **list_kwargs)\n    list2.set_text(\"summary2\")\n    list3 = GPTListIndex(documents[4:6], **list_kwargs)\n    list3.set_text(\"summary3\")\n    list4 = GPTListIndex(documents[6:8], **list_kwargs)\n    list4.set_text(\"summary4\")\n\n    # there are two root nodes in this tree: one containing [list1, list2]\n    # and the other containing [list3, list4]\n    # import pdb; pdb.set_trace()\n    tree = GPTTreeIndex(\n        [\n            list1,\n            list2,\n            list3,\n            list4,\n        ],\n        **tree_kwargs\n    )\n    # first pass prompt is \"summary1\\nsummary2\\n\" (6 tokens),\n    # response is the mock response (10 tokens)\n    # total is 16 tokens, multiply by 2 to get the total\n    assert tree._llm_predictor.total_tokens_used == 32\n\n    query_str = \"What is?\"\n    # query should first pick the left root node, then pick list1\n    # within list1, it should go through the first document and second document\n    start_token_ct = tree._llm_predictor.total_tokens_used\n    tree.query(query_str, mode=\"recursive\", query_configs=query_configs)\n    # prompt is which is 35 tokens, plus 10 for the mock response\n    assert tree._llm_predictor.total_tokens_used - start_token_ct == 45\n", "doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "__type__": "Document"}, "110501d1-b11c-4125-9d21-715ab6e87c39": {"text": "\nThis code file tests the functionality of a recursive query on GPT-Index, a library for creating composable indices. It sets up a fixture with index keyword arguments and query configs, and then tests recursive queries using mock objects to simulate the behavior of the library's components. The tests check that the query returns the expected response when it is run in recursive and non-recursive modes, and that the serialization and deserialization of the indices, as well as the total token count used in the query, are functioning correctly. The purpose of the code is to ensure that the query is working properly and that the data structures are being used correctly.", "doc_id": "110501d1-b11c-4125-9d21-715ab6e87c39", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"Test recursive queries.\"\"\"\n\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nfrom typing import Any, Dict, List, Tuple\nfrom unittest.mock import patch\n\nimport pytest\n\nfrom gpt_index.composability.graph import ComposableGraph\nfrom gpt_index.data_structs.struct_type import IndexStructType\nfrom gpt_index.indices.keyword_table.simple_base import GPTSimpleKeywordTableIndex\nfrom gpt_index.indices.list.base import GPTListIndex\nfrom gpt_index.indices.query.schema import QueryConfig, QueryMode\nfrom gpt_index.indices.tree.base import GPTTreeIndex\nfrom gpt_index.langchain_helpers.chain_wrapper import (\n    LLMChain,\n    LLMMetadata,\n    LLMPredictor,\n)\nfrom gpt_index.langchain_helpers.text_splitter import TokenTextSplitter\nfrom gpt_index.readers.schema.base import Document\nfrom tests.mock_utils.mock_predict import (\n    mock_llmchain_predict,\n    mock_llmpredictor_predict,\n)\nfrom tests.mock_utils.mock_prompts import (\n    MOCK_INSERT_PROMPT,\n   ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 0, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "1": {"text": "import (\n    MOCK_INSERT_PROMPT,\n    MOCK_KEYWORD_EXTRACT_PROMPT,\n    MOCK_QUERY_KEYWORD_EXTRACT_PROMPT,\n    MOCK_QUERY_PROMPT,\n    MOCK_REFINE_PROMPT,\n    MOCK_SUMMARY_PROMPT,\n    MOCK_TEXT_QA_PROMPT,\n)\nfrom tests.mock_utils.mock_text_splitter import mock_token_splitter_newline\n\n\n@pytest.fixture\ndef struct_kwargs() -> Tuple[Dict, List]:\n    \"\"\"Index kwargs.\"\"\"\n    index_kwargs = {\n        \"tree\": {\n            \"summary_template\": MOCK_SUMMARY_PROMPT,\n            \"insert_prompt\": MOCK_INSERT_PROMPT,\n            \"num_children\": 2,\n        },\n        \"list\": {\n            \"text_qa_template\": MOCK_TEXT_QA_PROMPT,\n        },\n       ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 1, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "2": {"text": "       },\n        \"table\": {\n            \"keyword_extract_template\": MOCK_KEYWORD_EXTRACT_PROMPT,\n        },\n    }\n    query_configs = [\n        QueryConfig(\n            index_struct_type=IndexStructType.TREE,\n            query_mode=QueryMode.DEFAULT,\n            query_kwargs={\n                \"query_template\": MOCK_QUERY_PROMPT,\n                \"text_qa_template\": MOCK_TEXT_QA_PROMPT,\n                \"refine_template\": MOCK_REFINE_PROMPT,\n            },\n        ),\n        QueryConfig(\n            index_struct_type=IndexStructType.LIST,\n            query_mode=QueryMode.DEFAULT,\n           ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 2, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "3": {"text": "           query_kwargs={\n                \"text_qa_template\": MOCK_TEXT_QA_PROMPT,\n                \"refine_template\": MOCK_REFINE_PROMPT,\n            },\n        ),\n        QueryConfig(\n            index_struct_type=IndexStructType.KEYWORD_TABLE,\n            query_mode=QueryMode.DEFAULT,\n            query_kwargs={\n                \"query_keyword_extract_template\": MOCK_QUERY_KEYWORD_EXTRACT_PROMPT,\n                \"text_qa_template\": MOCK_TEXT_QA_PROMPT,\n                \"refine_template\": MOCK_REFINE_PROMPT,\n            },\n        ),\n    ]\n    return index_kwargs, query_configs\n\n\n@pytest.fixture\ndef", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 3, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "4": {"text": "return index_kwargs, query_configs\n\n\n@pytest.fixture\ndef documents() -> List[Document]:\n    \"\"\"Get documents.\"\"\"\n    docs = [\n        Document(\"This is a test v2.\"),\n        Document(\"This is another test.\"),\n        Document(\"This is a test.\"),\n        Document(\"Hello world.\"),\n        Document(\"Hello world.\"),\n        Document(\"This is a test.\"),\n        Document(\"This is another test.\"),\n        Document(\"This is a test v2.\"),\n    ]\n    return docs\n\n\n@patch.object(TokenTextSplitter, \"split_text\", side_effect=mock_token_splitter_newline)\n@patch.object(LLMPredictor, \"predict\", side_effect=mock_llmpredictor_predict)\n@patch.object(LLMPredictor, \"total_tokens_used\", return_value=0)\n@patch.object(LLMPredictor, \"__init__\", return_value=None)\ndef test_recursive_query_list_tree(\n    _mock_init: Any,\n    _mock_total_tokens_used: Any,\n   ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 4, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "5": {"text": "  _mock_total_tokens_used: Any,\n    _mock_predict: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test query.\"\"\"\n    index_kwargs, query_configs = struct_kwargs\n    list_kwargs = index_kwargs[\"list\"]\n    tree_kwargs = index_kwargs[\"tree\"]\n    # try building a list for every two, then a tree\n    list1 = GPTListIndex(documents[0:2], **list_kwargs)\n    list1.set_text(\"summary1\")\n    list2 = GPTListIndex(documents[2:4], **list_kwargs)\n    list2.set_text(\"summary2\")\n    list3 = GPTListIndex(documents[4:6], **list_kwargs)\n    list3.set_text(\"summary3\")\n    list4 = GPTListIndex(documents[6:8], **list_kwargs)\n    list4.set_text(\"summary4\")\n\n    # there are two root nodes in this tree: one containing [list1, list2]\n    # and the other containing [list3, list4]\n    tree", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 5, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "6": {"text": "   # and the other containing [list3, list4]\n    tree = GPTTreeIndex(\n        [\n            list1,\n            list2,\n            list3,\n            list4,\n        ],\n        **tree_kwargs\n    )\n    query_str = \"What is?\"\n    # query should first pick the left root node, then pick list1\n    # within list1, it should go through the first document and second document\n    response = tree.query(query_str, mode=\"recursive\", query_configs=query_configs)\n    assert str(response) == (\"What is?:This is a test v2.\")\n\n    # Also test a non-recursive query. This should not go down into the list\n    tree_query_kwargs = query_configs[0].query_kwargs\n    response = tree.query(query_str, mode=\"default\", **tree_query_kwargs)\n    assert str(response) == (\"What is?:summary1\")\n\n\n@patch.object(TokenTextSplitter, \"split_text\",", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 6, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "7": {"text": "\"split_text\", side_effect=mock_token_splitter_newline)\n@patch.object(LLMPredictor, \"predict\", side_effect=mock_llmpredictor_predict)\n@patch.object(LLMPredictor, \"total_tokens_used\", return_value=0)\n@patch.object(LLMPredictor, \"__init__\", return_value=None)\ndef test_recursive_query_tree_list(\n    _mock_init: Any,\n    _mock_total_tokens_used: Any,\n    _mock_predict: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test query.\"\"\"\n    index_kwargs, query_configs = struct_kwargs\n    list_kwargs = index_kwargs[\"list\"]\n    tree_kwargs = index_kwargs[\"tree\"]\n    # try building a tree for a group of 4, then a list\n    # use a diff set of documents\n    tree1 = GPTTreeIndex(documents[2:6], **tree_kwargs)\n    tree2 = GPTTreeIndex(documents[:2] + documents[6:], **tree_kwargs)\n   ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 7, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "8": {"text": "+ documents[6:], **tree_kwargs)\n    tree1.set_text(\"tree_summary1\")\n    tree2.set_text(\"tree_summary2\")\n\n    # there are two root nodes in this tree: one containing [list1, list2]\n    # and the other containing [list3, list4]\n    list_index = GPTListIndex([tree1, tree2], **list_kwargs)\n    query_str = \"What is?\"\n    # query should first pick the left root node, then pick list1\n    # within list1, it should go through the first document and second document\n    response = list_index.query(\n        query_str, mode=\"recursive\", query_configs=query_configs\n    )\n    assert str(response) == (\"What is?:This is a test.\")\n\n    # Also test a non-recursive query. This should not go down into the list\n    list_query_kwargs = query_configs[1].query_kwargs\n    response = list_index.query(query_str, mode=\"default\", **list_query_kwargs)\n    assert str(response) == (\"What is?:tree_summary1\")\n\n\n@patch.object(TokenTextSplitter, \"split_text\",", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 8, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "9": {"text": "\"split_text\", side_effect=mock_token_splitter_newline)\n@patch.object(LLMPredictor, \"predict\", side_effect=mock_llmpredictor_predict)\n@patch.object(LLMPredictor, \"total_tokens_used\", return_value=0)\n@patch.object(LLMPredictor, \"__init__\", return_value=None)\ndef test_recursive_query_table_list(\n    _mock_init: Any,\n    _mock_total_tokens_used: Any,\n    _mock_predict: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test query.\"\"\"\n    index_kwargs, query_configs = struct_kwargs\n    list_kwargs = index_kwargs[\"list\"]\n    table_kwargs = index_kwargs[\"table\"]\n    # try building a tree for a group of 4, then a list\n    # use a diff set of documents\n    table1 = GPTSimpleKeywordTableIndex(documents[4:6], **table_kwargs)\n    table2 = GPTSimpleKeywordTableIndex(documents[2:3], **table_kwargs)\n   ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 9, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "10": {"text": "**table_kwargs)\n    table1.set_text(\"table_summary1\")\n    table2.set_text(\"table_summary2\")\n    table1.set_doc_id(\"table1\")\n    table2.set_doc_id(\"table2\")\n\n    list_index = GPTListIndex([table1, table2], **list_kwargs)\n    query_str = \"World?\"\n    response = list_index.query(\n        query_str, mode=\"recursive\", query_configs=query_configs\n    )\n    assert str(response) == (\"World?:Hello world.\")\n\n    query_str = \"Test?\"\n    response = list_index.query(\n        query_str, mode=\"recursive\", query_configs=query_configs\n    )\n    assert str(response) == (\"Test?:This is a test.\")\n\n    # test serialize and then back\n    with TemporaryDirectory() as tmpdir:\n        graph = ComposableGraph.build_from_index(list_index)\n        graph.save_to_disk(str(Path(tmpdir) / \"tmp.json\"))\n        graph = ComposableGraph.load_from_disk(str(Path(tmpdir) /", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 10, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "11": {"text": "= ComposableGraph.load_from_disk(str(Path(tmpdir) / \"tmp.json\"))\n        response = graph.query(query_str, query_configs=query_configs)\n        assert str(response) == (\"Test?:This is a test.\")\n\n        # test graph.get_index\n        test_table1 = graph.get_index(\"table1\", GPTSimpleKeywordTableIndex)\n        response = test_table1.query(\"Hello\")\n        assert str(response) == (\"Hello:Hello world.\")\n\n\n@patch.object(TokenTextSplitter, \"split_text\", side_effect=mock_token_splitter_newline)\n@patch.object(LLMPredictor, \"predict\", side_effect=mock_llmpredictor_predict)\n@patch.object(LLMPredictor, \"total_tokens_used\", return_value=0)\n@patch.object(LLMPredictor, \"__init__\", return_value=None)\ndef test_recursive_query_list_table(\n    _mock_init: Any,\n    _mock_total_tokens_used: Any,\n    _mock_predict: Any,\n    _mock_split_text: Any,\n    documents:", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 11, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "12": {"text": "   _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test query.\"\"\"\n    index_kwargs, query_configs = struct_kwargs\n    list_kwargs = index_kwargs[\"list\"]\n    table_kwargs = index_kwargs[\"table\"]\n    # try building a tree for a group of 4, then a list\n    # use a diff set of documents\n    # try building a list for every two, then a tree\n    list1 = GPTListIndex(documents[0:2], **list_kwargs)\n    list1.set_text(\"foo bar\")\n    list2 = GPTListIndex(documents[2:4], **list_kwargs)\n    list2.set_text(\"apple orange\")\n    list3 = GPTListIndex(documents[4:6], **list_kwargs)\n    list3.set_text(\"toronto london\")\n    list4 = GPTListIndex(documents[6:8], **list_kwargs)\n    list4.set_text(\"cat dog\")\n\n    table = GPTSimpleKeywordTableIndex([list1, list2, list3, list4], **table_kwargs)\n    query_str =", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 12, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "13": {"text": "list3, list4], **table_kwargs)\n    query_str = \"Foo?\"\n    response = table.query(query_str, mode=\"recursive\", query_configs=query_configs)\n    assert str(response) == (\"Foo?:This is a test v2.\")\n    query_str = \"Orange?\"\n    response = table.query(query_str, mode=\"recursive\", query_configs=query_configs)\n    assert str(response) == (\"Orange?:This is a test.\")\n    query_str = \"Cat?\"\n    response = table.query(query_str, mode=\"recursive\", query_configs=query_configs)\n    assert str(response) == (\"Cat?:This is another test.\")\n\n    # test serialize and then back\n    # use composable graph struct\n    with TemporaryDirectory() as tmpdir:\n        graph = ComposableGraph.build_from_index(table)\n        graph.save_to_disk(str(Path(tmpdir) / \"tmp.json\"))\n        graph = ComposableGraph.load_from_disk(str(Path(tmpdir) / \"tmp.json\"))\n        response = graph.query(query_str, query_configs=query_configs)\n       ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 13, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "14": {"text": "query_configs=query_configs)\n        assert str(response) == (\"Cat?:This is another test.\")\n\n\n@patch.object(LLMChain, \"predict\", side_effect=mock_llmchain_predict)\n@patch(\"gpt_index.langchain_helpers.chain_wrapper.OpenAI\")\n@patch.object(LLMPredictor, \"get_llm_metadata\", return_value=LLMMetadata())\n@patch.object(LLMChain, \"__init__\", return_value=None)\ndef test_recursive_query_list_tree_token_count(\n    _mock_init: Any,\n    _mock_llm_metadata: Any,\n    _mock_llmchain: Any,\n    _mock_predict: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test query.\"\"\"\n    index_kwargs, query_configs = struct_kwargs\n    list_kwargs = index_kwargs[\"list\"]\n    tree_kwargs = index_kwargs[\"tree\"]\n    # try building a list for every two, then a tree\n    list1 = GPTListIndex(documents[0:2], **list_kwargs)\n    list1.set_text(\"summary1\")\n ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 14, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "15": {"text": "   list1.set_text(\"summary1\")\n    list2 = GPTListIndex(documents[2:4], **list_kwargs)\n    list2.set_text(\"summary2\")\n    list3 = GPTListIndex(documents[4:6], **list_kwargs)\n    list3.set_text(\"summary3\")\n    list4 = GPTListIndex(documents[6:8], **list_kwargs)\n    list4.set_text(\"summary4\")\n\n    # there are two root nodes in this tree: one containing [list1, list2]\n    # and the other containing [list3, list4]\n    # import pdb; pdb.set_trace()\n    tree = GPTTreeIndex(\n        [\n            list1,\n            list2,\n            list3,\n            list4,\n        ],\n        **tree_kwargs\n    )\n    # first pass prompt is \"summary1\\nsummary2\\n\" (6 tokens),\n    # response is the mock response (10 tokens)\n    # total is 16", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 15, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "16": {"text": "response is the mock response (10 tokens)\n    # total is 16 tokens, multiply by 2 to get the total\n    assert tree._llm_predictor.total_tokens_used == 32\n\n    query_str = \"What is?\"\n    # query should first pick the left root node, then pick list1\n    # within list1, it should go through the first document and second document\n    start_token_ct = tree._llm_predictor.total_tokens_used\n    tree.query(query_str, mode=\"recursive\", query_configs=query_configs)\n    # prompt is which is 35 tokens, plus 10 for the mock response\n    assert tree._llm_predictor.total_tokens_used - start_token_ct == 45\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/query/test_recursive.py", "file_name": "test_recursive.py"}, "index": 16, "child_indices": [], "ref_doc_id": "1ed25268212c3ce05ed55f5f93ff110b69836ea8", "node_info": null}, "17": {"text": "This code file tests recursive queries using a combination of GPTListIndex, GPTTreeIndex, and GPTSimpleKeywordTableIndex. It sets up a fixture with index kwargs and query configs, and then tests recursive queries using a mock token splitter, mock LLMPredictor, and mock documents. The tests check that the query returns the expected response when it is run in recursive and non-recursive modes.", "doc_id": null, "embedding": null, "extra_info": null, "index": 17, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "ref_doc_id": null, "node_info": null}, "18": {"text": "This code file tests the functionality of a recursive query on a GPTListIndex and a GPTSimpleKeywordTableIndex. It tests the query on two tables, each containing two lists, and a tree containing four lists. It also tests the serialization and deserialization of the indices, as well as the total token count used in the query. The purpose of the code is to ensure that the query is functioning correctly and that the data structures are being used correctly.", "doc_id": null, "embedding": null, "extra_info": null, "index": 18, "child_indices": [10, 11, 12, 13, 14, 15, 16], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"17": {"text": "This code file tests recursive queries using a combination of GPTListIndex, GPTTreeIndex, and GPTSimpleKeywordTableIndex. It sets up a fixture with index kwargs and query configs, and then tests recursive queries using a mock token splitter, mock LLMPredictor, and mock documents. The tests check that the query returns the expected response when it is run in recursive and non-recursive modes.", "doc_id": null, "embedding": null, "extra_info": null, "index": 17, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "ref_doc_id": null, "node_info": null}, "18": {"text": "This code file tests the functionality of a recursive query on a GPTListIndex and a GPTSimpleKeywordTableIndex. It tests the query on two tables, each containing two lists, and a tree containing four lists. It also tests the serialization and deserialization of the indices, as well as the total token count used in the query. The purpose of the code is to ensure that the query is functioning correctly and that the data structures are being used correctly.", "doc_id": null, "embedding": null, "extra_info": null, "index": 18, "child_indices": [10, 11, 12, 13, 14, 15, 16], "ref_doc_id": null, "node_info": null}}, "__type__": "tree"}}}}