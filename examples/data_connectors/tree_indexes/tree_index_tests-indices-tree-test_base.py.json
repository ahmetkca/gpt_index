{"index_struct": {"text": "\nThis code file tests the GPTTreeIndex class, a tree-based indexing structure used to store and query documents. The test checks the functionality of the class, including building the tree, querying the tree, summarizing the query, and inserting new documents. It also checks that the tree is built correctly, with the correct nodes and text, and that the leaf nodes have the correct embeddings. Additionally, the test checks that the query and summarize modes work correctly. The code uses the LLMChain, LLMPredictor, and OpenAI classes, as well as the mock_llmchain_predict function. The purpose of the code is to ensure that the GPTTreeIndex class is functioning correctly and that documents are being stored and indexed accurately.", "doc_id": "37932076-4eff-4684-841a-6d768a7c7c96", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"Test tree index.\"\"\"\n\nfrom typing import Any, Dict, List, Optional, Tuple\nfrom unittest.mock import patch\n\nimport pytest\n\nfrom gpt_index.data_structs.data_structs import IndexGraph, Node\nfrom gpt_index.indices.tree.base import GPTTreeIndex\nfrom gpt_index.langchain_helpers.chain_wrapper import (\n    LLMChain,\n    LLMMetadata,\n    LLMPredictor,\n)\nfrom gpt_index.readers.schema.base import Document\nfrom tests.mock_utils.mock_decorator import patch_common\nfrom tests.mock_utils.mock_predict import mock_llmchain_predict\nfrom tests.mock_utils.mock_prompts import (\n    MOCK_INSERT_PROMPT,\n    MOCK_QUERY_PROMPT,\n    MOCK_REFINE_PROMPT,\n    MOCK_SUMMARY_PROMPT,\n    MOCK_TEXT_QA_PROMPT,\n)\n\n\n@pytest.fixture\ndef struct_kwargs() -> Tuple[Dict, Dict]:\n    \"\"\"Index kwargs.\"\"\"\n    index_kwargs = {\n        \"summary_template\": MOCK_SUMMARY_PROMPT,\n  ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 0, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "1": {"text": "\"summary_template\": MOCK_SUMMARY_PROMPT,\n        \"insert_prompt\": MOCK_INSERT_PROMPT,\n        \"num_children\": 2,\n    }\n    query_kwargs = {\n        \"query_template\": MOCK_QUERY_PROMPT,\n        \"text_qa_template\": MOCK_TEXT_QA_PROMPT,\n        \"refine_template\": MOCK_REFINE_PROMPT,\n    }\n    return index_kwargs, query_kwargs\n\n\n@pytest.fixture\ndef documents() -> List[Document]:\n    \"\"\"Get documents.\"\"\"\n    # NOTE: one document for now\n    doc_text = (\n        \"Hello world.\\n\"\n        \"This is a test.\\n\"\n        \"This is another test.\\n\"\n        \"This is a test v2.\"\n    )\n    return [Document(doc_text)]\n\n\ndef _get_left_or_right_node(\n    index_graph: IndexGraph, node: Optional[Node], left: bool = True\n) -> Node:\n    \"\"\"Get 'left' or 'right'", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 1, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "2": {"text": "= True\n) -> Node:\n    \"\"\"Get 'left' or 'right' node.\"\"\"\n    if node is None:\n        indices = set(index_graph.root_nodes.keys())\n    else:\n        indices = node.child_indices\n\n    index = min(indices) if left else max(indices)\n\n    if index not in index_graph.all_nodes:\n        raise ValueError(f\"Node {index} not in index_graph.all_nodes\")\n    return index_graph.all_nodes[index]\n\n\n@patch_common\ndef test_build_tree(\n    _mock_init: Any,\n    _mock_predict: Any,\n    _mock_total_tokens_used: Any,\n    _mock_split_text_overlap: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test build tree.\"\"\"\n    index_kwargs, _ = struct_kwargs\n    tree = GPTTreeIndex(documents, **index_kwargs)\n    assert len(tree.index_struct.all_nodes) == 6\n    # check contents", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 2, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "3": {"text": "== 6\n    # check contents of nodes\n    assert tree.index_struct.all_nodes[0].text == \"Hello world.\"\n    assert tree.index_struct.all_nodes[1].text == \"This is a test.\"\n    assert tree.index_struct.all_nodes[2].text == \"This is another test.\"\n    assert tree.index_struct.all_nodes[3].text == \"This is a test v2.\"\n    assert tree.index_struct.all_nodes[4].text == (\"Hello world.\\nThis is a test.\")\n    assert tree.index_struct.all_nodes[5].text == (\n        \"This is another test.\\nThis is a test v2.\"\n    )\n\n\n@patch_common\ndef test_build_tree_with_embed(\n    _mock_init: Any,\n    _mock_predict: Any,\n    _mock_total_tokens_used: Any,\n    _mock_split_text_overlap: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test build tree.\"\"\"\n    index_kwargs, _ = struct_kwargs\n    doc_text", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 3, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "4": {"text": "  index_kwargs, _ = struct_kwargs\n    doc_text = (\n        \"Hello world.\\n\"\n        \"This is a test.\\n\"\n        \"This is another test.\\n\"\n        \"This is a test v2.\"\n    )\n    document = Document(doc_text, embedding=[0.1, 0.2, 0.3])\n    tree = GPTTreeIndex([document], **index_kwargs)\n    assert len(tree.index_struct.all_nodes) == 6\n    # check contents of nodes\n    assert tree.index_struct.all_nodes[0].text == \"Hello world.\"\n    assert tree.index_struct.all_nodes[1].text == \"This is a test.\"\n    assert tree.index_struct.all_nodes[2].text == \"This is another test.\"\n    assert tree.index_struct.all_nodes[3].text == \"This is a test v2.\"\n    # make sure all leaf nodes have embeddings\n    for i in range(4):\n        assert tree.index_struct.all_nodes[i].embedding == [0.1, 0.2, 0.3]\n    assert", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 4, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "5": {"text": "== [0.1, 0.2, 0.3]\n    assert tree.index_struct.all_nodes[4].text == (\"Hello world.\\nThis is a test.\")\n    assert tree.index_struct.all_nodes[5].text == (\n        \"This is another test.\\nThis is a test v2.\"\n    )\n\n\n@patch_common\ndef test_build_tree_multiple(\n    _mock_init: Any,\n    _mock_predict: Any,\n    _mock_total_tokens_used: Any,\n    _mock_split_text_overlap: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test build tree.\"\"\"\n    new_docs = [\n        Document(\"Hello world.\\nThis is a test.\"),\n        Document(\"This is another test.\\nThis is a test v2.\"),\n    ]\n    index_kwargs, _ = struct_kwargs\n    tree = GPTTreeIndex(new_docs, **index_kwargs)\n    assert len(tree.index_struct.all_nodes) == 6\n    # check contents of", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 5, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "6": {"text": "== 6\n    # check contents of nodes\n    assert tree.index_struct.all_nodes[0].text == \"Hello world.\"\n    assert tree.index_struct.all_nodes[1].text == \"This is a test.\"\n    assert tree.index_struct.all_nodes[2].text == \"This is another test.\"\n    assert tree.index_struct.all_nodes[3].text == \"This is a test v2.\"\n\n\n@patch_common\ndef test_query(\n    _mock_init: Any,\n    _mock_predict: Any,\n    _mock_total_tokens_used: Any,\n    _mock_split_text_overlap: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test query.\"\"\"\n    index_kwargs, query_kwargs = struct_kwargs\n    tree = GPTTreeIndex(documents, **index_kwargs)\n\n    # test default query\n    query_str = \"What is?\"\n    response = tree.query(query_str, mode=\"default\", **query_kwargs)\n    assert str(response) == (\"What is?:Hello world.\")\n\n\n@patch_common\ndef", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 6, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "7": {"text": "str(response) == (\"What is?:Hello world.\")\n\n\n@patch_common\ndef test_summarize_query(\n    _mock_init: Any,\n    _mock_predict: Any,\n    _mock_total_tokens_used: Any,\n    _mock_split_text_overlap: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test summarize query.\"\"\"\n    # create tree index without building tree\n    index_kwargs, orig_query_kwargs = struct_kwargs\n    index_kwargs = index_kwargs.copy()\n    index_kwargs.update({\"build_tree\": False})\n    tree = GPTTreeIndex(documents, **index_kwargs)\n\n    # test summarize query\n    query_str = \"What is?\"\n    query_kwargs: Dict[str, Any] = {\n        \"text_qa_template\": MOCK_TEXT_QA_PROMPT,\n        \"num_children\": 2,\n    }\n    # TODO: fix unit test later\n    response = tree.query(query_str, mode=\"summarize\",", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 7, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "8": {"text": "   response = tree.query(query_str, mode=\"summarize\", **query_kwargs)\n    assert str(response) == (\"What is?:Hello world.\")\n\n    # test that default query fails\n    with pytest.raises(ValueError):\n        tree.query(query_str, mode=\"default\", **orig_query_kwargs)\n\n\n@patch_common\ndef test_insert(\n    _mock_init: Any,\n    _mock_predict: Any,\n    _mock_total_tokens_used: Any,\n    _mock_split_text_overlap: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test insert.\"\"\"\n    index_kwargs, _ = struct_kwargs\n    tree = GPTTreeIndex(documents, **index_kwargs)\n\n    # test insert\n    new_doc = Document(\"This is a new doc.\", doc_id=\"new_doc\")\n    tree.insert(new_doc)\n    # Before:\n    # Left root node: \"Hello world.\\nThis is a test.\"\n    # \"Hello world.\", \"This is a test\" are two children of the left root node\n  ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 8, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "9": {"text": "world.\", \"This is a test\" are two children of the left root node\n    # After:\n    # \"Hello world.\\nThis is a test\\n.\\nThis is a new doc.\" is the left root node\n    # \"Hello world\", \"This is a test\\n.This is a new doc.\" are the children\n    # of the left root node.\n    # \"This is a test\", \"This is a new doc.\" are the children of\n    # \"This is a test\\n.This is a new doc.\"\n    left_root = _get_left_or_right_node(tree.index_struct, None)\n    assert left_root.text == \"Hello world.\\nThis is a test.\\nThis is a new doc.\"\n    left_root2 = _get_left_or_right_node(tree.index_struct, left_root)\n    right_root2 = _get_left_or_right_node(tree.index_struct, left_root, left=False)\n    assert left_root2.text == \"Hello world.\"\n    assert right_root2.text == \"This is a test.\\nThis is a new doc.\"\n    left_root3 = _get_left_or_right_node(tree.index_struct, right_root2)\n    right_root3 =", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 9, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "10": {"text": "right_root2)\n    right_root3 = _get_left_or_right_node(tree.index_struct, right_root2, left=False)\n    assert left_root3.text == \"This is a test.\"\n    assert right_root3.text == \"This is a new doc.\"\n    assert right_root3.ref_doc_id == \"new_doc\"\n\n    # test insert from empty (no_id)\n    tree = GPTTreeIndex([], **index_kwargs)\n    new_doc = Document(\"This is a new doc.\")\n    tree.insert(new_doc)\n    assert len(tree.index_struct.all_nodes) == 1\n    assert tree.index_struct.all_nodes[0].text == \"This is a new doc.\"\n\n    # test insert from empty (with_id)\n    tree = GPTTreeIndex([], **index_kwargs)\n    new_doc = Document(\"This is a new doc.\", doc_id=\"new_doc_test\")\n    tree.insert(new_doc)\n    assert len(tree.index_struct.all_nodes) == 1\n    assert tree.index_struct.all_nodes[0].text == \"This is a new doc.\"\n    assert tree.index_struct.all_nodes[0].ref_doc_id ==", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 10, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "11": {"text": "assert tree.index_struct.all_nodes[0].ref_doc_id == \"new_doc_test\"\n\n\n@patch.object(LLMChain, \"predict\", side_effect=mock_llmchain_predict)\n@patch(\"gpt_index.langchain_helpers.chain_wrapper.OpenAI\")\n@patch.object(LLMPredictor, \"get_llm_metadata\", return_value=LLMMetadata())\n@patch.object(LLMChain, \"__init__\", return_value=None)\ndef test_build_and_count_tokens(\n    _mock_init: Any,\n    _mock_llm_metadata: Any,\n    _mock_llmchain: Any,\n    _mock_predict: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test build and count tokens.\"\"\"\n    index_kwargs, _ = struct_kwargs\n    # mock_prompts.MOCK_SUMMARY_PROMPT_TMPL adds a \"\\n\" to the document text\n    # and the document is 23 tokens\n    document_token_count = 24\n    llmchain_mock_resp_token_count = 10\n    tree = GPTTreeIndex(documents,", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 11, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "12": {"text": "= 10\n    tree = GPTTreeIndex(documents, **index_kwargs)\n    assert (\n        tree._llm_predictor.total_tokens_used\n        == document_token_count + llmchain_mock_resp_token_count\n    )\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 12, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "13": {"text": "This test file tests the GPTTreeIndex class, which is used to build a tree index from a list of documents. It tests the build_tree, build_tree_with_embed, build_tree_multiple, query, summarize_query, and insert functions. It checks the contents of the nodes in the tree index, and tests that the query and summarize query functions return the expected results. It also tests that the insert function correctly updates the tree index.", "doc_id": null, "embedding": null, "extra_info": null, "index": 13, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "ref_doc_id": null, "node_info": null}, "14": {"text": "This code file tests the functionality of the GPTTreeIndex class, which is used to store and index documents. It tests the insertion of documents from an empty index, as well as the build and count tokens feature. It also tests the left and right nodes of the index structure, and the reference document ID. The code uses the LLMChain, LLMPredictor, and OpenAI classes, as well as the mock_llmchain_predict function.", "doc_id": null, "embedding": null, "extra_info": null, "index": 14, "child_indices": [10, 11, 12], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"13": {"text": "This test file tests the GPTTreeIndex class, which is used to build a tree index from a list of documents. It tests the build_tree, build_tree_with_embed, build_tree_multiple, query, summarize_query, and insert functions. It checks the contents of the nodes in the tree index, and tests that the query and summarize query functions return the expected results. It also tests that the insert function correctly updates the tree index.", "doc_id": null, "embedding": null, "extra_info": null, "index": 13, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "ref_doc_id": null, "node_info": null}, "14": {"text": "This code file tests the functionality of the GPTTreeIndex class, which is used to store and index documents. It tests the insertion of documents from an empty index, as well as the build and count tokens feature. It also tests the left and right nodes of the index structure, and the reference document ID. The code uses the LLMChain, LLMPredictor, and OpenAI classes, as well as the mock_llmchain_predict function.", "doc_id": null, "embedding": null, "extra_info": null, "index": 14, "child_indices": [10, 11, 12], "ref_doc_id": null, "node_info": null}}}, "docstore": {"docs": {"afb4aa398df65ab659e297655a54660dc23d269e": {"text": "\"\"\"Test tree index.\"\"\"\n\nfrom typing import Any, Dict, List, Optional, Tuple\nfrom unittest.mock import patch\n\nimport pytest\n\nfrom gpt_index.data_structs.data_structs import IndexGraph, Node\nfrom gpt_index.indices.tree.base import GPTTreeIndex\nfrom gpt_index.langchain_helpers.chain_wrapper import (\n    LLMChain,\n    LLMMetadata,\n    LLMPredictor,\n)\nfrom gpt_index.readers.schema.base import Document\nfrom tests.mock_utils.mock_decorator import patch_common\nfrom tests.mock_utils.mock_predict import mock_llmchain_predict\nfrom tests.mock_utils.mock_prompts import (\n    MOCK_INSERT_PROMPT,\n    MOCK_QUERY_PROMPT,\n    MOCK_REFINE_PROMPT,\n    MOCK_SUMMARY_PROMPT,\n    MOCK_TEXT_QA_PROMPT,\n)\n\n\n@pytest.fixture\ndef struct_kwargs() -> Tuple[Dict, Dict]:\n    \"\"\"Index kwargs.\"\"\"\n    index_kwargs = {\n        \"summary_template\": MOCK_SUMMARY_PROMPT,\n        \"insert_prompt\": MOCK_INSERT_PROMPT,\n        \"num_children\": 2,\n    }\n    query_kwargs = {\n        \"query_template\": MOCK_QUERY_PROMPT,\n        \"text_qa_template\": MOCK_TEXT_QA_PROMPT,\n        \"refine_template\": MOCK_REFINE_PROMPT,\n    }\n    return index_kwargs, query_kwargs\n\n\n@pytest.fixture\ndef documents() -> List[Document]:\n    \"\"\"Get documents.\"\"\"\n    # NOTE: one document for now\n    doc_text = (\n        \"Hello world.\\n\"\n        \"This is a test.\\n\"\n        \"This is another test.\\n\"\n        \"This is a test v2.\"\n    )\n    return [Document(doc_text)]\n\n\ndef _get_left_or_right_node(\n    index_graph: IndexGraph, node: Optional[Node], left: bool = True\n) -> Node:\n    \"\"\"Get 'left' or 'right' node.\"\"\"\n    if node is None:\n        indices = set(index_graph.root_nodes.keys())\n    else:\n        indices = node.child_indices\n\n    index = min(indices) if left else max(indices)\n\n    if index not in index_graph.all_nodes:\n        raise ValueError(f\"Node {index} not in index_graph.all_nodes\")\n    return index_graph.all_nodes[index]\n\n\n@patch_common\ndef test_build_tree(\n    _mock_init: Any,\n    _mock_predict: Any,\n    _mock_total_tokens_used: Any,\n    _mock_split_text_overlap: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test build tree.\"\"\"\n    index_kwargs, _ = struct_kwargs\n    tree = GPTTreeIndex(documents, **index_kwargs)\n    assert len(tree.index_struct.all_nodes) == 6\n    # check contents of nodes\n    assert tree.index_struct.all_nodes[0].text == \"Hello world.\"\n    assert tree.index_struct.all_nodes[1].text == \"This is a test.\"\n    assert tree.index_struct.all_nodes[2].text == \"This is another test.\"\n    assert tree.index_struct.all_nodes[3].text == \"This is a test v2.\"\n    assert tree.index_struct.all_nodes[4].text == (\"Hello world.\\nThis is a test.\")\n    assert tree.index_struct.all_nodes[5].text == (\n        \"This is another test.\\nThis is a test v2.\"\n    )\n\n\n@patch_common\ndef test_build_tree_with_embed(\n    _mock_init: Any,\n    _mock_predict: Any,\n    _mock_total_tokens_used: Any,\n    _mock_split_text_overlap: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test build tree.\"\"\"\n    index_kwargs, _ = struct_kwargs\n    doc_text = (\n        \"Hello world.\\n\"\n        \"This is a test.\\n\"\n        \"This is another test.\\n\"\n        \"This is a test v2.\"\n    )\n    document = Document(doc_text, embedding=[0.1, 0.2, 0.3])\n    tree = GPTTreeIndex([document], **index_kwargs)\n    assert len(tree.index_struct.all_nodes) == 6\n    # check contents of nodes\n    assert tree.index_struct.all_nodes[0].text == \"Hello world.\"\n    assert tree.index_struct.all_nodes[1].text == \"This is a test.\"\n    assert tree.index_struct.all_nodes[2].text == \"This is another test.\"\n    assert tree.index_struct.all_nodes[3].text == \"This is a test v2.\"\n    # make sure all leaf nodes have embeddings\n    for i in range(4):\n        assert tree.index_struct.all_nodes[i].embedding == [0.1, 0.2, 0.3]\n    assert tree.index_struct.all_nodes[4].text == (\"Hello world.\\nThis is a test.\")\n    assert tree.index_struct.all_nodes[5].text == (\n        \"This is another test.\\nThis is a test v2.\"\n    )\n\n\n@patch_common\ndef test_build_tree_multiple(\n    _mock_init: Any,\n    _mock_predict: Any,\n    _mock_total_tokens_used: Any,\n    _mock_split_text_overlap: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test build tree.\"\"\"\n    new_docs = [\n        Document(\"Hello world.\\nThis is a test.\"),\n        Document(\"This is another test.\\nThis is a test v2.\"),\n    ]\n    index_kwargs, _ = struct_kwargs\n    tree = GPTTreeIndex(new_docs, **index_kwargs)\n    assert len(tree.index_struct.all_nodes) == 6\n    # check contents of nodes\n    assert tree.index_struct.all_nodes[0].text == \"Hello world.\"\n    assert tree.index_struct.all_nodes[1].text == \"This is a test.\"\n    assert tree.index_struct.all_nodes[2].text == \"This is another test.\"\n    assert tree.index_struct.all_nodes[3].text == \"This is a test v2.\"\n\n\n@patch_common\ndef test_query(\n    _mock_init: Any,\n    _mock_predict: Any,\n    _mock_total_tokens_used: Any,\n    _mock_split_text_overlap: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test query.\"\"\"\n    index_kwargs, query_kwargs = struct_kwargs\n    tree = GPTTreeIndex(documents, **index_kwargs)\n\n    # test default query\n    query_str = \"What is?\"\n    response = tree.query(query_str, mode=\"default\", **query_kwargs)\n    assert str(response) == (\"What is?:Hello world.\")\n\n\n@patch_common\ndef test_summarize_query(\n    _mock_init: Any,\n    _mock_predict: Any,\n    _mock_total_tokens_used: Any,\n    _mock_split_text_overlap: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test summarize query.\"\"\"\n    # create tree index without building tree\n    index_kwargs, orig_query_kwargs = struct_kwargs\n    index_kwargs = index_kwargs.copy()\n    index_kwargs.update({\"build_tree\": False})\n    tree = GPTTreeIndex(documents, **index_kwargs)\n\n    # test summarize query\n    query_str = \"What is?\"\n    query_kwargs: Dict[str, Any] = {\n        \"text_qa_template\": MOCK_TEXT_QA_PROMPT,\n        \"num_children\": 2,\n    }\n    # TODO: fix unit test later\n    response = tree.query(query_str, mode=\"summarize\", **query_kwargs)\n    assert str(response) == (\"What is?:Hello world.\")\n\n    # test that default query fails\n    with pytest.raises(ValueError):\n        tree.query(query_str, mode=\"default\", **orig_query_kwargs)\n\n\n@patch_common\ndef test_insert(\n    _mock_init: Any,\n    _mock_predict: Any,\n    _mock_total_tokens_used: Any,\n    _mock_split_text_overlap: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test insert.\"\"\"\n    index_kwargs, _ = struct_kwargs\n    tree = GPTTreeIndex(documents, **index_kwargs)\n\n    # test insert\n    new_doc = Document(\"This is a new doc.\", doc_id=\"new_doc\")\n    tree.insert(new_doc)\n    # Before:\n    # Left root node: \"Hello world.\\nThis is a test.\"\n    # \"Hello world.\", \"This is a test\" are two children of the left root node\n    # After:\n    # \"Hello world.\\nThis is a test\\n.\\nThis is a new doc.\" is the left root node\n    # \"Hello world\", \"This is a test\\n.This is a new doc.\" are the children\n    # of the left root node.\n    # \"This is a test\", \"This is a new doc.\" are the children of\n    # \"This is a test\\n.This is a new doc.\"\n    left_root = _get_left_or_right_node(tree.index_struct, None)\n    assert left_root.text == \"Hello world.\\nThis is a test.\\nThis is a new doc.\"\n    left_root2 = _get_left_or_right_node(tree.index_struct, left_root)\n    right_root2 = _get_left_or_right_node(tree.index_struct, left_root, left=False)\n    assert left_root2.text == \"Hello world.\"\n    assert right_root2.text == \"This is a test.\\nThis is a new doc.\"\n    left_root3 = _get_left_or_right_node(tree.index_struct, right_root2)\n    right_root3 = _get_left_or_right_node(tree.index_struct, right_root2, left=False)\n    assert left_root3.text == \"This is a test.\"\n    assert right_root3.text == \"This is a new doc.\"\n    assert right_root3.ref_doc_id == \"new_doc\"\n\n    # test insert from empty (no_id)\n    tree = GPTTreeIndex([], **index_kwargs)\n    new_doc = Document(\"This is a new doc.\")\n    tree.insert(new_doc)\n    assert len(tree.index_struct.all_nodes) == 1\n    assert tree.index_struct.all_nodes[0].text == \"This is a new doc.\"\n\n    # test insert from empty (with_id)\n    tree = GPTTreeIndex([], **index_kwargs)\n    new_doc = Document(\"This is a new doc.\", doc_id=\"new_doc_test\")\n    tree.insert(new_doc)\n    assert len(tree.index_struct.all_nodes) == 1\n    assert tree.index_struct.all_nodes[0].text == \"This is a new doc.\"\n    assert tree.index_struct.all_nodes[0].ref_doc_id == \"new_doc_test\"\n\n\n@patch.object(LLMChain, \"predict\", side_effect=mock_llmchain_predict)\n@patch(\"gpt_index.langchain_helpers.chain_wrapper.OpenAI\")\n@patch.object(LLMPredictor, \"get_llm_metadata\", return_value=LLMMetadata())\n@patch.object(LLMChain, \"__init__\", return_value=None)\ndef test_build_and_count_tokens(\n    _mock_init: Any,\n    _mock_llm_metadata: Any,\n    _mock_llmchain: Any,\n    _mock_predict: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test build and count tokens.\"\"\"\n    index_kwargs, _ = struct_kwargs\n    # mock_prompts.MOCK_SUMMARY_PROMPT_TMPL adds a \"\\n\" to the document text\n    # and the document is 23 tokens\n    document_token_count = 24\n    llmchain_mock_resp_token_count = 10\n    tree = GPTTreeIndex(documents, **index_kwargs)\n    assert (\n        tree._llm_predictor.total_tokens_used\n        == document_token_count + llmchain_mock_resp_token_count\n    )\n", "doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "__type__": "Document"}, "37932076-4eff-4684-841a-6d768a7c7c96": {"text": "\nThis code file tests the GPTTreeIndex class, a tree-based indexing structure used to store and query documents. The test checks the functionality of the class, including building the tree, querying the tree, summarizing the query, and inserting new documents. It also checks that the tree is built correctly, with the correct nodes and text, and that the leaf nodes have the correct embeddings. Additionally, the test checks that the query and summarize modes work correctly. The code uses the LLMChain, LLMPredictor, and OpenAI classes, as well as the mock_llmchain_predict function. The purpose of the code is to ensure that the GPTTreeIndex class is functioning correctly and that documents are being stored and indexed accurately.", "doc_id": "37932076-4eff-4684-841a-6d768a7c7c96", "embedding": null, "extra_info": null, "all_nodes": {"0": {"text": "\"\"\"Test tree index.\"\"\"\n\nfrom typing import Any, Dict, List, Optional, Tuple\nfrom unittest.mock import patch\n\nimport pytest\n\nfrom gpt_index.data_structs.data_structs import IndexGraph, Node\nfrom gpt_index.indices.tree.base import GPTTreeIndex\nfrom gpt_index.langchain_helpers.chain_wrapper import (\n    LLMChain,\n    LLMMetadata,\n    LLMPredictor,\n)\nfrom gpt_index.readers.schema.base import Document\nfrom tests.mock_utils.mock_decorator import patch_common\nfrom tests.mock_utils.mock_predict import mock_llmchain_predict\nfrom tests.mock_utils.mock_prompts import (\n    MOCK_INSERT_PROMPT,\n    MOCK_QUERY_PROMPT,\n    MOCK_REFINE_PROMPT,\n    MOCK_SUMMARY_PROMPT,\n    MOCK_TEXT_QA_PROMPT,\n)\n\n\n@pytest.fixture\ndef struct_kwargs() -> Tuple[Dict, Dict]:\n    \"\"\"Index kwargs.\"\"\"\n    index_kwargs = {\n        \"summary_template\": MOCK_SUMMARY_PROMPT,\n  ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 0, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "1": {"text": "\"summary_template\": MOCK_SUMMARY_PROMPT,\n        \"insert_prompt\": MOCK_INSERT_PROMPT,\n        \"num_children\": 2,\n    }\n    query_kwargs = {\n        \"query_template\": MOCK_QUERY_PROMPT,\n        \"text_qa_template\": MOCK_TEXT_QA_PROMPT,\n        \"refine_template\": MOCK_REFINE_PROMPT,\n    }\n    return index_kwargs, query_kwargs\n\n\n@pytest.fixture\ndef documents() -> List[Document]:\n    \"\"\"Get documents.\"\"\"\n    # NOTE: one document for now\n    doc_text = (\n        \"Hello world.\\n\"\n        \"This is a test.\\n\"\n        \"This is another test.\\n\"\n        \"This is a test v2.\"\n    )\n    return [Document(doc_text)]\n\n\ndef _get_left_or_right_node(\n    index_graph: IndexGraph, node: Optional[Node], left: bool = True\n) -> Node:\n    \"\"\"Get 'left' or 'right'", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 1, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "2": {"text": "= True\n) -> Node:\n    \"\"\"Get 'left' or 'right' node.\"\"\"\n    if node is None:\n        indices = set(index_graph.root_nodes.keys())\n    else:\n        indices = node.child_indices\n\n    index = min(indices) if left else max(indices)\n\n    if index not in index_graph.all_nodes:\n        raise ValueError(f\"Node {index} not in index_graph.all_nodes\")\n    return index_graph.all_nodes[index]\n\n\n@patch_common\ndef test_build_tree(\n    _mock_init: Any,\n    _mock_predict: Any,\n    _mock_total_tokens_used: Any,\n    _mock_split_text_overlap: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test build tree.\"\"\"\n    index_kwargs, _ = struct_kwargs\n    tree = GPTTreeIndex(documents, **index_kwargs)\n    assert len(tree.index_struct.all_nodes) == 6\n    # check contents", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 2, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "3": {"text": "== 6\n    # check contents of nodes\n    assert tree.index_struct.all_nodes[0].text == \"Hello world.\"\n    assert tree.index_struct.all_nodes[1].text == \"This is a test.\"\n    assert tree.index_struct.all_nodes[2].text == \"This is another test.\"\n    assert tree.index_struct.all_nodes[3].text == \"This is a test v2.\"\n    assert tree.index_struct.all_nodes[4].text == (\"Hello world.\\nThis is a test.\")\n    assert tree.index_struct.all_nodes[5].text == (\n        \"This is another test.\\nThis is a test v2.\"\n    )\n\n\n@patch_common\ndef test_build_tree_with_embed(\n    _mock_init: Any,\n    _mock_predict: Any,\n    _mock_total_tokens_used: Any,\n    _mock_split_text_overlap: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test build tree.\"\"\"\n    index_kwargs, _ = struct_kwargs\n    doc_text", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 3, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "4": {"text": "  index_kwargs, _ = struct_kwargs\n    doc_text = (\n        \"Hello world.\\n\"\n        \"This is a test.\\n\"\n        \"This is another test.\\n\"\n        \"This is a test v2.\"\n    )\n    document = Document(doc_text, embedding=[0.1, 0.2, 0.3])\n    tree = GPTTreeIndex([document], **index_kwargs)\n    assert len(tree.index_struct.all_nodes) == 6\n    # check contents of nodes\n    assert tree.index_struct.all_nodes[0].text == \"Hello world.\"\n    assert tree.index_struct.all_nodes[1].text == \"This is a test.\"\n    assert tree.index_struct.all_nodes[2].text == \"This is another test.\"\n    assert tree.index_struct.all_nodes[3].text == \"This is a test v2.\"\n    # make sure all leaf nodes have embeddings\n    for i in range(4):\n        assert tree.index_struct.all_nodes[i].embedding == [0.1, 0.2, 0.3]\n    assert", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 4, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "5": {"text": "== [0.1, 0.2, 0.3]\n    assert tree.index_struct.all_nodes[4].text == (\"Hello world.\\nThis is a test.\")\n    assert tree.index_struct.all_nodes[5].text == (\n        \"This is another test.\\nThis is a test v2.\"\n    )\n\n\n@patch_common\ndef test_build_tree_multiple(\n    _mock_init: Any,\n    _mock_predict: Any,\n    _mock_total_tokens_used: Any,\n    _mock_split_text_overlap: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test build tree.\"\"\"\n    new_docs = [\n        Document(\"Hello world.\\nThis is a test.\"),\n        Document(\"This is another test.\\nThis is a test v2.\"),\n    ]\n    index_kwargs, _ = struct_kwargs\n    tree = GPTTreeIndex(new_docs, **index_kwargs)\n    assert len(tree.index_struct.all_nodes) == 6\n    # check contents of", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 5, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "6": {"text": "== 6\n    # check contents of nodes\n    assert tree.index_struct.all_nodes[0].text == \"Hello world.\"\n    assert tree.index_struct.all_nodes[1].text == \"This is a test.\"\n    assert tree.index_struct.all_nodes[2].text == \"This is another test.\"\n    assert tree.index_struct.all_nodes[3].text == \"This is a test v2.\"\n\n\n@patch_common\ndef test_query(\n    _mock_init: Any,\n    _mock_predict: Any,\n    _mock_total_tokens_used: Any,\n    _mock_split_text_overlap: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test query.\"\"\"\n    index_kwargs, query_kwargs = struct_kwargs\n    tree = GPTTreeIndex(documents, **index_kwargs)\n\n    # test default query\n    query_str = \"What is?\"\n    response = tree.query(query_str, mode=\"default\", **query_kwargs)\n    assert str(response) == (\"What is?:Hello world.\")\n\n\n@patch_common\ndef", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 6, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "7": {"text": "str(response) == (\"What is?:Hello world.\")\n\n\n@patch_common\ndef test_summarize_query(\n    _mock_init: Any,\n    _mock_predict: Any,\n    _mock_total_tokens_used: Any,\n    _mock_split_text_overlap: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test summarize query.\"\"\"\n    # create tree index without building tree\n    index_kwargs, orig_query_kwargs = struct_kwargs\n    index_kwargs = index_kwargs.copy()\n    index_kwargs.update({\"build_tree\": False})\n    tree = GPTTreeIndex(documents, **index_kwargs)\n\n    # test summarize query\n    query_str = \"What is?\"\n    query_kwargs: Dict[str, Any] = {\n        \"text_qa_template\": MOCK_TEXT_QA_PROMPT,\n        \"num_children\": 2,\n    }\n    # TODO: fix unit test later\n    response = tree.query(query_str, mode=\"summarize\",", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 7, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "8": {"text": "   response = tree.query(query_str, mode=\"summarize\", **query_kwargs)\n    assert str(response) == (\"What is?:Hello world.\")\n\n    # test that default query fails\n    with pytest.raises(ValueError):\n        tree.query(query_str, mode=\"default\", **orig_query_kwargs)\n\n\n@patch_common\ndef test_insert(\n    _mock_init: Any,\n    _mock_predict: Any,\n    _mock_total_tokens_used: Any,\n    _mock_split_text_overlap: Any,\n    _mock_split_text: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test insert.\"\"\"\n    index_kwargs, _ = struct_kwargs\n    tree = GPTTreeIndex(documents, **index_kwargs)\n\n    # test insert\n    new_doc = Document(\"This is a new doc.\", doc_id=\"new_doc\")\n    tree.insert(new_doc)\n    # Before:\n    # Left root node: \"Hello world.\\nThis is a test.\"\n    # \"Hello world.\", \"This is a test\" are two children of the left root node\n  ", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 8, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "9": {"text": "world.\", \"This is a test\" are two children of the left root node\n    # After:\n    # \"Hello world.\\nThis is a test\\n.\\nThis is a new doc.\" is the left root node\n    # \"Hello world\", \"This is a test\\n.This is a new doc.\" are the children\n    # of the left root node.\n    # \"This is a test\", \"This is a new doc.\" are the children of\n    # \"This is a test\\n.This is a new doc.\"\n    left_root = _get_left_or_right_node(tree.index_struct, None)\n    assert left_root.text == \"Hello world.\\nThis is a test.\\nThis is a new doc.\"\n    left_root2 = _get_left_or_right_node(tree.index_struct, left_root)\n    right_root2 = _get_left_or_right_node(tree.index_struct, left_root, left=False)\n    assert left_root2.text == \"Hello world.\"\n    assert right_root2.text == \"This is a test.\\nThis is a new doc.\"\n    left_root3 = _get_left_or_right_node(tree.index_struct, right_root2)\n    right_root3 =", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 9, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "10": {"text": "right_root2)\n    right_root3 = _get_left_or_right_node(tree.index_struct, right_root2, left=False)\n    assert left_root3.text == \"This is a test.\"\n    assert right_root3.text == \"This is a new doc.\"\n    assert right_root3.ref_doc_id == \"new_doc\"\n\n    # test insert from empty (no_id)\n    tree = GPTTreeIndex([], **index_kwargs)\n    new_doc = Document(\"This is a new doc.\")\n    tree.insert(new_doc)\n    assert len(tree.index_struct.all_nodes) == 1\n    assert tree.index_struct.all_nodes[0].text == \"This is a new doc.\"\n\n    # test insert from empty (with_id)\n    tree = GPTTreeIndex([], **index_kwargs)\n    new_doc = Document(\"This is a new doc.\", doc_id=\"new_doc_test\")\n    tree.insert(new_doc)\n    assert len(tree.index_struct.all_nodes) == 1\n    assert tree.index_struct.all_nodes[0].text == \"This is a new doc.\"\n    assert tree.index_struct.all_nodes[0].ref_doc_id ==", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 10, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "11": {"text": "assert tree.index_struct.all_nodes[0].ref_doc_id == \"new_doc_test\"\n\n\n@patch.object(LLMChain, \"predict\", side_effect=mock_llmchain_predict)\n@patch(\"gpt_index.langchain_helpers.chain_wrapper.OpenAI\")\n@patch.object(LLMPredictor, \"get_llm_metadata\", return_value=LLMMetadata())\n@patch.object(LLMChain, \"__init__\", return_value=None)\ndef test_build_and_count_tokens(\n    _mock_init: Any,\n    _mock_llm_metadata: Any,\n    _mock_llmchain: Any,\n    _mock_predict: Any,\n    documents: List[Document],\n    struct_kwargs: Dict,\n) -> None:\n    \"\"\"Test build and count tokens.\"\"\"\n    index_kwargs, _ = struct_kwargs\n    # mock_prompts.MOCK_SUMMARY_PROMPT_TMPL adds a \"\\n\" to the document text\n    # and the document is 23 tokens\n    document_token_count = 24\n    llmchain_mock_resp_token_count = 10\n    tree = GPTTreeIndex(documents,", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 11, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "12": {"text": "= 10\n    tree = GPTTreeIndex(documents, **index_kwargs)\n    assert (\n        tree._llm_predictor.total_tokens_used\n        == document_token_count + llmchain_mock_resp_token_count\n    )\n", "doc_id": null, "embedding": null, "extra_info": {"file_path": "tests/indices/tree/test_base.py", "file_name": "test_base.py"}, "index": 12, "child_indices": [], "ref_doc_id": "afb4aa398df65ab659e297655a54660dc23d269e", "node_info": null}, "13": {"text": "This test file tests the GPTTreeIndex class, which is used to build a tree index from a list of documents. It tests the build_tree, build_tree_with_embed, build_tree_multiple, query, summarize_query, and insert functions. It checks the contents of the nodes in the tree index, and tests that the query and summarize query functions return the expected results. It also tests that the insert function correctly updates the tree index.", "doc_id": null, "embedding": null, "extra_info": null, "index": 13, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "ref_doc_id": null, "node_info": null}, "14": {"text": "This code file tests the functionality of the GPTTreeIndex class, which is used to store and index documents. It tests the insertion of documents from an empty index, as well as the build and count tokens feature. It also tests the left and right nodes of the index structure, and the reference document ID. The code uses the LLMChain, LLMPredictor, and OpenAI classes, as well as the mock_llmchain_predict function.", "doc_id": null, "embedding": null, "extra_info": null, "index": 14, "child_indices": [10, 11, 12], "ref_doc_id": null, "node_info": null}}, "root_nodes": {"13": {"text": "This test file tests the GPTTreeIndex class, which is used to build a tree index from a list of documents. It tests the build_tree, build_tree_with_embed, build_tree_multiple, query, summarize_query, and insert functions. It checks the contents of the nodes in the tree index, and tests that the query and summarize query functions return the expected results. It also tests that the insert function correctly updates the tree index.", "doc_id": null, "embedding": null, "extra_info": null, "index": 13, "child_indices": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "ref_doc_id": null, "node_info": null}, "14": {"text": "This code file tests the functionality of the GPTTreeIndex class, which is used to store and index documents. It tests the insertion of documents from an empty index, as well as the build and count tokens feature. It also tests the left and right nodes of the index structure, and the reference document ID. The code uses the LLMChain, LLMPredictor, and OpenAI classes, as well as the mock_llmchain_predict function.", "doc_id": null, "embedding": null, "extra_info": null, "index": 14, "child_indices": [10, 11, 12], "ref_doc_id": null, "node_info": null}}, "__type__": "tree"}}}}